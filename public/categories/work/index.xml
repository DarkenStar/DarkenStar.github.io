<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Work on WITHER</title>
    <link>http://localhost:57770/categories/work/</link>
    <description>Recent content in Work on WITHER</description>
    <generator>Hugo -- 0.147.7</generator>
    <language>en</language>
    <copyright>2024-2025 WITHER</copyright>
    <lastBuildDate>Wed, 11 Jun 2025 10:21:42 +0800</lastBuildDate>
    <atom:link href="http://localhost:57770/categories/work/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Tx8read</title>
      <link>http://localhost:57770/blogs/tx8read/</link>
      <pubDate>Wed, 11 Jun 2025 10:21:42 +0800</pubDate>
      <guid>http://localhost:57770/blogs/tx8read/</guid>
      <description>tx8 regression</description>
      <content:encoded><![CDATA[<h1 id="testgraphcompute">TestGraphCompute</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 1. 初始化与命令行参数处理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Timer</span> <span class="n">timer</span><span class="p">(</span><span class="s">&#34;TestGraphCompute&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">mlir</span><span class="o">::</span><span class="n">registerAsmPrinterCLOptions</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">mlir</span><span class="o">::</span><span class="n">registerMLIRContextCLOptions</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">mlir</span><span class="o">::</span><span class="n">registerPassManagerCLOptions</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 解析命令行参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cl</span><span class="o">::</span><span class="n">ParseCommandLineOptions</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="s">&#34;tx8be compiler</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 2. 初始化 MLIR 模块和上下文
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">mlir</span><span class="o">::</span><span class="n">OwningOpRef</span><span class="o">&lt;</span><span class="n">mlir</span><span class="o">::</span><span class="n">ModuleOp</span><span class="o">&gt;</span> <span class="n">module</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">mlir</span><span class="o">::</span><span class="n">MLIRContext</span> <span class="n">context</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 定义一个正则表达式，用于从命令行选项中提取 codegen_path 参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">regex</span> <span class="n">pattern</span><span class="p">(</span><span class="s">&#34;codegen_path=([a-zA-Z0-9_]+)&#34;</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">smatch</span> <span class="n">matches</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">cachePath</span> <span class="o">=</span> <span class="s">&#34;codegen&#34;</span><span class="p">;</span>  <span class="c1">// 默认文件夹名字
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">regex_search</span><span class="p">(</span><span class="n">optionstr</span><span class="p">,</span> <span class="n">matches</span><span class="p">,</span> <span class="n">pattern</span><span class="p">))</span> <span class="p">{</span>  <span class="c1">// 寻找命令行选项中是否指定 codegen_path
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">cachePath</span> <span class="o">=</span> <span class="n">matches</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 3. 加载 MLIR 模块
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果 cache 为 2 或 4，则从缓存路径加载模块；否则，使用默认的 gModelFil
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">gModelFile</span> <span class="o">=</span> <span class="p">(</span><span class="n">cache</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">cache</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="o">?</span> <span class="n">cachePath</span> <span class="o">+</span> <span class="s">&#34;/cache.mlir&#34;</span> <span class="o">:</span> <span class="n">gModelFile</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="n">getMLIRFromFile</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">gModelFile</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">error</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 4. 配置模块
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">auto</span> <span class="n">mconfig</span> <span class="o">=</span> <span class="n">getModuleConfig</span><span class="p">(</span><span class="n">module</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">optionstr</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">mconfig</span><span class="p">.</span><span class="n">option</span> <span class="o">+=</span> <span class="n">optionstr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">mconfig</span><span class="p">.</span><span class="n">constCache</span> <span class="o">=</span> <span class="n">cache</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">updateModuleConfig</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">mconfig</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">mconfig</span> <span class="o">=</span> <span class="n">getModuleConfig</span><span class="p">(</span><span class="n">module</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="n">showModuleConfig</span><span class="p">(</span><span class="n">mconfig</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 5. 处理多卡信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">json_info_multi_card_t</span> <span class="o">*</span><span class="n">multi_card_jinfo</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">multi_card_jinfo</span> <span class="o">=</span> <span class="p">(</span><span class="n">cache</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">cache</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="o">?</span> <span class="n">get_multi_card_info_from_file</span><span class="p">(</span><span class="n">cachePath</span> <span class="o">+</span> <span class="s">&#34;/model_info.json&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                                                <span class="o">:</span> <span class="n">parseMultiCardModuleInfo</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">context</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">dumpIR</span><span class="p">(</span><span class="n">module</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="nb">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 6. 读取参考路径
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fast_codegen</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// NOT fast_codegen
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">in_files</span> <span class="o">=</span> <span class="n">parseStringArgs</span><span class="p">(</span><span class="n">gInputBin</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&#34;,&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">out_files</span> <span class="o">=</span> <span class="n">parseStringArgs</span><span class="p">(</span><span class="n">gOutputBin</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&#34;,&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 定义一个 lambda 函数，用于从文件中读取参考文件路径。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">auto</span> <span class="n">getRefFiles</span> <span class="o">=</span> <span class="p">[]</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">gFile</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">files</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">gFile</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">llvm</span><span class="o">::</span><span class="n">sys</span><span class="o">::</span><span class="n">fs</span><span class="o">::</span><span class="n">exists</span><span class="p">(</span><span class="n">gFile</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">ifstream</span> <span class="n">gf</span><span class="p">(</span><span class="n">gFile</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">text</span><span class="p">((</span><span class="n">std</span><span class="o">::</span><span class="n">istreambuf_iterator</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="n">gf</span><span class="p">)),</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">istreambuf_iterator</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">()));</span>
</span></span><span class="line"><span class="cl">            <span class="n">files</span> <span class="o">=</span> <span class="n">parseStringArgs</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&#34;,&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">};</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">((</span><span class="n">gInputBin</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">gInputFile</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">getRefFiles</span><span class="p">(</span><span class="n">gInputFile</span><span class="p">,</span> <span class="n">in_files</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">getRefFiles</span><span class="p">(</span><span class="n">gOutputFile</span><span class="p">,</span> <span class="n">out_files</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 7. computeGolden
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">cache</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mconfig</span><span class="p">.</span><span class="n">tile</span><span class="p">.</span><span class="n">chip_num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 遍历芯片数量，创建对应的目录结构
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 构造并创建创建目 codegen/node_0_0/chip0/agent/data 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">path</span> <span class="o">=</span> <span class="s">&#34;codegen/node_0_0/chip&#34;</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">        <span class="n">path</span> <span class="o">+=</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#34;/agent/data&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">createDir</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 调用 computeGolden 函数，计算参考输出保存到 codegenPath
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">computeGolden</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">multi_card_jinfo</span><span class="p">,</span> <span class="n">in_files</span><span class="p">,</span> <span class="n">out_files</span><span class="p">,</span> <span class="n">mconfig</span><span class="p">.</span><span class="n">codegenPath</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 调用 moduleCompileCodegen 函数，对 MLIR 模块进行编译和代码生成
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int32_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">moduleCompileCodegen</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">context</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">ASSERT</span><span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="nb">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 9. 获取内存大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 从模块中获取立即数 (Immediate) 和常量参数的 DDR 大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">uint64_t</span> <span class="n">imm_size</span> <span class="o">=</span> <span class="n">module</span><span class="p">.</span><span class="n">get</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">hasAttr</span><span class="p">(</span><span class="n">tx8be</span><span class="o">::</span><span class="n">ModuleAttr</span><span class="o">::</span><span class="n">ImmDdrSize</span><span class="p">)</span> <span class="o">?</span>
</span></span><span class="line"><span class="cl">    <span class="n">module</span><span class="p">.</span><span class="n">get</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getAttrOfType</span><span class="o">&lt;</span><span class="n">mlir</span><span class="o">::</span><span class="n">IntegerAttr</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tx8be</span><span class="o">::</span><span class="n">ModuleAttr</span><span class="o">::</span><span class="n">ImmDdrSize</span><span class="p">).</span><span class="n">getInt</span><span class="p">()</span> <span class="o">:</span> <span class="mi">2147483648</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">    <span class="kt">uint64_t</span> <span class="n">params_size</span> <span class="o">=</span> <span class="n">module</span><span class="p">.</span><span class="n">get</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">hasAttr</span><span class="p">(</span><span class="n">tx8be</span><span class="o">::</span><span class="n">ModuleAttr</span><span class="o">::</span><span class="n">ConstDdrSize</span><span class="p">)</span> <span class="o">?</span>
</span></span><span class="line"><span class="cl">        <span class="n">module</span><span class="p">.</span><span class="n">get</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getAttrOfType</span><span class="o">&lt;</span><span class="n">mlir</span><span class="o">::</span><span class="n">IntegerAttr</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tx8be</span><span class="o">::</span><span class="n">ModuleAttr</span><span class="o">::</span><span class="n">ConstDdrSize</span><span class="p">).</span><span class="n">getInt</span><span class="p">()</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 10. 更新每个芯片的内存大小信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mconfig</span><span class="p">.</span><span class="n">tile</span><span class="p">.</span><span class="n">chip_num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">multi_card_jinfo</span><span class="o">-&gt;</span><span class="n">chip_infos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">imm_size</span> <span class="o">=</span> <span class="n">imm_size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">multi_card_jinfo</span><span class="o">-&gt;</span><span class="n">chip_infos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">params_size</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">params_size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 11. 保存多卡模型信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int32_t</span><span class="o">&gt;</span> <span class="n">chipIds</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">module</span><span class="p">.</span><span class="n">get</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">hasAttr</span><span class="p">(</span><span class="n">tx8be</span><span class="o">::</span><span class="n">ModuleAttr</span><span class="o">::</span><span class="n">ChipIds</span><span class="p">))</span> <span class="p">{</span>  <span class="c1">// 获取芯片 ID 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">mlir</span><span class="o">::</span><span class="n">ArrayAttr</span> <span class="n">chipIdsAttr</span> <span class="o">=</span> <span class="n">module</span><span class="p">.</span><span class="n">get</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getAttrOfType</span><span class="o">&lt;</span><span class="n">mlir</span><span class="o">::</span><span class="n">ArrayAttr</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tx8be</span><span class="o">::</span><span class="n">ModuleAttr</span><span class="o">::</span><span class="n">ChipIds</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">chipIdsAttr</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">chipIds</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">chipIdsAttr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">mlir</span><span class="o">::</span><span class="n">IntegerAttr</span><span class="o">&gt;</span><span class="p">().</span><span class="n">getInt</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 多卡模型文件保存到 codegenPath 路径下
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">saveMultiCardModelJson</span><span class="p">(</span><span class="n">multi_card_jinfo</span><span class="p">,</span> <span class="n">mconfig</span><span class="p">.</span><span class="n">codegenPath</span><span class="p">,</span> <span class="n">chipIds</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// uint64_t ddrSize = getModelDDRSize(multi_card_jinfo);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="computegolden">computeGolden</h2>
<p>输入参数的来源：</p>
<ul>
<li><code>module</code>：在 main 文件中，通过 <code>getMLIRFromFile</code> 函数从文件中加载 MLIR 模块</li>
<li><code>multi_card_jinfo</code>：在 main 文件中，通过 <code>get_multi_card_info_from_file</code> 或 <code>parseMultiCardModuleInfo</code> 从 JSON 文件或 MLIR 模块中提取多卡信息。</li>
<li><code>in_files</code> 和 <code>out_files</code>：在 main 文件中，通过 <code>parseStringArgs</code> 或 <code>getRefFiles</code> 解析输入和输出文件路径。</li>
<li><code>mconfig.codegenPath</code>：在 main 文件中，通过命令行选项或默认值设置代码生成路径，并传递给 computeGolden。</li>
</ul>
<p>computeGolden 函数生成的数据（输入和输出的二进制文件）将保存到指定路径 mconfig.codegenPath.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">computeGolden</span><span class="p">(</span><span class="n">mlir</span><span class="o">::</span><span class="n">OwningOpRef</span><span class="o">&lt;</span><span class="n">mlir</span><span class="o">::</span><span class="n">ModuleOp</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">module</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                   <span class="n">json_info_multi_card_t</span> <span class="o">*</span><span class="n">multi_card_jinfo</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                   <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">inFiles</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                   <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">outFiles</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                   <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">file_path</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 定义形状类型，用于存储多维张量的形状信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">using</span> <span class="n">ShapeType</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 用于存储多芯片的输入和输出数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int8_t</span> <span class="o">*&gt;&gt;</span> <span class="n">multiInputDdata</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int8_t</span> <span class="o">*&gt;&gt;</span> <span class="n">multiOutputData</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">threads</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">uint32_t</span> <span class="n">chip_num</span> <span class="o">=</span> <span class="n">multi_card_jinfo</span><span class="o">-&gt;</span><span class="n">chip_num</span><span class="p">;</span>  <span class="c1">// 获取芯片数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">auto</span> <span class="n">tile_info</span> <span class="o">=</span> <span class="n">get_tileinfo</span><span class="p">(</span><span class="n">module</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>  <span class="c1">// 从 MLIR 模块中提取 tile 信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ShapeType</span><span class="o">&gt;</span> <span class="n">outShapes</span><span class="p">(</span><span class="n">chip_num</span><span class="p">);</span>  <span class="c1">// 存储每个芯片的输出形状信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">chip_num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">chip_info_t</span> <span class="o">*</span><span class="n">chip_info</span> <span class="o">=</span> <span class="n">multi_card_jinfo</span><span class="o">-&gt;</span><span class="n">chip_infos</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 分配当前芯片的输入和输出数据指针数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int8_t</span> <span class="o">*&gt;</span> <span class="n">input_data</span><span class="p">(</span><span class="n">chip_info</span><span class="o">-&gt;</span><span class="n">input_num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int8_t</span> <span class="o">*&gt;</span> <span class="n">output_data</span><span class="p">(</span><span class="n">chip_info</span><span class="o">-&gt;</span><span class="n">output_num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 用于 OneDNN 计算的输入和输出缓冲区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span> <span class="o">*&gt;</span> <span class="n">computeInputs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span> <span class="o">*&gt;</span> <span class="n">computeOutputs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 当前芯片的输入和输出文件路径
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">chipInFiles</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">chipOutFiles</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">parseInOutfile</span><span class="p">(</span><span class="n">inFiles</span><span class="p">,</span> <span class="n">chipInFiles</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">chip_num</span><span class="p">,</span> <span class="n">chip_info</span><span class="o">-&gt;</span><span class="n">input_num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">parseInOutfile</span><span class="p">(</span><span class="n">outFiles</span><span class="p">,</span> <span class="n">chipOutFiles</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">chip_num</span><span class="p">,</span> <span class="n">chip_info</span><span class="o">-&gt;</span><span class="n">output_num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 生成当前芯片的输入输出数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">genInputs4SingleChip</span><span class="p">(</span><span class="n">computeInputs</span><span class="p">,</span> <span class="n">input_data</span><span class="p">,</span> <span class="n">chip_info</span><span class="p">,</span> <span class="n">chipInFiles</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">genOutputs4SingleChip</span><span class="p">(</span><span class="n">computeOutputs</span><span class="p">,</span> <span class="n">output_data</span><span class="p">,</span> <span class="n">chip_info</span><span class="p">,</span> <span class="n">chipOutFiles</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果输入文件为空，则生成随机输入数据并校正
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">chipInFiles</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">updateSpecialInputData</span><span class="p">(</span><span class="n">computeModuleRef</span><span class="p">,</span> <span class="n">computeInputs</span><span class="p">,</span> <span class="n">input_data</span><span class="p">,</span> <span class="n">chip_info</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">multiInputDdata</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">input_data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">multiOutputData</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">output_data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">outFiles</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">threads</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">moduleComputeInterface</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">computeModuleRef</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">outShapes</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">computeInputs</span><span class="p">,</span> <span class="n">computeOutputs</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 等待所有线程完成计算
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="kr">thread</span> <span class="o">:</span> <span class="n">threads</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kr">thread</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 遍历每个芯片，保存输入和输出数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">chip_num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">chip_info_t</span> <span class="o">*</span><span class="n">chip_info</span> <span class="o">=</span> <span class="n">multi_card_jinfo</span><span class="o">-&gt;</span><span class="n">chip_infos</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kt">uint32_t</span> <span class="n">node_id</span> <span class="o">=</span> <span class="n">get_node_id</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">tile_info</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int32_t</span> <span class="n">relative_chip_id</span> <span class="o">=</span> <span class="n">get_relative_chip_id</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">tile_info</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 构造当前芯片的数据保存路径  file_path/node_x_y/chip_z/agent/data
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">data_path</span> <span class="o">=</span> <span class="n">file_path</span> <span class="o">+</span> <span class="s">&#34;/node_&#34;</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">node_id</span> <span class="o">/</span> <span class="n">tile_info</span><span class="p">.</span><span class="n">node_y</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#34;_&#34;</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">node_id</span> <span class="o">%</span> <span class="n">tile_info</span><span class="p">.</span><span class="n">node_y</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#34;/chip&#34;</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">relative_chip_id</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#34;/agent/data&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">createDir</span><span class="p">(</span><span class="n">data_path</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// bin格式保存当前芯片的输入数据  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">chip_info</span><span class="o">-&gt;</span><span class="n">input_num</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">inout_tensor_info_t</span> <span class="o">*</span><span class="n">tensor</span> <span class="o">=</span> <span class="n">chip_info</span><span class="o">-&gt;</span><span class="n">input</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="n">saveInOutTensor</span><span class="p">(</span><span class="n">tensor</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">,</span> <span class="n">tensor</span><span class="o">-&gt;</span><span class="n">dim</span><span class="p">,</span> <span class="n">tensor</span><span class="o">-&gt;</span><span class="n">layout</span><span class="p">,</span> <span class="n">tensor</span><span class="o">-&gt;</span><span class="n">dtype</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                           <span class="n">data_path</span> <span class="o">+</span> <span class="s">&#34;/in&#34;</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#34;.bin&#34;</span><span class="p">,</span> <span class="n">multiInputDdata</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// bin格式保存当前芯片的输出数据  out_j_ref.bin
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">chip_info</span><span class="o">-&gt;</span><span class="n">output_num</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">inout_tensor_info_t</span> <span class="o">*</span><span class="n">tensor</span> <span class="o">=</span> <span class="n">chip_info</span><span class="o">-&gt;</span><span class="n">output</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int32_t</span> <span class="n">tensorShape</span><span class="p">[</span><span class="n">MAX_SHAPE_DIM</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// 根据 outShapes 或原始形状计算输出张量的形状
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">tensor</span><span class="o">-&gt;</span><span class="n">dim</span><span class="p">;</span> <span class="o">++</span><span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">outShapes</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">tensorShape</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">outShapes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">idx</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">tensorShape</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">tensor</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// 保存输出数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">saveInOutTensor</span><span class="p">(</span><span class="n">tensorShape</span><span class="p">,</span> <span class="n">tensor</span><span class="o">-&gt;</span><span class="n">dim</span><span class="p">,</span> <span class="n">tensor</span><span class="o">-&gt;</span><span class="n">layout</span><span class="p">,</span> <span class="n">tensor</span><span class="o">-&gt;</span><span class="n">dtype</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                           <span class="n">data_path</span> <span class="o">+</span> <span class="s">&#34;/out&#34;</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#34;_ref.bin&#34;</span><span class="p">,</span> <span class="n">multiOutputData</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 释放当前芯片的输入和输出数据内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">chip_info</span><span class="o">-&gt;</span><span class="n">input_num</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">free</span><span class="p">(</span><span class="n">multiInputDdata</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">chip_info</span><span class="o">-&gt;</span><span class="n">output_num</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">free</span><span class="p">(</span><span class="n">multiOutputData</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="run_code_gen_layer">run_code_gen_layer</h1>
<p>主要用于运行代码生成 (codegen) 相关的任务，以下是函数的详细功能解释：</p>
<ol>
<li>解析参数：</li>
</ol>
<ul>
<li>接受至少两个参数：$1 是可执行文件的名称，$2 是种子文件 (seed file)</li>
<li>如果有更多参数 ($# &gt; 2)，则将额外参数存储为配置参数 (config_params)</li>
<li>从 config_params 中提取 <code>codegen_path</code> (代码生成输出路径) ，如果未指定则使用默认值 &ldquo;codegen&rdquo;</li>
</ul>
<ol start="2">
<li>切换工作目录：</li>
</ol>
<ul>
<li>切换到 <code>${BEMLIR_PROJECT_ROOT}/build/bin</code> 目录。</li>
<li>删除旧的 <code>codegen_path</code> 目录，确保环境干净。</li>
</ul>
<ol start="3">
<li>执行可执行文件：</li>
</ol>
<ul>
<li>使用 <code>${layer_cmd}</code> (即 ./$1) 运行指定的可执行文件，传入种子文件和配置参数。</li>
<li>检查返回值，如果失败 <code>(ret != 0)</code>，则恢复目录并返回错误。</li>
</ul>
<ol start="4">
<li>处理生成的代码：</li>
</ol>
<ul>
<li>根据参数中的 <code>chip_num</code> 或 <code>static_shape</code> 判断 <code>host_type</code>.</li>
<li>调用 <code>get_codegen_file</code> 处理生成的代码文件。</li>
</ul>
<ol start="5">
<li>运行 cmodel 测试:</li>
</ol>
<ul>
<li>根据参数中的 <code>fast_codegen</code> 或 <code>not_run</code> 设置 cmp_flag.</li>
<li>调用 <code>run_on_cmodel</code> 在 cmodel 上运行生成的代码。</li>
<li>检查返回值，失败则返回错误。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># 定义 run_codegen_layer 函数，用于运行代码生成层测试流程</span>
</span></span><span class="line"><span class="cl"><span class="k">function</span> run_codegen_layer<span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 1. 打印开始时间，用于调试和性能追踪</span>
</span></span><span class="line"><span class="cl">    <span class="nb">echo</span> -n <span class="s2">&#34;time==&gt;&gt;run_codegen_layer-start   &#34;</span><span class="p">;</span> date<span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># 2. 函数参数说明</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># $1: 可执行文件名称</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># $2: 种子文件 (seed file）</span>
</span></span><span class="line"><span class="cl">    <span class="nv">layer_cmd</span><span class="o">=</span><span class="s2">&#34;./</span><span class="nv">$1</span><span class="s2">&#34;</span>  <span class="c1"># 在当前目录下执行的可执行文件路径</span>
</span></span><span class="line"><span class="cl">    <span class="nv">seed_file</span><span class="o">=</span><span class="nv">$2</span>      <span class="c1"># 种子文件或配置文件</span>
</span></span><span class="line"><span class="cl">    <span class="nv">config_params</span><span class="o">=</span><span class="s2">&#34;&#34;</span>  <span class="c1"># 配置参数，默认为空</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># 默认代码生成输出路径</span>
</span></span><span class="line"><span class="cl">    <span class="nv">codegen_path</span><span class="o">=</span><span class="s2">&#34;codegen&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># 3. 检查是否有超过2个参数</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">[</span> <span class="nv">$#</span> -gt <span class="m">2</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 提取除前两个参数外的所有参数作为配置参数</span>
</span></span><span class="line"><span class="cl">        <span class="nv">config_params</span><span class="o">=</span><span class="nv">$*</span>
</span></span><span class="line"><span class="cl">        <span class="nv">config_params</span><span class="o">=</span><span class="si">${</span><span class="nv">config_params</span><span class="p">#*</span><span class="si">}</span>  <span class="c1"># 移除第一个参数 (可执行文件）</span>
</span></span><span class="line"><span class="cl">        <span class="nv">config_params</span><span class="o">=</span><span class="si">${</span><span class="nv">config_params</span><span class="p">#*</span><span class="si">}</span>  <span class="c1"># 移除第二个参数 (种子文件）</span>
</span></span><span class="line"><span class="cl">    <span class="k">fi</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># 4. 如果配置参数中包含 --codegen_path，提取其值作为代码生成路径</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">[[</span> <span class="si">${</span><span class="nv">config_params</span><span class="si">}</span> <span class="o">==</span> *<span class="s2">&#34;--codegen_path=&#34;</span>* <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 提取 --codegen_path= 后面的值</span>
</span></span><span class="line"><span class="cl">        <span class="nv">codegen_path</span><span class="o">=</span><span class="si">${</span><span class="nv">config_params</span><span class="p">#*codegen_path=</span><span class="si">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 移除可能存在的引号或其他字符</span>
</span></span><span class="line"><span class="cl">        <span class="nv">codegen_path</span><span class="o">=</span><span class="si">${</span><span class="nv">codegen_path</span><span class="p">%%</span><span class="se">\&#34;</span><span class="p">*</span><span class="si">}</span>
</span></span><span class="line"><span class="cl">        <span class="nv">codegen_path</span><span class="o">=</span><span class="si">${</span><span class="nv">codegen_path</span><span class="p">-*</span><span class="si">}</span>
</span></span><span class="line"><span class="cl">        <span class="nv">codegen_path</span><span class="o">=</span><span class="si">${</span><span class="nv">codegen_path</span><span class="p">*</span><span class="si">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">fi</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># 5. 切换到 build/bin 目录执行命令</span>
</span></span><span class="line"><span class="cl">    <span class="nb">pushd</span> <span class="si">${</span><span class="nv">BEMLIR_PROJECT_ROOT</span><span class="si">}</span>/build/bin
</span></span><span class="line"><span class="cl">        <span class="c1"># 删除旧的 codegen_path 目录，确保环境干净</span>
</span></span><span class="line"><span class="cl">        rm -rf <span class="si">${</span><span class="nv">codegen_path</span><span class="si">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 执行层命令，传入种子文件和配置参数</span>
</span></span><span class="line"><span class="cl">        <span class="si">${</span><span class="nv">layer_cmd</span><span class="si">}</span> <span class="si">${</span><span class="nv">seed_file</span><span class="si">}</span> <span class="si">${</span><span class="nv">config_params</span><span class="si">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 捕获命令的返回值</span>
</span></span><span class="line"><span class="cl">        <span class="nv">ret</span><span class="o">=</span><span class="nv">$?</span>  
</span></span><span class="line"><span class="cl">        <span class="c1"># 如果命令执行失败 (返回码非0），恢复目录并返回错误</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">[[</span> <span class="si">${</span><span class="nv">ret</span><span class="si">}</span> -ne <span class="m">0</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="cl">            <span class="nb">popd</span>
</span></span><span class="line"><span class="cl">            <span class="nb">echo</span> <span class="si">${</span><span class="nv">ret</span><span class="si">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="si">${</span><span class="nv">ret</span><span class="si">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">fi</span>
</span></span><span class="line"><span class="cl">    <span class="nb">popd</span>  <span class="c1"># 恢复原始目录</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># 6. 打印代码生成完成的时间</span>
</span></span><span class="line"><span class="cl">    <span class="nb">echo</span> -n <span class="s2">&#34;time==&gt;&gt;run_codegen_layer-codegen=== &#34;</span><span class="p">;</span> date<span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># 7. 根据参数判断主机类型</span>
</span></span><span class="line"><span class="cl">    <span class="nv">host_type</span><span class="o">=</span><span class="m">0</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 如果参数中包含 chip_num 或 static_shape，则将 host_type 设为 1</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">[[</span> <span class="nv">$*</span> <span class="o">==</span> *<span class="s2">&#34;chip_num&#34;</span>* <span class="o">]]</span> <span class="o">||</span> <span class="o">[[</span> <span class="nv">$*</span> <span class="o">==</span> *<span class="s2">&#34;static_shape&#34;</span>* <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="cl">        <span class="nv">host_type</span><span class="o">=</span><span class="m">1</span>
</span></span><span class="line"><span class="cl">    <span class="k">fi</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># 8. 调用 get_codegen_file 处理生成的代码文件</span>
</span></span><span class="line"><span class="cl">    get_codegen_file <span class="si">${</span><span class="nv">codegen_path</span><span class="si">}</span> <span class="si">${</span><span class="nv">host_type</span><span class="si">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 捕获返回值</span>
</span></span><span class="line"><span class="cl">    <span class="nv">ret</span><span class="o">=</span><span class="nv">$?</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 如果处理失败，恢复目录并返回错误</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">[[</span> <span class="si">${</span><span class="nv">ret</span><span class="si">}</span> -ne <span class="m">0</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="cl">        <span class="nb">popd</span>
</span></span><span class="line"><span class="cl">        <span class="nb">echo</span> <span class="si">${</span><span class="nv">ret</span><span class="si">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="si">${</span><span class="nv">ret</span><span class="si">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">fi</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># 9. 初始化比较标志</span>
</span></span><span class="line"><span class="cl">    <span class="nv">cmp_flag</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 如果参数中包含 fast_codegen 或 not_run，则设置 cmp_flag 为 &#34;not_run&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">[[</span> <span class="nv">$*</span> <span class="o">==</span> *<span class="s2">&#34;fast_codegen&#34;</span>* <span class="o">]]</span> <span class="o">||</span> <span class="o">[[</span> <span class="nv">$*</span> <span class="o">==</span> *<span class="s2">&#34;not_run&#34;</span>* <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="cl">        <span class="nv">cmp_flag</span><span class="o">=</span><span class="s2">&#34;not_run&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="k">fi</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># 10. 在 cmodel 上运行生成的代码，传入比较标志</span>
</span></span><span class="line"><span class="cl">    run_on_cmodel <span class="si">${</span><span class="nv">codegen_path</span><span class="si">}</span> <span class="si">${</span><span class="nv">cmp_flag</span><span class="si">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 捕获返回值</span>
</span></span><span class="line"><span class="cl">    <span class="nv">ret</span><span class="o">=</span><span class="nv">$?</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 如果运行失败，恢复目录并返回错误</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">[[</span> <span class="si">${</span><span class="nv">ret</span><span class="si">}</span> -ne <span class="m">0</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="cl">        <span class="nb">popd</span>
</span></span><span class="line"><span class="cl">        <span class="nb">echo</span> <span class="si">${</span><span class="nv">ret</span><span class="si">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="si">${</span><span class="nv">ret</span><span class="si">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">fi</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># 11. 打印结束时间</span>
</span></span><span class="line"><span class="cl">    <span class="nb">echo</span> -n <span class="s2">&#34;time==&gt;&gt;run codegen layer-end===   &#34;</span><span class="p">;</span> date<span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h2 id="get_codegen_file">get_codegen_file</h2>
<p><code>get_codegen_file</code> 用于整理代码生成的结果 (位于 <code>${BEMLIR_PROJECT_ROOT}/build/bin/${codegen_case}</code>)，为每个节点生成版本信息 (version.txt)，并将生成的文件复制到测试目录 (<code>${BEMLIR_PROJECT_ROOT}/external/tx8be-oplib/tests/test_codegen</code>)，最后调用 <code>get_codegen_host</code> 完成主机相关处理。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># Function to process and organize generated codegen files</span>
</span></span><span class="line"><span class="cl"><span class="k">function</span> get_codegen_file<span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Print all input arguments for debugging</span>
</span></span><span class="line"><span class="cl">    <span class="nb">echo</span> <span class="s2">&#34;</span><span class="nv">$*</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Assign first argument as the codegen case name or path</span>
</span></span><span class="line"><span class="cl">    <span class="nv">codegen_case</span><span class="o">=</span><span class="nv">$1</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Second argument: 0 for host thread mode, 1 for host stream mode</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Note: $2 is passed to get_codegen_host</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Change to the codegen case directory under build/bin</span>
</span></span><span class="line"><span class="cl">    <span class="nb">pushd</span> <span class="s2">&#34;</span><span class="si">${</span><span class="nv">BEMLIR_PROJECT_ROOT</span><span class="si">}</span><span class="s2">/build/bin/</span><span class="si">${</span><span class="nv">codegen_case</span><span class="si">}</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># Find node directories matching node_[0-9]+_[0-9] pattern (e.g., node_123_4)</span>
</span></span><span class="line"><span class="cl">        <span class="nv">node_dirs</span><span class="o">=</span><span class="k">$(</span>find . -maxdepth <span class="m">1</span> -type d -regex <span class="s1">&#39;.*/node_[0-9]+_[0-9]&#39;</span> -exec basename <span class="o">{}</span> <span class="se">\;</span><span class="k">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># Iterate through each node directory</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> dir in <span class="nv">$node_dirs</span><span class="p">;</span> <span class="k">do</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># Check if libTX8MLIRTransforms.a exists to determine version type</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="o">[</span> ! -e <span class="s2">&#34;</span><span class="si">${</span><span class="nv">BEMLIR_PROJECT_ROOT</span><span class="si">}</span><span class="s2">/lib/libTX8MLIRTransforms.a&#34;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="cl">                <span class="c1"># Write &#39;tx8be-mlir&#39; to version.txt if library is absent</span>
</span></span><span class="line"><span class="cl">                <span class="nb">echo</span> -e <span class="s2">&#34;tx8be-mlir&#34;</span> &gt; <span class="s2">&#34;</span><span class="si">${</span><span class="nv">dir</span><span class="si">}</span><span class="s2">/version.txt&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span>
</span></span><span class="line"><span class="cl">                <span class="c1"># Write &#39;tx8be-mlir-sdk&#39; to version.txt if library is present</span>
</span></span><span class="line"><span class="cl">                <span class="nb">echo</span> -e <span class="s2">&#34;tx8be-mlir-sdk&#34;</span> &gt; <span class="s2">&#34;</span><span class="si">${</span><span class="nv">dir</span><span class="si">}</span><span class="s2">/version.txt&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="k">fi</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># Append git status to version.txt to record repository state</span>
</span></span><span class="line"><span class="cl">            git status --porcelain &gt;&gt; <span class="s2">&#34;</span><span class="si">${</span><span class="nv">dir</span><span class="si">}</span><span class="s2">/version.txt&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># Append last two git commits to version.txt for version history</span>
</span></span><span class="line"><span class="cl">            git log -2 &gt;&gt; <span class="s2">&#34;</span><span class="si">${</span><span class="nv">dir</span><span class="si">}</span><span class="s2">/version.txt&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="k">done</span>
</span></span><span class="line"><span class="cl">    <span class="nb">popd</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Change to the test_codegen directory</span>
</span></span><span class="line"><span class="cl">    <span class="nb">pushd</span> <span class="s2">&#34;</span><span class="si">${</span><span class="nv">BEMLIR_PROJECT_ROOT</span><span class="si">}</span><span class="s2">/external/tx8be-oplib/tests/test_codegen&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># Remove existing codegen_case directory to ensure a clean state</span>
</span></span><span class="line"><span class="cl">        rm -rf <span class="s2">&#34;</span><span class="si">${</span><span class="nv">codegen_case</span><span class="si">}</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># Copy the codegen_case directory from build/bin</span>
</span></span><span class="line"><span class="cl">        cp -r <span class="s2">&#34;</span><span class="si">${</span><span class="nv">BEMLIR_PROJECT_ROOT</span><span class="si">}</span><span class="s2">/build/bin/</span><span class="si">${</span><span class="nv">codegen_case</span><span class="si">}</span><span class="s2">&#34;</span> .
</span></span><span class="line"><span class="cl">    <span class="nb">popd</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Call get_codegen_host to process host-related tasks</span>
</span></span><span class="line"><span class="cl">    get_codegen_host <span class="s2">&#34;</span><span class="si">${</span><span class="nv">codegen_case</span><span class="si">}</span><span class="s2">&#34;</span> <span class="s2">&#34;</span><span class="nv">$2</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h2 id="get_codegen_host">get_codegen_host</h2>
<p><code>get_codegen_host </code> 用于为 host 环境准备代码生成用例的测试文件。它在指定的测试用例目录中处理 node &amp; chip 相关的文件，复制必要的配置文件、源代码和构建脚本，并根据 host_type 选择不同的主机实现文件 host_thread.cpp 或 host_stream.cpp.</p>
<ol>
<li>函数输入参数：</li>
</ol>
<ul>
<li><code>$1 (codegen_case)</code>: 代码生成用例的名称或路径，通常是一个目录 (例如 codegen0 或 codegen1) ，表示测试用例的根目录。</li>
<li><code>$2 (host_type)</code>: 主机执行模式，0: host_thread.cpp，1: host_stream.cpp.</li>
</ul>
<ol start="2">
<li>切换到 <code>${{OPLIB_PROJECT_ROOT}}/tests/test_codegen/${codegen_case}</code> 目录:</li>
</ol>
<ul>
<li>使用 find 命令查找符合 node_[0-9]+_[0-9] 模式 (例如 node_123_4) 的子目录，表示代码生成中的节点。</li>
<li>对每个 node_dir 追加版本信息和复制相关文件。</li>
</ul>
<ol start="3">
<li>处理 chip 目录:</li>
</ol>
<ul>
<li>在每个节点目录下，查找符合 <code> chip[0-9]+</code> 模式 (例如 chip0, chip1) 的子目录</li>
<li>为每个 dir 复制 Makefile_tile 到 <code>./${node_dir}/${dir}/Makefile</code>. 在 <code>./${node_dir}/${dir}/</code> 下创建 16 个子目录 (tiles0 - tiles15)，并为每个子目录复制 Makefile_main 到 t <code>iles$i/Makefile</code></li>
</ul>
<ol start="4">
<li>根据 <code>host_type</code> 复制 host_thread.cpp 或 host_stream.cpp 到当前目录的 host.cpp.</li>
<li>复制 CMakeLists.txt 和 Makefile 到当前目录。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># Function to prepare host-related files for a codegen test case</span>
</span></span><span class="line"><span class="cl"><span class="k">function</span> get_codegen_host<span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Print all input arguments for debugging</span>
</span></span><span class="line"><span class="cl">    <span class="nb">echo</span> <span class="s2">&#34;</span><span class="nv">$*</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Assign first argument as the codegen case name or path</span>
</span></span><span class="line"><span class="cl">    <span class="nv">codegen_case</span><span class="o">=</span><span class="nv">$1</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Assign second argument as host type (0: thread mode, 1: stream mode)</span>
</span></span><span class="line"><span class="cl">    <span class="nv">host_type</span><span class="o">=</span><span class="nv">$2</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Define relative path for test_codegen directory</span>
</span></span><span class="line"><span class="cl">    <span class="nv">oplib_path</span><span class="o">=</span><span class="s2">&#34;tests/test_codegen&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Change to the test_codegen directory for the codegen case</span>
</span></span><span class="line"><span class="cl">    <span class="nb">pushd</span> <span class="s2">&#34;</span><span class="si">${</span><span class="p">{OPLIB_PROJECT_ROOT</span><span class="si">}</span><span class="s2">}/tests/test_codegen/</span><span class="si">${</span><span class="nv">codegen_case</span><span class="si">}</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># Find node directories matching node_[0-9]+_[0-9] pattern (e.g., node_123_4)</span>
</span></span><span class="line"><span class="cl">        <span class="nv">node_dirs</span><span class="o">=</span><span class="k">$(</span>find . -maxdepth <span class="m">1</span> -type d -regex <span class="s1">&#39;.*/node_[0-9]+_[0-9]&#39;</span> -exec basename <span class="o">{}</span> <span class="se">\;</span><span class="k">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> node_dir in <span class="nv">$node_dirs</span><span class="p">;</span> <span class="k">do</span>  <span class="c1"># # Iterate through each node directory</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># Append oplib version info to version.txt</span>
</span></span><span class="line"><span class="cl">            <span class="nb">echo</span> -e <span class="s2">&#34;\n\ntx8be-oplib:&#34;</span> &gt;&gt; <span class="s2">&#34;</span><span class="si">${</span><span class="nv">node_dir</span><span class="si">}</span><span class="s2">/version.txt&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># Append git status to version.txt to record repository state</span>
</span></span><span class="line"><span class="cl">            git status --porcelain &gt;&gt; <span class="s2">&#34;</span><span class="si">${</span><span class="nv">node_dir</span><span class="si">}</span><span class="s2">/version.txt&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># Write last two git commits to version.txt for version history</span>
</span></span><span class="line"><span class="cl">            git log -2 &gt;&gt; <span class="s2">&#34;</span><span class="si">${</span><span class="nv">node_dir</span><span class="si">}</span><span class="s2">/version.txt&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1"># Copy all stream-related files to node directory</span>
</span></span><span class="line"><span class="cl">            cp <span class="s2">&#34;</span><span class="si">${</span><span class="p">{OPLIB_PROJECT_ROOT</span><span class="si">}</span><span class="s2">}/tools/codegen/stream*&#34;</span> <span class="s2">&#34;./</span><span class="si">${</span><span class="nv">node_dir</span><span class="si">}</span><span class="s2">/&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># Copy CMakeLists_chip.txt as CMakeLists.txt for node</span>
</span></span><span class="line"><span class="cl">            cp <span class="s2">&#34;</span><span class="si">${</span><span class="p">{OPLIB_PROJECT_ROOT</span><span class="si">}</span><span class="s2">}/tools/codegen/CMakeLists_chip.txt&#34;</span> <span class="s2">&#34;./</span><span class="si">${</span><span class="nv">node_dir</span><span class="si">}</span><span class="s2">/CMakeLists.txt&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># Copy main_kcore.c to node directory</span>
</span></span><span class="line"><span class="cl">            cp <span class="s2">&#34;</span><span class="si">${</span><span class="p">{OPLIB_PROJECT_ROOT</span><span class="si">}</span><span class="s2">}/tools/codegen/main_kcore.c&#34;</span> <span class="s2">&#34;./</span><span class="si">${</span><span class="nv">node_dir</span><span class="si">}</span><span class="s2">/&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># Copy Makefile_chip as Makefile for node</span>
</span></span><span class="line"><span class="cl">            cp <span class="s2">&#34;</span><span class="si">${</span><span class="p">{OPLIB_PROJECT_ROOT</span><span class="si">}</span><span class="s2">}/tools/codegen/Makefile_chip&#34;</span> <span class="s2">&#34;./</span><span class="si">${</span><span class="nv">node_dir</span><span class="si">}</span><span class="s2">/Makefile&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1"># Find chip directories matching chip[0-9]+ pattern (e.g., chip0, chip1)</span>
</span></span><span class="line"><span class="cl">            <span class="nv">chip_dirs</span><span class="o">=</span><span class="k">$(</span>find <span class="s2">&#34;./</span><span class="si">${</span><span class="nv">node_dir</span><span class="si">}</span><span class="s2">&#34;</span> -maxdepth <span class="m">1</span> -type d -regex <span class="s1">&#39;.*/chip[0-9]+&#39;</span> -exec basename <span class="o">{}</span> <span class="se">\;</span><span class="k">)</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># Iterate through each chip directory</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> dir in <span class="nv">$chip_dirs</span><span class="p">;</span> <span class="k">do</span>
</span></span><span class="line"><span class="cl">                <span class="c1"># Copy Makefile_tile as Makefile for chip</span>
</span></span><span class="line"><span class="cl">                cp <span class="s2">&#34;</span><span class="si">${</span><span class="p">{OPLIB_PROJECT_ROOT</span><span class="si">}</span><span class="s2">}/tools/codegen/Makefile_tile&#34;</span> <span class="s2">&#34;./</span><span class="si">${</span><span class="nv">node_dir</span><span class="si">}</span><span class="s2">/</span><span class="si">${</span><span class="nv">dir</span><span class="si">}</span><span class="s2">/Makefile&#34;</span>
</span></span><span class="line"><span class="cl">                <span class="c1"># Create Makefiles for 16 tiles (tiles0 to tiles15)</span>
</span></span><span class="line"><span class="cl">                <span class="k">for</span> <span class="o">((</span><span class="nv">i</span><span class="o">=</span>0<span class="p">;</span> i&lt;16<span class="p">;</span> i++<span class="o">))</span><span class="p">;</span> <span class="k">do</span>
</span></span><span class="line"><span class="cl">                    <span class="nv">dst_file</span><span class="o">=</span><span class="s2">&#34;./</span><span class="si">${</span><span class="nv">node_dir</span><span class="si">}</span><span class="s2">/</span><span class="si">${</span><span class="nv">dir</span><span class="si">}</span><span class="s2">/tiles</span><span class="si">${</span><span class="nv">i</span><span class="si">}</span><span class="s2">/Makefile&#34;</span>
</span></span><span class="line"><span class="cl">                    <span class="c1"># Copy Makefile_main to each tile&#39;s Makefile</span>
</span></span><span class="line"><span class="cl">                    cp <span class="s2">&#34;</span><span class="si">${</span><span class="p">{OPLIB_PROJECT_ROOT</span><span class="si">}</span><span class="s2">}/tools/codegen/Makefile_main&#34;</span> <span class="s2">&#34;</span><span class="nv">$dst_file</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl">                <span class="k">done</span>
</span></span><span class="line"><span class="cl">            <span class="k">done</span>
</span></span><span class="line"><span class="cl">        <span class="k">done</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># Copy host implementation based on host_type</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">[</span> <span class="nv">$host_type</span> -eq <span class="m">0</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># Use thread-based host implementation</span>
</span></span><span class="line"><span class="cl">            cp <span class="s2">&#34;</span><span class="si">${</span><span class="p">{OPLIB_PROJECT_ROOT</span><span class="si">}</span><span class="s2">}/tools/codegen/host_thread.cpp&#34;</span> <span class="s2">&#34;host.cpp&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># Use stream-based host implementation</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># Note: Fixed typo &#39;$t{OPLIB_PROJECT_ROOT}&#39; to &#39;${{OPLIB_PROJECT_ROOT}}&#39;</span>
</span></span><span class="line"><span class="cl">            cp <span class="s2">&#34;</span><span class="si">${</span><span class="p">{OPLIB_PROJECT_ROOT</span><span class="si">}</span><span class="s2">}/tools/codegen/host_stream.cpp&#34;</span> <span class="s2">&#34;host.cpp&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="k">fi</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># Copy top-level CMakeLists.txt for test case</span>
</span></span><span class="line"><span class="cl">        cp <span class="s2">&#34;</span><span class="si">${</span><span class="p">{OPLIB_PROJECT_ROOT</span><span class="si">}</span><span class="s2">}/tools/codegen/CMakeLists.txt&#34;</span> .
</span></span><span class="line"><span class="cl">        <span class="c1"># Copy top-level Makefile for test case</span>
</span></span><span class="line"><span class="cl">        cp <span class="s2">&#34;</span><span class="si">${</span><span class="p">{OPLIB_PROJECT_ROOT</span><span class="si">}</span><span class="s2">}/tools/codegen/Makefile&#34;</span> .
</span></span><span class="line"><span class="cl">    <span class="c1"># Restore original directory</span>
</span></span><span class="line"><span class="cl">    <span class="nb">popd</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h2 id="run_on_cmodel">run_on_cmodel</h2>
<p><code>run_on_cmodel</code> 用于在指定的测试用例目录中运行 cmodel 仿真任务。函数的主要功能包括环境设置、构建、执行仿真脚本或程序，并处理错误。以下是详细的功能说明：</p>
<ol>
<li>函数输入参数：</li>
</ol>
<ul>
<li>$1 (case_name): 来自 <code>run_codegen_layer</code> 的 <code>codegen_path</code>，可能附加 <code>host_type</code>.</li>
<li>$2 (run_flag): 运行标志，来自 <code>run_codegen_layer</code> 的 <code>cmp_flag</code> 用于控制仿真执行的方式 (例如是否运行或运行模式) 。</li>
</ul>
<ol start="2">
<li>切换工作目录并执行:</li>
</ol>
<ul>
<li>切换到测试用例目录 <code>${{OPLIB_PROJECT_ROOT}}/tests/test_codegen/${case_name}</code></li>
<li>运行 <code>cmake .. -DUSING_RISCV=OFF</code>，配置构建系统，禁用 RISCV 支持。</li>
<li>运行 <code>make -j</code> 并动态设置并行任务数 (基于 CPU 核心数，<code>cat /proc/stat | grep cpu[0-9] -c</code>)</li>
</ul>
<ol start="3">
<li>仿真执行: 根据参数运行仿真脚本 (host_sim.sh) 或 host_sim.</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># Function to run a cmodel simulation for a given test case</span>
</span></span><span class="line"><span class="cl"><span class="k">function</span> run_on_cmodel<span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Assign first argument as the test case name</span>
</span></span><span class="line"><span class="cl">    <span class="nv">case_name</span><span class="o">=</span><span class="nv">$1</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Assign second argument as the run flag (controls execution mode)</span>
</span></span><span class="line"><span class="cl">    <span class="nv">run_flag</span><span class="o">=</span><span class="nv">$2</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Check if case_name is empty</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">[</span> -z <span class="s2">&#34;</span><span class="nv">$case_name</span><span class="s2">&#34;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="cl">        <span class="nb">echo</span> <span class="s2">&#34;Error: case_name is empty&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="m">1</span>
</span></span><span class="line"><span class="cl">    <span class="k">fi</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Check if the test case directory exists</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">[</span> ! -d <span class="s2">&#34;</span><span class="si">${</span><span class="p">{OPLIB_PROJECT_ROOT</span><span class="si">}</span><span class="s2">}/tests/test_codegen/</span><span class="si">${</span><span class="nv">case_name</span><span class="si">}</span><span class="s2">&#34;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="cl">        <span class="nb">echo</span> <span class="s2">&#34;Can not find </span><span class="si">${</span><span class="nv">case_name</span><span class="si">}</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="m">1</span>
</span></span><span class="line"><span class="cl">    <span class="k">fi</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Change to the test case directory</span>
</span></span><span class="line"><span class="cl">    <span class="nb">pushd</span> <span class="s2">&#34;</span><span class="si">${</span><span class="p">{OPLIB_PROJECT_ROOT</span><span class="si">}</span><span class="s2">}/tests/test_codegen/</span><span class="si">${</span><span class="nv">case_name</span><span class="si">}</span><span class="s2">&#34;</span>  <span class="c1"># FIXED DIR</span>
</span></span><span class="line"><span class="cl">        rm -rf build
</span></span><span class="line"><span class="cl">        mkdir build
</span></span><span class="line"><span class="cl">        <span class="nb">cd</span> build
</span></span><span class="line"><span class="cl">        <span class="c1"># Run cmake to configure the build, disabling RISCV support</span>
</span></span><span class="line"><span class="cl">        cmake .. -DUSING_RISCV<span class="o">=</span>OFF
</span></span><span class="line"><span class="cl">        <span class="c1"># Run make with parallel jobs based on CPU core count</span>
</span></span><span class="line"><span class="cl">        make -j<span class="k">$(</span>cat /proc/stat <span class="p">|</span> grep cpu<span class="o">[</span>0-9<span class="o">]</span> -c<span class="k">)</span>
</span></span><span class="line"><span class="cl">        <span class="nv">ret</span><span class="o">=</span><span class="nv">$?</span>  <span class="c1"># Capture the return code</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># If make fails, restore directory, print error, and exit</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">[[</span> <span class="nv">$ret</span> -ne <span class="m">0</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="cl">            <span class="nb">popd</span>
</span></span><span class="line"><span class="cl">            <span class="nb">echo</span> <span class="nv">$ret</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nv">$ret</span>
</span></span><span class="line"><span class="cl">        <span class="k">fi</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># Check if run_flag is empty</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">[</span> -z <span class="s2">&#34;</span><span class="nv">$run_flag</span><span class="s2">&#34;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="o">[</span> -e ../host_sim.sh <span class="o">]</span><span class="p">;</span> <span class="k">then</span>  <span class="c1"># Check if host_sim.sh exists in the parent directory</span>
</span></span><span class="line"><span class="cl">                cp ../host_sim.sh .
</span></span><span class="line"><span class="cl">                sh ./host_sim.sh
</span></span><span class="line"><span class="cl">                <span class="nv">ret</span><span class="o">=</span><span class="nv">$?</span>  <span class="c1"># Capture the return code</span>
</span></span><span class="line"><span class="cl">                <span class="c1"># If script fails, restore directory, print error, and exit</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="o">[[</span> <span class="nv">$ret</span> -ne <span class="m">0</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>  
</span></span><span class="line"><span class="cl">                    <span class="nb">popd</span>
</span></span><span class="line"><span class="cl">                    <span class="nb">echo</span> <span class="nv">$ret</span>
</span></span><span class="line"><span class="cl">                    <span class="k">return</span> <span class="nv">$ret</span>
</span></span><span class="line"><span class="cl">                <span class="k">fi</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span>
</span></span><span class="line"><span class="cl">                ./host_sim ../  <span class="c1"># Run host_sim with parent directory as argument</span>
</span></span><span class="line"><span class="cl">                <span class="nv">ret</span><span class="o">=</span><span class="nv">$?</span>  <span class="c1"># Capture the return code</span>
</span></span><span class="line"><span class="cl">                <span class="c1"># If host_sim fails, restore directory, print error, and exit</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="o">[[</span> <span class="nv">$ret</span> -ne <span class="m">0</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="cl">                    <span class="nb">popd</span>
</span></span><span class="line"><span class="cl">                    <span class="nb">echo</span> <span class="nv">$ret</span>
</span></span><span class="line"><span class="cl">                    <span class="k">return</span> <span class="nv">$ret</span>
</span></span><span class="line"><span class="cl">                <span class="k">fi</span>
</span></span><span class="line"><span class="cl">            <span class="k">fi</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># Check if run_flag is &#34;0&#34; or &#34;1&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="k">elif</span> <span class="o">[[</span> <span class="nv">$run_flag</span> <span class="o">==</span> <span class="s2">&#34;0&#34;</span> <span class="o">]]</span> <span class="o">||</span> <span class="o">[[</span> <span class="nv">$run_flag</span> <span class="o">==</span> <span class="s2">&#34;1&#34;</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># Run host_sim with parent directory and run_flag</span>
</span></span><span class="line"><span class="cl">            ./host_sim ../ <span class="s2">&#34;</span><span class="nv">$run_flag</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="nv">ret</span><span class="o">=</span><span class="nv">$?</span>  <span class="c1"># Capture the return code</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># If host_sim fails, restore directory, print error, and exit</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="o">[[</span> <span class="nv">$ret</span> -ne <span class="m">0</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="cl">                <span class="nb">popd</span>
</span></span><span class="line"><span class="cl">                <span class="nb">echo</span> <span class="nv">$ret</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="nv">$ret</span>
</span></span><span class="line"><span class="cl">            <span class="k">fi</span>
</span></span><span class="line"><span class="cl">        <span class="k">fi</span>
</span></span><span class="line"><span class="cl">    <span class="nb">popd</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nb">echo</span> <span class="s2">&#34;</span><span class="si">${</span><span class="nv">FUNCNAME</span><span class="p">[0]</span><span class="si">}</span><span class="s2"> </span><span class="nv">$*</span><span class="s2"> passed&#34;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h1 id="run_codegen_case_soc_rtt">run_codegen_case_soc_rtt</h1>
<p>run_codegen_case_soc_rtt 位于 <code>tx8-oplib/scripts/regression.sh</code>，函数用于在 SOC 环境下运行 RTT (Real-Time Transfer) 测试。其主要流程如下：</p>
<ol>
<li>初始化和参数获取：</li>
</ol>
<ul>
<li>函数从命令行参数中获取 <code>case_name</code>, <code>copy_option</code>, 和 <code>multi_graph_enable</code>.</li>
<li>检查 <code>case_name</code> 是否为空，如果为空则输出错误信息并返回 1.</li>
</ul>
<ol start="2">
<li>环境设置和目录导航：</li>
</ol>
<ul>
<li>将工作目录切换到 <code>${OPLIB_PROJECT_ROOT}/tests/test_codegen/${case_name}</code>. 如果目录不存在，则输出错误信息并返回 1。</li>
</ul>
<ol start="3">
<li>构建和配置：</li>
</ol>
<ul>
<li>执行 <code>rm -rf ${case_name}_build</code> 清理之前的构建文件。</li>
<li>根据 <code>multi_graph_enable</code> 设置 <code>CONFIG_ARGS</code>，如果启用多图则设置为 &ldquo;-DMULTI_GRAPH=1&rdquo;，否则为空。</li>
<li>调用 cmake 命令生成构建文件，指定构建目录为 <code>${case_name}_build</code>，并根据 <code>copy_option</code> 设置 <code>COPY_RTT_FLAG</code>.</li>
<li>执行 make 命令进行实际构建，目标包括 all 和 chip_out.</li>
</ul>
<ol start="4">
<li>错误处理和退出：</li>
</ol>
<ul>
<li>每次关键步骤执行后，检查返回状态 <code>$ret</code>，如果非 0，则弹出目录并返回错误码。</li>
<li>构建成功后输出 <code>${FUNCNAME[0]} &quot;passed&quot;</code> 表示通过。</li>
</ul>
<ol start="5">
<li>清理和返回: 函数结束时弹出目录，恢复原始工作目录。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="k">function</span> run_codegen_case_soc_rtt<span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">echo</span> <span class="s2">&#34;</span><span class="si">${</span><span class="nv">FUNCNAME</span><span class="p">[0]</span><span class="si">}</span><span class="s2"> &#39;start&#39;&#34;</span>  <span class="c1"># 输出函数名和&#34;start&#34;表示开始</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nv">case_name</span><span class="o">=</span><span class="nv">$1</span>                  <span class="c1"># 获取用例名称</span>
</span></span><span class="line"><span class="cl">    <span class="nv">copy_option</span><span class="o">=</span><span class="nv">$2</span>                 <span class="c1"># 获取复制选项</span>
</span></span><span class="line"><span class="cl">    <span class="nv">multi_graph_enable</span><span class="o">=</span><span class="nv">$3</span>          <span class="c1"># 获取多图启用标志</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">[</span> -z <span class="s2">&#34;</span><span class="nv">$case_name</span><span class="s2">&#34;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>   <span class="c1"># 如果用例名称为空</span>
</span></span><span class="line"><span class="cl">        <span class="nb">echo</span> <span class="s2">&#34;case_name(</span><span class="nv">$case_name</span><span class="s2">) not found &#34;</span>  <span class="c1"># 输出错误信息</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="m">1</span>                   <span class="c1"># 返回错误码 1</span>
</span></span><span class="line"><span class="cl">    <span class="k">fi</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nv">case_dir</span><span class="o">=</span><span class="si">${</span><span class="nv">OPLIB_PROJECT_ROOT</span><span class="si">}</span>/tests/test_codegen/<span class="si">${</span><span class="nv">case_name</span><span class="si">}</span>  <span class="c1"># 设置用例目录</span>
</span></span><span class="line"><span class="cl">    <span class="nb">pushd</span> <span class="si">${</span><span class="nv">case_dir</span><span class="si">}</span>              <span class="c1"># 切换到用例目录</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    rm -rf <span class="si">${</span><span class="nv">case_name</span><span class="si">}</span>_build      <span class="c1"># 清理之前的构建文件</span>
</span></span><span class="line"><span class="cl">    <span class="nv">ret</span><span class="o">=</span><span class="nv">$?</span><span class="p">;</span> <span class="k">if</span> <span class="o">[</span> <span class="o">[</span> <span class="nv">$ret</span> -ne <span class="m">0</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span> popd<span class="p">;</span> <span class="nb">echo</span> <span class="nv">$ret</span><span class="p">;</span> <span class="k">return</span> <span class="nv">$ret</span><span class="p">;</span> <span class="k">fi</span>  <span class="c1"># 检查清理是否成功</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">[</span> -z <span class="s2">&#34;</span><span class="nv">$multi_graph_enable</span><span class="s2">&#34;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>  <span class="c1"># 如果多图启用标志为空</span>
</span></span><span class="line"><span class="cl">        <span class="nv">CONFIG_ARGS</span><span class="o">=</span><span class="s2">&#34;&#34;</span>                 <span class="c1"># 配置参数为空</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>                                 <span class="c1"># 否则</span>
</span></span><span class="line"><span class="cl">        <span class="nv">CONFIG_ARGS</span><span class="o">=</span><span class="s2">&#34;-DMULTI_GRAPH=1&#34;</span>  <span class="c1"># 设置多图配置参数</span>
</span></span><span class="line"><span class="cl">    <span class="k">fi</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    cmake -B <span class="s2">&#34;</span><span class="si">${</span><span class="nv">case_name</span><span class="si">}</span><span class="s2">_build&#34;</span> -DUSING_RISCV<span class="o">=</span>ON -TX8FW_BASE<span class="o">=</span><span class="si">${</span><span class="nv">OPLIB_PROJECT_ROOT</span><span class="si">}</span>/release/riscv/tx8-yoc-rt-thread-smp <span class="si">${</span><span class="nv">CONFIG_ARGS</span><span class="si">}</span> <span class="p">;</span> <span class="nv">ret</span><span class="o">=</span><span class="nv">$?</span><span class="p">;</span> <span class="k">if</span> <span class="o">[</span> <span class="o">[</span> <span class="nv">$ret</span> -ne <span class="m">0</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span> popd<span class="p">;</span> <span class="nb">echo</span> <span class="nv">$ret</span><span class="p">;</span> <span class="k">return</span> <span class="nv">$ret</span><span class="p">;</span> <span class="k">fi</span>  <span class="c1"># 生成构建文件</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    make -j -C <span class="s2">&#34;</span><span class="si">${</span><span class="nv">case_name</span><span class="si">}</span><span class="s2">_build&#34;</span> --target all chip_out <span class="p">;</span> <span class="nv">ret</span><span class="o">=</span><span class="nv">$?</span><span class="p">;</span> <span class="k">if</span> <span class="o">[</span> <span class="o">[</span> <span class="nv">$ret</span> -ne <span class="m">0</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span> popd<span class="p">;</span> <span class="nb">echo</span> <span class="nv">$ret</span><span class="p">;</span> <span class="k">return</span> <span class="nv">$ret</span><span class="p">;</span> <span class="k">fi</span>  <span class="c1"># 执行构建</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nb">popd</span>                          <span class="c1"># 恢复到原始目录</span>
</span></span><span class="line"><span class="cl">    <span class="nb">echo</span> <span class="s2">&#34;</span><span class="si">${</span><span class="nv">FUNCNAME</span><span class="p">[0]</span><span class="si">}</span><span class="s2"> &#39;passed&#39;&#34;</span> <span class="c1"># 输出函数名和&#34;passed&#34;表示通过</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h2 id="export_tx8fw_to_env">export_tx8fw_to_env</h2>
<p><code>export_tx8fw_to_env</code> 函数的主要目的是设置与 TX8FW 相关的环境变量，以便后续构建或运行时使用。以下是其流程：</p>
<ol>
<li>设置 SDK 路径：</li>
</ol>
<ul>
<li>定义 TX8FW 的 SDK 路径 <code>soc_sdk_path</code> 为 <code>${OPLIB_PROJECT_ROOT}/3rd_party/tx8-yoc-rt-thread-smp</code>.</li>
</ul>
<ol start="2">
<li>检查路径是否存在:</li>
</ol>
<ul>
<li>检查路径 <code>${soc_sdk_path}/tool/tx8fw-xuantie-sdk</code> 是否存在。如果不存在，打印错误信息并退出，状态码为 1.</li>
</ul>
<ol start="3">
<li>导出环境变量: 打印并设置以下环境变量</li>
</ol>
<ul>
<li>TX8FW_SDK_INSTALL_DIR：指向 ${soc_sdk_path}/tool/tx8fw-xuantie-sdk。</li>
<li>TX8FW_TOOLCHAIN_VARIANT：设置为 cross-compile。</li>
</ul>
<ol start="4">
<li>清理目录: 使用 popd 命令恢复到之前的目录.</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="k">function</span> export_tx8fw_to_env<span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="nv">soc_sdk_path</span><span class="o">=</span><span class="si">${</span><span class="nv">OPLIB_PROJECT_ROOT</span><span class="si">}</span>/3rd_party/tx8-yoc-rt-thread-smp  <span class="c1"># 设置 TX8FW SDK 路径</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nb">pushd</span> <span class="si">${</span><span class="nv">soc_sdk_path</span><span class="si">}</span>/tool/tx8fw-xuantie-sdk  <span class="c1"># 切换到 TX8FW SDK 工具目录</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">[</span> ! -d <span class="s2">&#34;xuantie-900-gcc-elf-newlib-x86_64-V2.8.0&#34;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>  <span class="c1"># 检查指定 SDK 目录是否存在</span>
</span></span><span class="line"><span class="cl">        <span class="nb">echo</span> <span class="s2">&#34;</span><span class="si">${</span><span class="nv">soc_sdk_path</span><span class="si">}</span><span class="s2">/tool/tx8fw-xuantie-sdk didn&#39;t exist&#34;</span>  <span class="c1"># 如果不存在，打印错误信息</span>
</span></span><span class="line"><span class="cl">        <span class="nb">exit</span> <span class="m">1</span>  <span class="c1"># 退出并返回状态码 1</span>
</span></span><span class="line"><span class="cl">    <span class="k">fi</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nb">echo</span> <span class="s2">&#34;export TX8FW_SDK_INSTALL_DIR=</span><span class="si">${</span><span class="nv">soc_sdk_path</span><span class="si">}</span><span class="s2">/tool/tx8fw-xuantie-sdk&#34;</span>  <span class="c1"># 打印并设置 TX8FW SDK 安装目录环境变量</span>
</span></span><span class="line"><span class="cl">    <span class="nb">export</span> <span class="nv">TX8FW_SDK_INSTALL_DIR</span><span class="o">=</span><span class="si">${</span><span class="nv">soc_sdk_path</span><span class="si">}</span>/tool/tx8fw-xuantie-sdk  <span class="c1"># 导出 TX8FW SDK 安装目录环境变量</span>
</span></span><span class="line"><span class="cl">    <span class="nb">export</span> <span class="nv">TX8FW_TOOLCHAIN_VARIANT</span><span class="o">=</span>cross-compile  <span class="c1"># 导出工具链变体为 cross-compile</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nb">popd</span>  <span class="c1"># 恢复到之前的目录</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h2 id="build_oplib_with_soc-函数">build_oplib_with_soc 函数</h2>
<p><code>build_oplib_with_soc</code> 函数用于构建 OPLib 并结合特定 SoC 配置。以下是其流程：</p>
<p>打印项目根目录：
打印 OPLIB_PROJECT_ROOT 环境变量，用于调试或日志记录。</p>
<ol>
<li>切换目录和初始化：</li>
</ol>
<ul>
<li>使用 pushd 切换到 <code>OPLIB_PROJECT_ROOT</code> 目录。</li>
<li>定义变量 <code>rm=rf build</code>, <code>mkdir=build</code> 和 <code>cd=build</code>，这些变量实际上是模拟命令（rm -rf build、mkdir build 和 cd build）。</li>
</ul>
<ol start="2">
<li>设置复制标志：</li>
</ol>
<ul>
<li>检查 <code>$1</code> (即 <code>copy_option</code>) 是否为 &ldquo;NOT_COPY&rdquo;，如果是，则设置 <code>COPY_RTT_FLAG</code> 为 <code>--DRTT_HOST_COPY=OFF</code>，否则为空。</li>
</ul>
<ol start="3">
<li>导出环境变量并构建：</li>
</ol>
<ul>
<li>调用 <code>export_tx8fw_to_env</code> 函数设置 TX8FW 相关环境变量。</li>
<li>运行 cmake 命令，生成构建文件，指定构建选项 <code>-DUSING_RISCV=ON</code> 和 <code>TX8FW_BASE</code>，并根据 <code>COPY_RTT_FLAG</code> 添加额外参数。</li>
<li>使用 make 命令执行构建，目标包括 grep epilog 和 c</li>
</ul>
<ol start="4">
<li>清理目录: 使用 popd 命令恢复到之前的目录.</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="k">function</span> build_oplib_with_soc<span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">echo</span> <span class="si">${</span><span class="nv">OPLIB_PROJECT_ROOT</span><span class="si">}</span>  <span class="c1"># 打印 OPLib 项目根目录路径</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nb">pushd</span> <span class="si">${</span><span class="nv">OPLIB_PROJECT_ROOT</span><span class="si">}</span>  <span class="c1"># 切换到 OPLib 项目根目录</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nv">rm</span><span class="o">=</span>rf build  <span class="c1"># 定义清理构建目录的命令</span>
</span></span><span class="line"><span class="cl">    <span class="nv">mkdir</span><span class="o">=</span>build  <span class="c1"># 定义创建构建目录的命令</span>
</span></span><span class="line"><span class="cl">    <span class="nv">cd</span><span class="o">=</span>build     <span class="c1"># 定义切换到构建目录的命令</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nv">COPY_RTT_FLAG</span><span class="o">=</span><span class="s2">&#34;&#34;</span>  <span class="c1"># 初始化 RTT 复制标志</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">[</span> <span class="s2">&#34;</span><span class="nv">$1</span><span class="s2">&#34;</span> <span class="o">==</span> <span class="s2">&#34;NOT_COPY&#34;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>  <span class="c1"># 如果传入的复制选项为 NOT_COPY</span>
</span></span><span class="line"><span class="cl">        <span class="nv">COPY_RTT_FLAG</span><span class="o">=</span><span class="s2">&#34;--DRTT_HOST_COPY=OFF&#34;</span>  <span class="c1"># 设置 RTT 复制标志为关闭</span>
</span></span><span class="line"><span class="cl">    <span class="k">fi</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    export_tx8fw_to_env  <span class="c1"># 调用函数导出 TX8FW 相关环境变量</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    cmake .. -DUSING_RISCV<span class="o">=</span>ON -TX8FW_BASE<span class="o">=</span><span class="si">${</span><span class="nv">OPLIB_PROJECT_ROOT</span><span class="si">}</span>/release/riscv/tx8-yoc-rt-thread-smp <span class="si">${</span><span class="nv">COPY_RTT_FLAG</span><span class="si">}</span>  <span class="c1"># 生成构建文件，指定 RISCV 和 TX8FW 路径</span>
</span></span><span class="line"><span class="cl">    <span class="nv">ret</span><span class="o">=</span><span class="nv">$?</span><span class="p">;</span> <span class="k">if</span> <span class="o">[</span> <span class="nv">$ret</span> -ne <span class="m">0</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span> popd<span class="p">;</span> <span class="k">return</span> <span class="nv">$ret</span><span class="p">;</span> <span class="k">fi</span>  <span class="c1"># 检查 cmake 是否成功，失败则返回</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    make -j cat /proc/stat <span class="p">|</span> grep epilog -c  <span class="c1"># 执行构建并检查 epilog 相关信息</span>
</span></span><span class="line"><span class="cl">    <span class="nv">ret</span><span class="o">=</span><span class="nv">$?</span><span class="p">;</span> <span class="k">if</span> <span class="o">[</span> <span class="nv">$ret</span> -ne <span class="m">0</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span> popd<span class="p">;</span> <span class="k">return</span> <span class="nv">$ret</span><span class="p">;</span> <span class="k">fi</span>  <span class="c1"># 检查 make 是否成功，失败则返回</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nb">popd</span>  <span class="c1"># 恢复到之前的目录</span>
</span></span><span class="line"><span class="cl">    <span class="nb">echo</span> <span class="si">${</span><span class="nv">FUNCNAME</span><span class="p">[0]</span><span class="si">}</span> <span class="s2">&#34;passed&#34;</span>  <span class="c1"># 输出函数名和&#34;passed&#34;表示构建成功</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h2 id="run_on_soc_rtt">run_on_soc_rtt</h2>
<p><code>run_on_soc_rtt</code>，用于在特定 SoC 和 RTT 环境下运行测试用例。以下是其主要流程：</p>
<ol>
<li>初始化和参数获取:</li>
</ol>
<ul>
<li>函数从命令行参数中获取 <code>case_name</code>, <code>rtt_option</code> 和 <code>multi_graph_enable</code>.</li>
<li>检查 <code>case_name</code> 是否为空，如果为空则输出错误信息并返回 1。</li>
</ul>
<ol start="2">
<li>目录切换和清理:</li>
</ol>
<ul>
<li>将工作目录切换到 <code>${OPLIB_PROJECT_ROOT}/tests/test_codegen/${case_name}</code>.</li>
<li>执行 <code>rm -rf ${case_name}_build</code> 清理之前的构建文件。</li>
</ul>
<ol start="3">
<li>配置设置: 根据 <code>multi_graph_enable</code> 设置 CONFIG_ARGS，如果启用多图则设置为 &ldquo;-DMULTI_GRAPH=1&rdquo;，否则为空。</li>
<li>构建和运行：</li>
</ol>
<ul>
<li>使用 cmake 生成构建文件，指定构建目录为 <code>${case_name}_build</code>，并设置 <code>-DUSING_RISCV=ON</code> 和 <code>-TX8FW_BASE</code> 路径。</li>
<li>使用 make 命令执行构建，目标包括 all 和 chip_out.</li>
</ul>
<ol start="5">
<li>清理和返回: 使用 popd 恢复到原始目录。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="k">function</span> run_on_soc_rtt<span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">echo</span> <span class="s2">&#34;</span><span class="si">${</span><span class="nv">FUNCNAME</span><span class="p">[0]</span><span class="si">}</span><span class="s2"> &#39;start&#39;&#34;</span>  <span class="c1"># 输出函数名和&#34;start&#34;表示开始</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nv">case_name</span><span class="o">=</span><span class="nv">$1</span>                  <span class="c1"># 获取用例名称</span>
</span></span><span class="line"><span class="cl">    <span class="nv">rtt_option</span><span class="o">=</span><span class="nv">$2</span>                 <span class="c1"># 获取 RTT 选项</span>
</span></span><span class="line"><span class="cl">    <span class="nv">multi_graph_enable</span><span class="o">=</span><span class="nv">$3</span>         <span class="c1"># 获取多图启用标志</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">[</span> -z <span class="s2">&#34;</span><span class="nv">$case_name</span><span class="s2">&#34;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>   <span class="c1"># 如果用例名称为空</span>
</span></span><span class="line"><span class="cl">        <span class="nb">echo</span> <span class="s2">&#34;case_name(</span><span class="nv">$case_name</span><span class="s2">) not found &#34;</span>  <span class="c1"># 输出错误信息</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="m">1</span>                   <span class="c1"># 返回错误码 1</span>
</span></span><span class="line"><span class="cl">    <span class="k">fi</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nv">case_dir</span><span class="o">=</span><span class="si">${</span><span class="nv">OPLIB_PROJECT_ROOT</span><span class="si">}</span>/tests/test_codegen/<span class="si">${</span><span class="nv">case_name</span><span class="si">}</span>  <span class="c1"># 设置用例目录</span>
</span></span><span class="line"><span class="cl">    <span class="nb">pushd</span> <span class="si">${</span><span class="nv">case_dir</span><span class="si">}</span>              <span class="c1"># 切换到用例目录</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    rm -rf <span class="si">${</span><span class="nv">case_name</span><span class="si">}</span>_build      <span class="c1"># 清理之前的构建文件</span>
</span></span><span class="line"><span class="cl">    <span class="nv">ret</span><span class="o">=</span><span class="nv">$?</span><span class="p">;</span> <span class="k">if</span> <span class="o">[</span> <span class="o">[</span> <span class="nv">$ret</span> -ne <span class="m">0</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span> popd<span class="p">;</span> <span class="nb">echo</span> <span class="nv">$ret</span><span class="p">;</span> <span class="k">return</span> <span class="nv">$ret</span><span class="p">;</span> <span class="k">fi</span>  <span class="c1"># 检查清理是否成功，失败则返回</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">[</span> -z <span class="s2">&#34;</span><span class="nv">$multi_graph_enable</span><span class="s2">&#34;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>  <span class="c1"># 如果多图启用标志为空</span>
</span></span><span class="line"><span class="cl">        <span class="nv">CONFIG_ARGS</span><span class="o">=</span><span class="s2">&#34;&#34;</span>                 <span class="c1"># 配置参数为空</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>                                 <span class="c1"># 否则</span>
</span></span><span class="line"><span class="cl">        <span class="nv">CONFIG_ARGS</span><span class="o">=</span><span class="s2">&#34;-DMULTI_GRAPH=1&#34;</span>  <span class="c1"># 设置多图配置参数</span>
</span></span><span class="line"><span class="cl">    <span class="k">fi</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    cmake -B <span class="s2">&#34;</span><span class="si">${</span><span class="nv">case_name</span><span class="si">}</span><span class="s2">_build&#34;</span> -DUSING_RISCV<span class="o">=</span>ON -TX8FW_BASE<span class="o">=</span><span class="si">${</span><span class="nv">OPLIB_PROJECT_ROOT</span><span class="si">}</span>/release/riscv/tx8-yoc-rt-thread-smp <span class="si">${</span><span class="nv">CONFIG_ARGS</span><span class="si">}</span> <span class="p">;</span> <span class="nv">ret</span><span class="o">=</span><span class="nv">$?</span><span class="p">;</span> <span class="k">if</span> <span class="o">[</span> <span class="o">[</span> <span class="nv">$ret</span> -ne <span class="m">0</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span> popd<span class="p">;</span> <span class="nb">echo</span> <span class="nv">$ret</span><span class="p">;</span> <span class="k">return</span> <span class="nv">$ret</span><span class="p">;</span> <span class="k">fi</span>  <span class="c1"># 生成构建文件，指定 RISCV 和 TX8FW 路径</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    make -C <span class="s2">&#34;</span><span class="si">${</span><span class="nv">case_name</span><span class="si">}</span><span class="s2">_build&#34;</span> --target all chip_out <span class="p">;</span> <span class="nv">ret</span><span class="o">=</span><span class="nv">$?</span><span class="p">;</span> <span class="k">if</span> <span class="o">[</span> <span class="o">[</span> <span class="nv">$ret</span> -ne <span class="m">0</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span> popd<span class="p">;</span> <span class="nb">echo</span> <span class="nv">$ret</span><span class="p">;</span> <span class="k">return</span> <span class="nv">$ret</span><span class="p">;</span> <span class="k">fi</span>  <span class="c1"># 执行构建，目标为 all 和 chip_out</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nb">popd</span>                          <span class="c1"># 恢复到原始目录</span>
</span></span><span class="line"><span class="cl">    <span class="nb">echo</span> <span class="s2">&#34;</span><span class="si">${</span><span class="nv">FUNCNAME</span><span class="p">[0]</span><span class="si">}</span><span class="s2"> &#39;passed&#39;&#34;</span> <span class="c1"># 输出函数名和&#34;passed&#34;表示通过</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div>]]></content:encoded>
    </item>
  </channel>
</rss>
