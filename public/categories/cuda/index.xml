<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>CUDA on WITHER</title>
    <link>http://localhost:1313/categories/cuda/</link>
    <description>Recent content in CUDA on WITHER</description>
    <generator>Hugo -- 0.147.7</generator>
    <language>en</language>
    <copyright>2024-2025 WITHER</copyright>
    <lastBuildDate>Sat, 07 Jun 2025 16:41:56 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/categories/cuda/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>PMPP Learning-Chapter 15 Graph traversal</title>
      <link>http://localhost:1313/blogs/courselearning/pmpp/pmpp-ch15/</link>
      <pubDate>Wed, 18 Sep 2024 16:05:12 +0800</pubDate>
      <guid>http://localhost:1313/blogs/courselearning/pmpp/pmpp-ch15/</guid>
      <description>Personal notebook 15 of Programming Massively Parallel</description>
      <content:encoded><![CDATA[<h1 id="15-graph-traversal">15 Graph Traversal</h1>
<p>图是一种表示实体之间关系的数据结构。所涉及的实体表示为顶点，关系表示为边。图的遍历是指从一个顶点出发，依次访问图中所有与之相邻的顶点，直到所有顶点都被访问过为止。</p>
<h2 id="151-background">15.1 Background</h2>
<p>下图展示了一个有向的简单图的例子。我们为每个顶点分配一个唯一的数字，称为顶点编号 (<em>vertex id</em>).</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEBe6e0bafe63910bccfb3577f88479dffb?method=download&amp;shareKey=84d69b480eb0abc7389b157e34df8def" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEBe6e0bafe63910bccfb3577f88479dffb?method=download&amp;shareKey=84d69b480eb0abc7389b157e34df8def" alt="A Simple Graph Example with 9 Vertices and 15 Directional Edges">
    </a><figcaption>A Simple Graph Example with 9 Vertices and 15 Directional Edges</figcaption></figure></p>
<p>图的直观表示是邻接矩阵 (<em>adjacency matrix</em>). 如果存在一条从源顶点 i 到目的顶点 j 的边，则邻接矩阵元素 <code>a[i][j]</code> 的值为 1，否则为 0. 下图展示了对应的邻接矩阵。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEB50516a130f544bbffa7beab784efb84a?method=download&amp;shareKey=f6419b90e7b997b86ba1213964c6672d" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEB50516a130f544bbffa7beab784efb84a?method=download&amp;shareKey=f6419b90e7b997b86ba1213964c6672d" alt="Adjacent Matrix Representation of the Example Graph">
    </a><figcaption>Adjacent Matrix Representation of the Example Graph</figcaption></figure></p>
<p>稀疏连接的图可以用稀疏矩阵表示，下图展示了用三种不同存储格式的邻接矩阵: CSR, CSC 和 COO. 我们将行下标和指针数组分别称为 <code>src</code> 和 <code>srcPtrs</code> 数组，列下标和指针数组分别称为 <code>dst</code> 和 <code>dstPtrs</code> 数组。在图的 CSR 表示中，每个源顶点指针(<code>srcPtrs</code>) 给出顶点出边的起始位置。在图的 CSC 表示中，每个目的顶点指针 (<code>dstPtrs</code>) 给出顶点入边的起始位置。在图的 COO 表示中，<code>src</code> 和 <code>dst</code> 数组分别存储源顶点和目的顶点的编号。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEB2d0fabda0f28ddd99a4173aeba461b7d?method=download&amp;shareKey=8204d08f33f6447a23ca5a1c595ea505" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEB2d0fabda0f28ddd99a4173aeba461b7d?method=download&amp;shareKey=8204d08f33f6447a23ca5a1c595ea505" alt="Three Sparse Matrix Representations of the Adjacency Matrix">
    </a><figcaption>Three Sparse Matrix Representations of the Adjacency Matrix</figcaption></figure></p>
<h2 id="152-breadth-first-search-bfs">15.2 Breadth-first Search (BFS)</h2>
<p>BFS 通常用于找到从图的一个顶点到另一个顶点所需遍历的最短边数。一种方法是，给定一个被称为根的顶点，用从根到某个顶点所需要遍历的最小边数来标记每个顶点。</p>
<p>下图(A)展示示了以顶点 0 为根的 BFS 结果。如果另一个顶点作为根，BFS 的结果将完全不同。下图(B)是为以顶点 2 为根的 BFS 的结果。可以将 BFS 的标记操作看作是构建一个搜索根节点的 BFS 树。树由所有标记的顶点和在搜索过程中从一个顶点到下一个顶点的遍历的边组成。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEB86988e0b8a20689df2c463bc1a37c06a?method=download&amp;shareKey=1439c86c169aaab86a80e4bef46363e3" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEB86988e0b8a20689df2c463bc1a37c06a?method=download&amp;shareKey=1439c86c169aaab86a80e4bef46363e3" alt="(A and B) Two Examples of BFS Results for Two Different Root Vertices">
    </a><figcaption>(A and B) Two Examples of BFS Results for Two Different Root Vertices</figcaption></figure></p>
<p>下图展示了 BFS 在计算机辅助设计 (Computer-Aided Design, CAD) 中的一个重要应用。迷宫路由 (maze routing) 将芯片表示为图。路由块是顶点。从顶点 i 到顶点 j 的边表示可以将一条线从块 i 延伸到块 j.</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEB95b0ba416ed35e18d378b0a2cab1841b?method=download&amp;shareKey=83ec350ed8c87f47c217d4b32ffc5d0d" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEB95b0ba416ed35e18d378b0a2cab1841b?method=download&amp;shareKey=83ec350ed8c87f47c217d4b32ffc5d0d" alt="Maze Routing in Integrated Circuits">
    </a><figcaption>Maze Routing in Integrated Circuits</figcaption></figure></p>
<h2 id="153-vertex-centric-parallelization-of-bfs">15.3 Vertex-centric Parallelization of BFS</h2>
<p>以顶点为中心的并行实现将线程分配给顶点，并让每个线程对其顶点执行操作，这通常涉及迭代该顶点的邻居。当处理不同层级的迭代时，并行实现遵循相同的策略。为每一层调用一个单独的内核的原因是，我们需要等待前一层的所有顶点都被标记，然后再继续标记下一层的顶点。下面实现了一个 BFS 内核，根据前一个层级的顶点标签来标记属于该层级的所有顶点。该内核将每个线程分配给一个顶点，检查其顶点是否属于前一层。如果是，线程将遍历出边，将所有未访问的邻居标记为属于当前级别。这种以顶点为中心的实现通常被称为自顶向下或 push 实现，因为其需要访问给定源顶点的出边。多个线程可以将该标志赋值为 1，代码仍然可以正确执行。这个性质称为幂等性 (<em>idempotence</em>).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">CSRGRAPH</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">numVertices</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span><span class="o">*</span> <span class="n">scrPtrs</span><span class="p">;</span>  <span class="c1">// Strating outgoing edge index of each vertex
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span><span class="o">*</span> <span class="n">dstList</span><span class="p">;</span>  <span class="c1">// Destination vertex index of each edge
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">__global__</span> 
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">bfs_kernel_csr</span><span class="p">(</span><span class="n">CSRGRAPH</span> <span class="n">graph</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span> <span class="n">level</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span> <span class="n">visited</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">currLevel</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="n">vertexId</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">vertexId</span> <span class="o">&lt;</span> <span class="n">graph</span><span class="p">.</span><span class="n">numVertices</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">level</span><span class="p">[</span><span class="n">vertexId</span><span class="p">]</span> <span class="o">==</span> <span class="n">currLevel</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">graph</span><span class="p">.</span><span class="n">scrPtrs</span><span class="p">[</span><span class="n">vertexId</span><span class="p">];</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">graph</span><span class="p">.</span><span class="n">scrPtrs</span><span class="p">[</span><span class="n">vertexId</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">neighbor</span> <span class="o">=</span> <span class="n">graph</span><span class="p">.</span><span class="n">dstList</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">level</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xFFFFFFFF</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// unvisited neighbor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="n">level</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">=</span> <span class="n">currLevel</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                    <span class="n">visited</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                    <span class="o">*</span><span class="n">visited</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// flag to indicate whether reached the end of the graph
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>下图展示了该内核如何执行从第 1 层 (<code>currLevel-1</code>) 到第 2 层 (<code>currLevel</code>) 的遍历。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEB631a2ec2144a24f5b99cda39d3f0da53?method=download&amp;shareKey=30e9a4215568e79524f1e082a1d4c65b" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEB631a2ec2144a24f5b99cda39d3f0da53?method=download&amp;shareKey=30e9a4215568e79524f1e082a1d4c65b" alt="Example of a Vertex-centric Push BFS Traversal from Level 1 to Level 2">
    </a><figcaption>Example of a Vertex-centric Push BFS Traversal from Level 1 to Level 2</figcaption></figure></p>
<p>第二个以顶点为中心的并行实现将每个线程分配给一个顶点，迭代顶点的入边。每个线程首先检查其顶点是否已被访问。如果没被访问，线程将遍历入边，如果线程找到一个属于前一层的邻居，线程将把它的顶点标记为属于当前层。这种以顶点为中心的实现通常被称为自底向上或 pull 实现。实现要求能访问给定目标顶点的入边，因此要采用 CSC 表示。
以顶点为中心的 pull 实现的内核代码如下，对于一个线程来说，要确定它的顶点处于当前层，只需要该顶点有一个邻居s属于前一层中就足够了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">CSCGRAPH</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">numVertices</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span><span class="o">*</span> <span class="n">dstPtrs</span><span class="p">;</span>  <span class="c1">// Starting incoming edge index of each vertex
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span><span class="o">*</span> <span class="n">scrList</span><span class="p">;</span>  <span class="c1">// Source vertex index of each edge
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">__global__</span> 
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">bfs_kernel_csc</span><span class="p">(</span><span class="n">CSCGRAPH</span> <span class="n">graph</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span> <span class="n">level</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span> <span class="n">visited</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">currLevel</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="n">vertexId</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">vertexId</span> <span class="o">&lt;</span> <span class="n">graph</span><span class="p">.</span><span class="n">numVertices</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">level</span><span class="p">[</span><span class="n">vertexId</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xFFFFFFF</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// loop through its incoming edges if not visited
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">graph</span><span class="p">.</span><span class="n">dstPtrs</span><span class="p">[</span><span class="n">vertexId</span><span class="p">];</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">graph</span><span class="p">.</span><span class="n">dstPtrs</span><span class="p">[</span><span class="n">vertexId</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">neighbor</span> <span class="o">=</span> <span class="n">graph</span><span class="p">.</span><span class="n">scrList</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">level</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">==</span> <span class="n">currLevel</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">level</span><span class="p">[</span><span class="n">vertexId</span><span class="p">]</span> <span class="o">=</span> <span class="n">currLevel</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                    <span class="o">*</span><span class="n">visited</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// flag to indicate whether reached the end of the graph
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="k">break</span><span class="p">;</span>  <span class="c1">// Only need 1 neighbor in previous level to identify the vetex is currLevel
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>下图展示了这个内核如何执行从第 1 层到第 2 层的遍历。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEB316aa0df65a0a6249ead5e5ecc6290e9?method=download&amp;shareKey=d2f16ad21467d1bedd052c11f45ee5b3" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEB316aa0df65a0a6249ead5e5ecc6290e9?method=download&amp;shareKey=d2f16ad21467d1bedd052c11f45ee5b3" alt="Example of a Vertex-centric Pull (bottom-up) Traversal from Level 1 to Level 2">
    </a><figcaption>Example of a Vertex-centric Pull (bottom-up) Traversal from Level 1 to Level 2</figcaption></figure></p>
<p>在比较推和拉以顶点为中心的并行实现时，需要考虑两个对性能有重要影响的关键差异。</p>
<ol>
<li>在 push 实现中，线程在其顶点的循环遍历所有邻居；而在 pull 实现中，线程可能会提前跳出循环。</li>
<li>在 push 实现中，只有被标记为前一层的顶点的线程在遍历其邻居列表；而在 pull 实现中，任何被标记为未访问顶点的线程会遍历其邻居列表。
基于两种实现的差异，常见的优化方法是对低层级使用 push 实现，然后对较高层级使用 pull 实现。这种方法通常被称为方向优化 (<em>directional optimization</em>) 实现。选择何时切换通常取决于图的类型。低度图通常有很多层；高度图中，从任何顶点到任何其他顶点只需要很少的层。因此对于高度图来说从 push 实现切换到 pull 实现通常比低度图要早得多。
如果要使用方向优化的实现，则图的 CSR 和 CSC 表示都需要储存。但对于无向图来说，其邻接矩阵是对称的，因此 CSR 和 CSC 表示是相同的的，只需要存储其中一个，就可以被两个实现使用。</li>
</ol>
<h2 id="154-edge-centric-parallelization-of-bfs">15.4 Edge-centric Parallelization of BFS</h2>
<p>在这个实现中，每个线程被分配到一条边。它检查边的源顶点是否属于前一层以及边的目标顶点是否未被访问。
以边为中心的并行实现的内核代码如下。每个线程使用 COO <code>src</code> 数组找到其边缘的源顶点，并检查顶点是否属于前一级。通过此检查的线程将使用 COO <code>dst</code> 数组确定边的目的顶点，并检查其是否未被访问过。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">COOGRAPH</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">numVertices</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">numEdges</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span><span class="o">*</span> <span class="n">srcList</span><span class="p">;</span>  <span class="c1">// Source vertex index of each edge
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span><span class="o">*</span> <span class="n">dstList</span><span class="p">;</span>  <span class="c1">// Destination vertex index of each edge
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">__global__</span> 
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">bfs_kernel_coo</span><span class="p">(</span><span class="n">COOGRAPH</span> <span class="n">graph</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span> <span class="n">level</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span> <span class="n">visited</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">currLevel</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="n">edgeId</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">edgeId</span> <span class="o">&lt;</span> <span class="n">graph</span><span class="p">.</span><span class="n">numEdges</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">src</span> <span class="o">=</span> <span class="n">graph</span><span class="p">.</span><span class="n">srcList</span><span class="p">[</span><span class="n">edgeId</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">level</span><span class="p">[</span><span class="n">src</span><span class="p">]</span> <span class="o">==</span> <span class="n">currLevel</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">neighbor</span> <span class="o">=</span> <span class="n">graph</span><span class="p">.</span><span class="n">dstList</span><span class="p">[</span><span class="n">edgeId</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">level</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0xFFFFFFFF</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// unvisited neighbor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">level</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">=</span> <span class="n">currLevel</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">visited</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="o">*</span><span class="n">visited</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// flag to indicate whether reached the end of the graph
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>下图展示了该内核如何执行从从第 1 层到第 2 层的遍历。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEB1a12c34603381779af3db3e8ff96ca11?method=download&amp;shareKey=835bfaff2b7020013da3dcc13912a00c" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEB1a12c34603381779af3db3e8ff96ca11?method=download&amp;shareKey=835bfaff2b7020013da3dcc13912a00c" alt="Example of an Edge-centric Traversal from Level 1 to Level 2">
    </a><figcaption>Example of an Edge-centric Traversal from Level 1 to Level 2</figcaption></figure></p>
<p>与以顶点为中心的并行实现相比，以边为中心的并行实现的优点如下</p>
<ol>
<li>有更多的并行性。在以顶点为中心的实现中，如果顶点的数量很少，可能不会启动足够的线程来完全占用设备。因为一个图通常有比顶点更多的边，以边为中心的实现可以启动更多的线程。</li>
<li>具有较小的负载不平衡和控制发散。在以顶点为中心的实现中，每个线程迭代不同数量的边。相反，在以边为中心的实现中，每个线程只遍历一个边。
以边为中心的实现的缺点如下</li>
<li>需要检查图中的每条边。相反，以顶点为中心的实现中，如果确定顶点与当前层级无关，则会跳过整个边列表。</li>
<li>使用 COO 格式存储图，与以顶点为中心的实现使用的 CSR 和 CSC 相比，它需要更多的存储空间来存储边。</li>
</ol>
<h2 id="155-improving-efficiency-with-frontiers">15.5 Improving efficiency with frontiers</h2>
<p>在前两节中的方法中，我们会检查每个顶点或每条边是否属和当前层有关。这种策略的优点是内核是高度并行的，并且不需要跨线程进行任何同步。缺点是启动了许多不必要的线程，并执行了大量无用的工作。我们可以让处理前一层顶点的线程将它们访问的顶点作为 frontier. 因此，对于当前层级，只需要为该 frontier 中的顶点启动线程。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEB8c15c5b4a331ade6411685dd9c0d1f1a?method=download&amp;shareKey=bd7f5e6781a9073f31fdb3005f541380" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEB8c15c5b4a331ade6411685dd9c0d1f1a?method=download&amp;shareKey=bd7f5e6781a9073f31fdb3005f541380" alt="Example of a Vertex-centric Push (top-down) BFS Traversal from Level 1 to Level 2 with Frontiers">
    </a><figcaption>Example of a Vertex-centric Push (top-down) BFS Traversal from Level 1 to Level 2 with Frontiers</figcaption></figure></p>
<p>对应的内核代码如下。首先为 frontier 的每个元素分配一个线程，使用 CSR <code>srcPtrs</code> 数组来定位顶点的出边并进行迭代。对于每个出边，线程使用 CSR <code>dst</code> 数组确定其目的顶点，若未被访问过，并将其标记为属于当前层级。为了避免多个线程将邻居视为未访问，应该以原子方式执行邻居标签的检查和更新。<code>atomicCAS</code> 内置函数提供 compare-and-swap 的原子操作。如果比较成功,与其他原子操作一样，<code>atomicCAS</code> 返回存储的旧值。因此，我们可以通过比较返回值与被比较的值来检查该顶点是否被访问过。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">__global__</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">frontier_bfs_kernel</span><span class="p">(</span><span class="n">CSRGRAPH</span> <span class="n">graph</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span> <span class="n">level</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span> <span class="n">prevFroniter</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span> <span class="n">currFroniter</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">numPrevFroniter</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span> <span class="n">numCurrFroniter</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span> <span class="n">currLevel</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Each thread processes a node in prevFroniter.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">numPrevFroniter</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vertexId</span> <span class="o">=</span> <span class="n">prevFroniter</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> 
</span></span><span class="line"><span class="cl">        <span class="c1">// All its neighbouring nodes are traversed.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">edge</span> <span class="o">=</span> <span class="n">graph</span><span class="p">.</span><span class="n">scrPtrs</span><span class="p">[</span><span class="n">vertexId</span><span class="p">];</span> <span class="n">edge</span> <span class="o">&lt;</span> <span class="n">graph</span><span class="p">.</span><span class="n">scrPtrs</span><span class="p">[</span><span class="n">vertexId</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span> <span class="n">edge</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">neighbor</span> <span class="o">=</span> <span class="n">graph</span><span class="p">.</span><span class="n">dstList</span><span class="p">[</span><span class="n">edge</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">atomicCAS</span><span class="p">(</span><span class="n">level</span> <span class="o">+</span> <span class="n">neighbor</span><span class="p">,</span> <span class="mh">0xFFFFFFFF</span><span class="p">,</span> <span class="n">currLevel</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0xFFFFFFFF</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// check if neighbor is unvisited
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">currFroniterIndex</span> <span class="o">=</span> <span class="n">atomicAdd</span><span class="p">(</span><span class="n">numCurrFroniter</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">currFroniter</span><span class="p">[</span><span class="n">currFroniterIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">neighbor</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这种基于 frontier 的方法的优势在于，它通过只启动处理相关顶点的线程减少了冗余工作。缺点是长延迟原子操作的开销，特别是当这些操作竞争访问相同的地址时。对于 atomicAdd 操作争用会很高，因为所有线程都增加同一个计数器。</p>
<h2 id="156-reducing-contention-with-privatization">15.6 Reducing Contention with Privatization</h2>
<p>私有化可以应用于对 numCurrFrontier 的增加，以减少插入 frontier 时的争用。我们可以让每个线程块在整个计算过程中维护自己的本地 frontier，并在完成后更新全局 frontier. 本地 frontier 及其计数器可以存储在共享内存中，从而支持对计数器和存储到本地边界的低延迟原子操作。此外，当将共享内存中的 frontier 存储到全局内存中的公共 frontier 时，访问可以合并。</p>
<p>下图说明了 frontier 私有化的执行情况。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEB34a0e090d131236cb469365789ba6a21?method=download&amp;shareKey=cd8a9dcd79e858b456d2bcd1d99c16c3" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEB34a0e090d131236cb469365789ba6a21?method=download&amp;shareKey=cd8a9dcd79e858b456d2bcd1d99c16c3" alt="Privatization of Frontiers Example">
    </a><figcaption>Privatization of Frontiers Example</figcaption></figure></p>
<p>对应的内核代码如下。注意到公共 frontiner 的索引 <code>currFrontierIdx</code> 是用 <code>currFrontierIdx_s</code> 表示的，而 <code>currFrontierIdx_s</code> 是用 <code>threadIdx.x</code> 表示的。因此，相邻线程存储到连续的全局内存位置，这意味着内存访问是合并的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#define LOCAL_FRONTIER_SIZE 4
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="n">__global__</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">private_frontier_bfs_kernel</span><span class="p">(</span><span class="n">CSRGRAPH</span> <span class="n">graph</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span> <span class="n">level</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span> <span class="n">prevFroniter</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span> <span class="n">currFroniter</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">numPrevFroniter</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span> <span class="n">numCurrFroniter</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span> <span class="n">currLevel</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Initialize privative frontier
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">__shared__</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">currFrontier_s</span><span class="p">[</span><span class="n">LOCAL_FRONTIER_SIZE</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="n">__shared__</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">numCurrFrontier_s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">numCurrFrontier_s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">__syncthreads</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Perform BFS on private frontier
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">numPrevFroniter</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vertexId</span> <span class="o">=</span> <span class="n">prevFroniter</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">edge</span> <span class="o">=</span> <span class="n">graph</span><span class="p">.</span><span class="n">scrPtrs</span><span class="p">[</span><span class="n">vertexId</span><span class="p">];</span> <span class="n">edge</span> <span class="o">&lt;</span> <span class="n">graph</span><span class="p">.</span><span class="n">scrPtrs</span><span class="p">[</span><span class="n">vertexId</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span> <span class="n">edge</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">neighbor</span> <span class="o">=</span> <span class="n">graph</span><span class="p">.</span><span class="n">dstList</span><span class="p">[</span><span class="n">edge</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">atomicCAS</span><span class="p">(</span><span class="n">level</span> <span class="o">+</span> <span class="n">neighbor</span><span class="p">,</span> <span class="mh">0xFFFFFFFF</span><span class="p">,</span> <span class="n">currLevel</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0xFFFFFFFF</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// Once a new frontier node is found,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="kt">unsigned</span> <span class="n">currFroniterIndex</span> <span class="o">=</span> <span class="n">atomicAdd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">numCurrFrontier_s</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">currFroniterIndex</span> <span class="o">&lt;</span> <span class="n">LOCAL_FRONTIER_SIZE</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// Try to add it to the private frontier (currFrontier_s)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="n">currFrontier_s</span><span class="p">[</span><span class="n">currFroniterIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">neighbor</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">numCurrFrontier_s</span> <span class="o">=</span> <span class="n">LOCAL_FRONTIER_SIZE</span><span class="p">;</span>  <span class="c1">// frontier is full, stop adding new elements
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">currFrontierIdx</span> <span class="o">=</span> <span class="n">atomicAdd</span><span class="p">(</span><span class="n">numCurrFroniter</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                    <span class="n">currFroniter</span><span class="p">[</span><span class="n">currFrontierIdx</span><span class="p">]</span> <span class="o">=</span> <span class="n">neighbor</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Copy private frontier to global frontier
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">__syncthreads</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">__shared__</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">currFrontierStartIdx</span><span class="p">;</span>  <span class="c1">// Start index of private frontier in global frontier
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">currFrontierStartIdx</span> <span class="o">=</span> <span class="n">atomicAdd</span><span class="p">(</span><span class="n">numCurrFroniter</span><span class="p">,</span> <span class="n">numCurrFrontier_s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">__syncthreads</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Commit private frontier to global frontier
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">numCurrFrontier_s</span><span class="p">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">currFroniterIdx</span> <span class="o">=</span> <span class="n">currFrontierStartIdx</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">currFroniter</span><span class="p">[</span><span class="n">currFroniterIdx</span><span class="p">]</span> <span class="o">=</span> <span class="n">currFrontier_s</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div>]]></content:encoded>
    </item>
    <item>
      <title>PMPP Learning-Chapter 14 Sparse Matrix Computation</title>
      <link>http://localhost:1313/blogs/courselearning/pmpp/pmpp-ch14/</link>
      <pubDate>Wed, 18 Sep 2024 11:43:12 +0800</pubDate>
      <guid>http://localhost:1313/blogs/courselearning/pmpp/pmpp-ch14/</guid>
      <description>Personal notebook 14 of Programming Massively Parallel</description>
      <content:encoded><![CDATA[<h1 id="14-sparse-matrix-computation">14 Sparse Matrix Computation</h1>
<p>在稀疏矩阵中，大多数元素是零。存储和处理这些零元素在内存容量、内存带宽、时间和能量方面是浪费的。</p>
<h2 id="141-background">14.1 Background</h2>
<p>矩阵常用于求解 N 个未知数 N 个方程的线性系统，其形式为 AX+Y = 0，其中A是一个 NxN 矩阵，X 是一个 N 维的未知数向量，Y 是一个 N 维的常数向量。求解线性方程组的迭代方法中最耗时的部分是对计算 AX+Y，这是一个稀疏矩阵向量的乘法和累加。
删除所有的零元素不仅节省了存储空间，而且消除了从内存中获取这些零元素并对它们执行无用的乘法或加法操作的冗余步骤。
以下是一些在稀疏矩阵存储格式的结构中的关键考虑因素如下:</p>
<ul>
<li>空间效率 (<em>Space efficiency</em>): 使用存储格式表示矩阵所需的内存容量。</li>
<li>灵活性 (<em>Flexibility</em>): 通过添加或删除非零来修改矩阵的存储格式的方便程度•</li>
<li>可访问性 (<em>Accessibility</em>): 存储格式是否易于访问数据。</li>
<li>内存访问效率 (<em>Memory access efficiency</em>): 存储格式在多大程度上为特定计算实现了有效的内存访问模式 (正则化的一个方面).</li>
<li>负载平衡 (<em>Load balancing</em>): 存储格式在多大程度上为特定计算在不同线程之间平衡负载 (正则化的另一个方面).</li>
</ul>
<h2 id="142-a-simple-spmv-kernel-with-the-coo-format">14.2 A simple SpMV kernel with the COO format</h2>
<p>如下图所示， COO (<em>COOrdinate</em>) 格式是一种稀疏矩阵的存储格式，其中矩阵元素以三元组的形式存储，即 <code>(i, j, a_ij)</code>. 、</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEBef2abaed055d77396d3fb9ef77660515?method=download&amp;shareKey=7c73fa2fae1de40aff87876e3c37e6f6" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEBef2abaed055d77396d3fb9ef77660515?method=download&amp;shareKey=7c73fa2fae1de40aff87876e3c37e6f6" alt="Example of the Coordinate List (COO) Format">
    </a><figcaption>Example of the Coordinate List (COO) Format</figcaption></figure></p>
<p>使用以 COO 格式表示的稀疏矩阵并行执行 SpMV (<em>Sparse Matrix Vector Multiplication</em>) 的一种方法是为矩阵中的每个非零元素分配一个线程，下图是其示意图。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEBba4140a13706e68918e8a9fc953e764a?method=download&amp;shareKey=21a3ec827ee9d185f7c0c0e124b9379b" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEBba4140a13706e68918e8a9fc953e764a?method=download&amp;shareKey=21a3ec827ee9d185f7c0c0e124b9379b" alt="Example of Parallelizing SpMV with the COO Format">
    </a><figcaption>Example of Parallelizing SpMV with the COO Format</figcaption></figure></p>
<p>对应的内核代码如下所示，它在列索引对应的位置查找输入向量值，将其乘以非零值，然后将结果累加到对应的行索引处的输出值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">COOMATRIX</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span><span class="o">*</span> <span class="n">rowIdx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span><span class="o">*</span> <span class="n">colIdx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">float</span><span class="o">*</span> <span class="n">val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">numNonZeros</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">__global__</span> 
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">spmv_coo_kernel</span><span class="p">(</span><span class="n">COOMATRIX</span> <span class="n">m</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// Assign a thread to each nonzero element
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">.</span><span class="n">numNonZeros</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">rowIdx</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">		<span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">colIdx</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">		<span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">val</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">		<span class="n">atomicAdd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">y</span><span class="p">[</span><span class="n">row</span><span class="p">],</span> <span class="n">val</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="n">col</span><span class="p">]);</span>  <span class="c1">// Perform the matrix-vector multiplication
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>下面来分析 COO 格式在几个性能指标上的表现。</p>
<ul>
<li>空间效率：COO 需要三个数组，<code>rowIdx</code>, <code>colIdx</code> 和 <code>value</code>，每个数组的元素数量与非零元素的数量相同。</li>
<li>灵活性：只要以相同的方式重新排序 <code>rowIdx</code>, <code>colIdx</code> 和 <code>value</code> 数组，就可以在不丢失任何信息的情况下任意地以 COO 格式重新排序元素。</li>
<li>可访问性方面：COO 不易访问某一行或某一列中的所有非零元素。</li>
<li>内存访问效率：相邻线程访问 COO 格式的每个数组中的相邻元素。因此，通过 SpMV/COO 对矩阵的访问是内存合并的。</li>
<li>负载平衡：由于每个线程负责计算一个非零元素，所有线程负责相同数量的工作。
<em>SpMV/COO 的主要缺点是需要使用原子操作</em>，非常耗时。</li>
</ul>
<h2 id="143-grouping-row-nonzeros-with-the-csr-format">14.3 Grouping Row Nonzeros with the CSR Format</h2>
<p>如果将同一行中的所有非零都分配给同一个线程，那么该线程将是唯一更新相应输出值的线程，则可以避免原子操作。这种可访问性可以通过 CSR (Compressed Sparse Row ) 存储格式实现。下图说明了如何使用 CSR 格式存储 14.1 节中的矩阵。CSR 也将非零值存储在一维数组中，但这些非零值是按行分组的。COO 格式和 CSR 格式之间的关键区别在于，CSR 格式用 rowPtrs 数组替换了 rowIdx 数组，rowPtrs 数组存储了 colIdx 和 value 数组中每行非零的起始偏移量，每行中的非零元素不一定按列索引排序。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEB58c586fae078693686b726fe92eca4d5?method=download&amp;shareKey=011f87e0d08ea4e961006f353bf06fa7" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEB58c586fae078693686b726fe92eca4d5?method=download&amp;shareKey=011f87e0d08ea4e961006f353bf06fa7" alt="Example of Compressed Sparse Row (CSR) Format">
    </a><figcaption>Example of Compressed Sparse Row (CSR) Format</figcaption></figure></p>
<p>如下图所示，要使用以 CSR 格式表示的稀疏矩阵并行执行 SpMV，可以为矩阵的每一行分配一个线程。由于一个线程遍历一行，所以每个线程将输出写入不同的内存位置。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEB5af8c1b2e91b7e460d54f44a9fa3baaf?method=download&amp;shareKey=434cc8c983d44ceaa2c52d237d6e3c1c" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEB5af8c1b2e91b7e460d54f44a9fa3baaf?method=download&amp;shareKey=434cc8c983d44ceaa2c52d237d6e3c1c" alt="Example of Parallelizing SpMV with the CSR Format">
    </a><figcaption>Example of Parallelizing SpMV with the CSR Format</figcaption></figure></p>
<p>对应的内核代码如下，每个线程确定它负责的行，循环遍历该行的非零元素来执行点积。线程在 <code>rowPtrs</code> 数组中确定它们的起始索引 (<code>rowPtrs[row]</code>)和通过下一行非零的起始索引 (<code>rowPtrs[row+1]</code>) 来确定结束位置。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">CSRMatrix</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span><span class="o">*</span> <span class="n">rowPtrs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span><span class="o">*</span> <span class="n">colIdx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">float</span><span class="o">*</span> <span class="n">val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">numRows</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">__global__</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">spmv_csr_kernel</span><span class="p">(</span><span class="n">CSRMatrix</span> <span class="n">m</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// Assign a thread to each row
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">row</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">.</span><span class="n">numRows</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">rowPtrs</span><span class="p">[</span><span class="n">row</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">		<span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">rowPtrs</span><span class="p">[</span><span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">		<span class="kt">float</span> <span class="n">sum</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">colIdx</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">			<span class="kt">float</span> <span class="n">val</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">val</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">			<span class="n">sum</span> <span class="o">+=</span> <span class="n">val</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="n">col</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="n">y</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum</span><span class="p">;</span>  <span class="c1">// Perform the matrix-vector multiplication
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>下面来分析 CSR 格式在几个性能指标上的表现。</p>
<ul>
<li>空间效率：CSR 需要三个数组，其中 <code>colIdx</code> 和 <code>value</code> 的维度和非零元素的数量一样。<code>rowPtrs</code> 维度等于行数加 1.</li>
<li>灵活性：CSR 格式中要添加的非零必须添加到它所属的特定行中。这意味着后面行的非零元素都需要移动，后面行的行指针都需要相应增加。</li>
<li>可访问性：CSR 可以很容易地访问给定行的非零元素，允许在 SpMV/CSR 中跨行并行。</li>
<li>内存访问效率：CSR 访问模式使得连相邻程访问的数据相距很远，并不能进行内存合并。</li>
<li>负载平衡：线程在点积循环中进行的迭代次数取决于分配给线程的行中非零元素的数量，因此大多数甚至所有线程中都存在控制发散。</li>
</ul>
<h2 id="144-improving-memory-coalescing-with-the-ell-format">14.4 Improving Memory Coalescing with the ELL Format</h2>
<p>ELL 存储格式通过对稀疏矩阵数据进行填充和转置，可以解决非合并内存访问的问题。它的名字来源于 ELLPACK 中的稀疏矩阵包，一个用于求解椭圆边值问题的包。
一个用 ELL 格式存储的例子如下图所示。从按行分组非零的 CSR 格式中确定具有最大非零元素数量的行。然后在所有其他行的非零元素之后的添加填充元素，使它们与最大行长度相同。最后按列主元素顺序存储填充矩阵。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEB8edc4d051905f48396eed329afa0c448?method=download&amp;shareKey=88bf3affb57e04c78c662c0670721e0c" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEB8edc4d051905f48396eed329afa0c448?method=download&amp;shareKey=88bf3affb57e04c78c662c0670721e0c" alt="Example of ELL Storage Format">
    </a><figcaption>Example of ELL Storage Format</figcaption></figure></p>
<p>下图使用 ELL 格式并行化 SpMV。与 CSR 一样，每个线程被分配到矩阵的不同行。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEBacb970fc57de19c7e45ab63353ecfdce?method=download&amp;shareKey=8b7e2e9723776c11dbf40de54b6a6075" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEBacb970fc57de19c7e45ab63353ecfdce?method=download&amp;shareKey=8b7e2e9723776c11dbf40de54b6a6075" alt="Example of Parallelizing SpMV with the ELL Format">
    </a><figcaption>Example of Parallelizing SpMV with the ELL Format</figcaption></figure></p>
<p>对应的内核代码如下，点积循环遍历每行的非零元素。SpMV/ELL 内核假设输入矩阵有一个向量 <code>ellMatrix.nnzPerRow</code> 记录每行中非零的数量，每个线程只迭代其分配的行中的非零元素。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">ELLMATRIX</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span><span class="o">*</span> <span class="n">nnzPerRow</span><span class="p">;</span>  <span class="c1">// Number of nonzeros per row
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">int</span><span class="o">*</span> <span class="n">colIdx</span><span class="p">;</span>  <span class="c1">// Column indices of nonzeros
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">float</span><span class="o">*</span> <span class="n">val</span><span class="p">;</span>  <span class="c1">// Nonzero values
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">int</span> <span class="n">numRows</span><span class="p">;</span>  <span class="c1">// Number of rows
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">__global__</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">spmv_ell_kernel</span><span class="p">(</span><span class="n">ELLMATRIX</span> <span class="n">m</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">row</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">.</span><span class="n">numRows</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kt">float</span> <span class="n">sum</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">.</span><span class="n">nnzPerRow</span><span class="p">[</span><span class="n">row</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// ell matrix stores values in column-major order
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">colIdx</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">m</span><span class="p">.</span><span class="n">numRows</span> <span class="o">+</span> <span class="n">row</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">			<span class="kt">float</span> <span class="n">val</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">val</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">m</span><span class="p">.</span><span class="n">numRows</span> <span class="o">+</span> <span class="n">row</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">			<span class="n">sum</span> <span class="o">+=</span> <span class="n">val</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="n">col</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="n">y</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum</span><span class="p">;</span>  <span class="c1">// Perform the matrix-vector multiplication
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>下面来分析 CSR 格式在几个性能指标上的表现。</p>
<ul>
<li>空间效率：由于填充元素的空间开销，ELL格式的空间效率低于CSR格式。</li>
<li>灵活性：ELL 格式的比 CSR 格式有更高的灵活性。只要一行没有达到矩阵中非零的最大数目，就可以通过简单地用实际值替换填充元素来向该行添加非零。</li>
<li>可访问性：ELL 可以访问某一行的非零元素。ELL 还允许在给定非零元素的索引后得到该元素的行和列索引，因为 <code>i = col*m.numRows + row</code>, 通过 <code>i % m.numRows</code> 就可以得到所在的行。</li>
<li>内存访问效率：由于元素按列主序排列，所有相邻的线程现在都访问相邻的内存位置。</li>
<li>负载平衡：SpMV/ELL 仍然和 SpMV/CSR 具有相同的负载不平衡问题，因为每个线程循环次数仍取决它负责的行中的非零元素数量。</li>
</ul>
<h2 id="145-regulating-padding-with-the-hybrid-ell-coo-format">14.5 Regulating Padding with the Hybrid ELL-COO Format</h2>
<p>在 ELL 格式中，当一行或少数行具有非常多的非零元素时，空间效率低和控制发散的问题最为明显。COO 格式可用于限制 ELL 格式中的行长度。在将稀疏矩阵转换为 ELL 之前，我们可以从具有大量非零元素的行中取出一些元素，并将这些元素用单独的 COO 格式存储。
下图展示了如何使用混合 ELL-COO 格式存储图中矩阵。从 ELL 格式中删除第二行的最后 3 个非零元素和第六行的最后 2 个非零元素，并将它们移动到单独的 COO 格式中。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEBa993b596c97e6f2c8d465a7d2eefee9a?method=download&amp;shareKey=558b288f71efe76be4032f0848e44ebd" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEBa993b596c97e6f2c8d465a7d2eefee9a?method=download&amp;shareKey=558b288f71efe76be4032f0848e44ebd" alt="Hybrid ELL-COO Example">
    </a><figcaption>Hybrid ELL-COO Example</figcaption></figure></p>
<p>对应的内核代码如下，点积将被划分为两部分处理，一部分负责处理 ELL 格式的非零元素，另一部分负责处理 COO 格式中 rowIdx 与 row 相同的非零元素。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">__global__</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">spmv_hybrid_ell_coo_kernel</span><span class="p">(</span><span class="n">ELLMATRIX</span> <span class="n">ell</span><span class="p">,</span> <span class="n">COOMATRIX</span> <span class="n">coo</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">float</span> <span class="n">sum</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// ELL part
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">row</span> <span class="o">&lt;</span> <span class="n">ell</span><span class="p">.</span><span class="n">numRows</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ell</span><span class="p">.</span><span class="n">nnzPerRow</span><span class="p">[</span><span class="n">row</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="n">ell</span><span class="p">.</span><span class="n">colIdx</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">ell</span><span class="p">.</span><span class="n">numRows</span> <span class="o">+</span> <span class="n">row</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">			<span class="kt">float</span> <span class="n">val</span> <span class="o">=</span> <span class="n">ell</span><span class="p">.</span><span class="n">val</span><span class="p">[</span><span class="n">col</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">			<span class="n">sum</span> <span class="o">+=</span> <span class="n">val</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="n">col</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">y</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum</span><span class="p">;</span>  <span class="c1">// Perform the matrix-vector multiplication
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="c1">// COO part
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">coo</span><span class="p">.</span><span class="n">numNonZeros</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="n">coo</span><span class="p">.</span><span class="n">colIdx</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">		<span class="kt">float</span> <span class="n">val</span> <span class="o">=</span> <span class="n">coo</span><span class="p">.</span><span class="n">val</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">		<span class="n">sum</span> <span class="o">+=</span> <span class="n">val</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="n">col</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">		<span class="n">atomicAdd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">y</span><span class="p">[</span><span class="n">row</span><span class="p">],</span> <span class="n">val</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="n">col</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>下面来分析混合 ELL-COO 格式在几个性能指标上的表现。</p>
<ul>
<li>空间效率：因为减少了填充元素，混合 ELL-COO 格式比单独使用 ELL 格式的空间效率更高。</li>
<li>灵活性：混合 COO-ELL 既可以通过替换填充元素来添加非零。如果该行没有任何可以在 ELL 部分中替换的填充元素，也可以在格式的 COO 部分添加。</li>
<li>可访问性：访问给定行中所有的非零元素只能用于适合用 ELL 格式存储的部分行。</li>
<li>内存访问效率：SpMV/ELL 和 SpMV/COO 都能对稀疏矩阵进行合并内存访问。因此，它们的组合也将是合并访问模式。</li>
<li>负载平衡：从ELL 格式部分移除一些非零元素可以减少 SpMV/ELL 内核的控制发散。这些非零元素被放在 COO 格式部分，不会出现控制发散。</li>
</ul>
<h2 id="146-reducing-control-divergence-with-the-jds-format">14.6 Reducing Control Divergence with the JDS Format</h2>
<p>根据矩阵中行的非零元素夺少进行降序排序之后矩阵在很大程度上看起来像三角形矩阵，因此这种格式通常被称为 JDS (<em>Jagged Diagonal Storage</em>) 格式。
下图展示了如何使用 JDS 格式存储矩阵。首先，与 CSR 和 ELL 格式一样将非零元素按行分组。接下来，按每行中非零的个数从大到小排序。<code>value</code> 数组中的非零值及其存储其对应列索引的 <code>colIdx</code> 数组按列主元素顺序存储。在每次迭代中添加一个 <code>iterPtr</code> 数组来跟踪非零元素的开始位置。并且维护一个保留原始行索引的 <code>rowIdx</code> 数组。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEBb894f6329a43fbdd14f93fe7572ffaa5?method=download&amp;shareKey=c451117b781a978aa9f937f2bb65f097" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEBb894f6329a43fbdd14f93fe7572ffaa5?method=download&amp;shareKey=c451117b781a978aa9f937f2bb65f097" alt="Example of JDS Storage Format">
    </a><figcaption>Example of JDS Storage Format</figcaption></figure></p>
<p>对应的内核代码如下，我们一共要迭代 <code>maxNumNonZerosPerRow</code> 次，每次迭代中每个线程判断自己负责的行是否还存在非零元素。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">JDSMATRIX</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span><span class="o">*</span> <span class="n">iterPtr</span><span class="p">;</span>  <span class="c1">// Pointer to the start of each row in the JDS format
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">int</span><span class="o">*</span> <span class="n">colIdx</span><span class="p">;</span>  <span class="c1">// Column indices of nonzeros
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">float</span><span class="o">*</span> <span class="n">val</span><span class="p">;</span>  <span class="c1">// Nonzero values
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">int</span><span class="o">*</span> <span class="n">rowIdx</span><span class="p">;</span> <span class="c1">// Original row indices
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">int</span> <span class="n">numRows</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">maxNumNonZerosPerRow</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">__global__</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">spmv_jds_kernel</span><span class="p">(</span><span class="n">JDSMATRIX</span> <span class="n">m</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">row</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">.</span><span class="n">numRows</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kt">float</span> <span class="n">sum</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">.</span><span class="n">maxNumNonZerosPerRow</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">iterPtr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">			<span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">iterPtr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="n">row</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="n">sum</span> <span class="o">+=</span> <span class="n">m</span><span class="p">.</span><span class="n">val</span><span class="p">[</span><span class="n">row</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="n">y</span><span class="p">[</span><span class="n">m</span><span class="p">.</span><span class="n">rowIdx</span><span class="p">[</span><span class="n">row</span><span class="p">]]</span> <span class="o">=</span> <span class="n">sum</span><span class="p">;</span>  <span class="c1">// Perform the matrix-vector multiplication
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>下面来分析 JDS 格式在几个性能指标上的表现。</p>
<ul>
<li>空间效率：因为避免了填充 JDS 格式比 ELL 格式效率更高。</li>
<li>灵活性：JDS 格式的灵活性较差，因为添加非零会改变行大小，这可能需要重新对行进行排序。</li>
<li>可访问性：JDS 格式类似于CSR格式，允许在给定行索引的情况下访问该行的非零元素。</li>
<li>内存访问效率：JDS 格式的内存访问效率比 ELL 格式高，因为它可以对稀疏矩阵进行合并访问。</li>
<li>负载平衡：JDS 格式对矩阵的行进行排序，使得相邻线程遍长度接近的行。因此，JDS 格式能减少控制发散。</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>PMPP Learning-Chapter 13 Sorting</title>
      <link>http://localhost:1313/blogs/courselearning/pmpp/pmpp-ch13/</link>
      <pubDate>Sat, 14 Sep 2024 13:36:12 +0800</pubDate>
      <guid>http://localhost:1313/blogs/courselearning/pmpp/pmpp-ch13/</guid>
      <description>Personal notebook 13 of Programming Massively Parallel</description>
      <content:encoded><![CDATA[<h1 id="13-sorting">13 Sorting</h1>
<p>排序算法将列表中的数据元素按一定的顺序排列。</p>
<h2 id="131-background">13.1 Background</h2>
<p>任何排序算法都必须满足以下两个条件:</p>
<ul>
<li>输出是非递减顺序或非递增顺序。</li>
<li>输出是输入的一种排列 (permutation).</li>
</ul>
<p>排序算法可以分为稳定算法和不稳定算法。当两个元素具有相同的键值时，稳定的排序算法保留了原始的出现顺序。
排序算法也可以分为基于比较的算法和非基于比较的算法。基于比较的排序算法无法达到比 O(NlogN) 更好的复杂度，因为它们必须在元素之间执行最少次数的比较。</p>
<h2 id="132-radix-sort">13.2 Radix Sort</h2>
<p>基数排序是一种基于非比较的排序算法，其工作原理是根据基数值将要排序的键分布到桶 (bucket) 中。如果键由多个数字组成，则重复对每个数字重复分配桶，直到覆盖所有数字。
下图展示了如何使用 1 位基数对 4 位整数列表进行基数排序。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEB25b04d30be5a63b12bfdbb3093994f44?method=download&amp;shareKey=92a8bec7bdc022c628a42bd27a54086b" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEB25b04d30be5a63b12bfdbb3093994f44?method=download&amp;shareKey=92a8bec7bdc022c628a42bd27a54086b" alt="A Radix Sort Example">
    </a><figcaption>A Radix Sort Example</figcaption></figure></p>
<h2 id="133-parallel-radix-sort">13.3 Parallel Radix Sort</h2>
<p>基数排序的每次迭代都依赖于前一次迭代的整个结果。因此，迭代是相对于彼此顺序执行的。我们将重点关注执行单个基数排序迭代的内核的实现，并假设主机代码每次迭代调用该内核一次。
在 GPU 上并行化基数排序迭代的一种直接方法是让每个线程负责输入列表中的一个键。线程必须确定键在输出列表中的位置，然后将键存储到该位置。
下图展示了这种并行化方法第一次迭代的执行情况。对于映射到 0 桶的键，目标索引可以通过如下公式计算：
</p>
$$
\begin{align*} 
\text{destination of a zero} &=  \text{\#zeros before} \\
&=\text{\#keys before} - \text{\#ones before} \\
&=\text{key index}-\text{\#ones before}
\end{align*}
$$<p>对于映射到 1 桶的键，目标索引如下所示:</p>
$$
\begin{align*}
\text{destination of a one}&=\text{\#zeros in total}+\text{\#ones before} \\
&=(\text{\#keys in total}-\text{\#ones in total})+\text{\#ones before} \\
&=\text{input size}-\text{\#ones in total}+\text{\#ones before}
\end{align*}
$$<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEBa8ef27e147df1b0c4de80ee951d9f79d?method=download&amp;shareKey=c3797389c4f43d2d3ec67d06eef347f3" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEBa8ef27e147df1b0c4de80ee951d9f79d?method=download&amp;shareKey=c3797389c4f43d2d3ec67d06eef347f3" alt="Parallelizing a Radix Sort Iteration by Assigning One Input Key to Each Thread">
    </a><figcaption>Parallelizing a Radix Sort Iteration by Assigning One Input Key to Each Thread</figcaption></figure></p>
<p>下图展示了每个线程查找其键的目标索引所执行的操作。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEBb99f77f6611178972cecd41b56175600?method=download&amp;shareKey=3c54c366645f7a1dadda9f884843f70a" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEBb99f77f6611178972cecd41b56175600?method=download&amp;shareKey=3c54c366645f7a1dadda9f884843f70a" alt="Finding the Destination of Each Input Key">
    </a><figcaption>Finding the Destination of Each Input Key</figcaption></figure></p>
<p>对应的内核代码如下所示。在每个线程确定自己的索引并提取出对应的 bit 后，因为这些位不是 0 就是 1，所以排除扫描的结果就等于索引前面 1 的个数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">__global__</span> 
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">exclusiveScan</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span> <span class="n">bits</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">extern</span> <span class="n">__shared__</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">temp</span><span class="p">[];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">thid</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Load input into shared memory
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">temp</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">thid</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">thid</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">)</span> <span class="o">?</span> <span class="n">bits</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">thid</span><span class="p">]</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">temp</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">thid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">thid</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">)</span> <span class="o">?</span> <span class="n">bits</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">thid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Build sum in place up the tree
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">N</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span> <span class="n">d</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">d</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">__syncthreads</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">thid</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">ai</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">thid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">bi</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">thid</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">temp</span><span class="p">[</span><span class="n">bi</span><span class="p">]</span> <span class="o">+=</span> <span class="n">temp</span><span class="p">[</span><span class="n">ai</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">offset</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Clear the last element
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">thid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">temp</span><span class="p">[</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Traverse down the tree
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">d</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">offset</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">__syncthreads</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">thid</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">ai</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">thid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// left child index of the thread
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="kt">int</span> <span class="n">bi</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">thid</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// right
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="n">ai</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="n">temp</span><span class="p">[</span><span class="n">ai</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="n">bi</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="n">temp</span><span class="p">[</span><span class="n">bi</span><span class="p">]</span> <span class="o">+=</span> <span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Write results to output array
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">__syncthreads</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">thid</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">)</span> <span class="n">bits</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">thid</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">thid</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">thid</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">)</span> <span class="n">bits</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">thid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">thid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">__global__</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">radix_sort_iter</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span> <span class="n">input</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span> <span class="n">output</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span> <span class="n">bits</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">iter</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">key</span><span class="p">,</span> <span class="n">bit</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">key</span> <span class="o">=</span> <span class="n">input</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">		<span class="n">bit</span> <span class="o">=</span> <span class="p">(</span><span class="n">key</span> <span class="o">&gt;&gt;</span> <span class="n">iter</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">bits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">bit</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">exclusiveScan</span><span class="p">(</span><span class="n">bits</span><span class="p">,</span> <span class="n">N</span><span class="p">);</span>  <span class="c1">// # ones before
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">numberOnesBefore</span> <span class="o">=</span> <span class="n">bits</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">numberOnesTotal</span> <span class="o">=</span> <span class="n">bits</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dst</span> <span class="o">=</span> <span class="p">(</span><span class="n">bit</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">numberOnesBefore</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="n">numberOnesTotal</span> <span class="o">-</span> <span class="n">numberOnesBefore</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="n">output</span><span class="p">[</span><span class="n">dst</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="134-optimizing-for-memory-coalescing">13.4 Optimizing for Memory Coalescing</h2>
<p>上面方法效率低下的一个主要原因是，对输出数组的写入显示出不能以内存合并的模式访问。改进后的算法如下图所示，每个块中的线程将首先执行块级别的局部排序，以分离共享内存中映射到 0 bucket 的键和映射到 1 bucket 的键。此优化中的主要挑战是每个线程块在全局 bucket 中确定其位置。线程块的 0 桶的位置在前面线程块的所有 0 桶之后。另一方面，线程块的 1 桶的位置在所有线程块的 0 桶和之前线程块的所有 1 桶之后。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEBf574d6d0c92edf4dc69026e429cc9f87?method=download&amp;shareKey=37e73d2ec0d91af6e330c10db179d93a" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEBf574d6d0c92edf4dc69026e429cc9f87?method=download&amp;shareKey=37e73d2ec0d91af6e330c10db179d93a" alt="Optimizing for Memory Coalescing by Sorting Locally in Shared Memory">
    </a><figcaption>Optimizing for Memory Coalescing by Sorting Locally in Shared Memory</figcaption></figure></p>
<p>下图展示了如何使用排除扫描来查找每个线程块的本地桶的位置的。在完成局部基数排序之后，每个线程块标识其每个自己桶中键的数量。然后每个块将结果记录在如图中所示的表中，该表按行主顺序存储，对线性化的表执行排除扫描，结果表示线程块的本地 bucket 的起始位置。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEBea305ebe970559e5fae76374c79ee2f7?method=download&amp;shareKey=1a6535297a6a2fbccbeed23f7a25eeb6" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEBea305ebe970559e5fae76374c79ee2f7?method=download&amp;shareKey=1a6535297a6a2fbccbeed23f7a25eeb6" alt="Finding the Destination of Each Thread Block&rsquo;s Local Buckets">
    </a><figcaption>Finding the Destination of Each Thread Block&#39;s Local Buckets</figcaption></figure></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#define SECTION_SIZE 32
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="n">__global__</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">memory_coalescing_radix_sort</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span> <span class="n">input</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span> <span class="n">output</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span> <span class="n">bits</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span> <span class="n">table</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="p">,</span> <span class="kt">int</span> <span class="n">iter</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">__shared__</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">input_s</span><span class="p">[</span><span class="n">SECTION_SIZE</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="n">__shared__</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">output_s</span><span class="p">[</span><span class="n">SECTION_SIZE</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Load input into shared memory
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">globalIdx</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">globalIdx</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">input_s</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">input</span><span class="p">[</span><span class="n">globalIdx</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">__syncthreads</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Sort each section
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">radix_sort_iter</span><span class="p">(</span><span class="n">input_s</span><span class="p">,</span> <span class="n">output_s</span><span class="p">,</span> <span class="n">bits</span> <span class="o">+</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">SECTION_SIZE</span><span class="p">,</span> <span class="n">SECTION_SIZE</span><span class="p">,</span> <span class="n">iter</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">__syncthreads</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Store local bucket num
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">numberOnesTotal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">numberZerosTotal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SECTION_SIZE</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">numberOnesTotal</span> <span class="o">+=</span> <span class="n">bits</span><span class="p">[</span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">SECTION_SIZE</span> <span class="o">+</span> <span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">numberZerosTotal</span> <span class="o">=</span> <span class="n">SECTION_SIZE</span> <span class="o">-</span> <span class="n">numberOnesTotal</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">table</span><span class="p">[</span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">numberZerosTotal</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">table</span><span class="p">[</span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">numberOnesTotal</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">__syncthreads</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Exclusive prefix sum to determine output index
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">exclusiveScan</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Write results to output array
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">globalIdx</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">zeroOffset</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">oneOffset</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bit</span> <span class="o">=</span> <span class="n">bits</span><span class="p">[</span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">SECTION_SIZE</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dst</span> <span class="o">=</span> <span class="p">(</span><span class="n">bit</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">globalIdx</span> <span class="o">-</span> <span class="n">zeroOffset</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="n">oneOffset</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">output</span><span class="p">[</span><span class="n">dst</span><span class="p">]</span> <span class="o">=</span> <span class="n">input</span><span class="p">[</span><span class="n">globalIdx</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="135-choice-of-radix-value">13.5 Choice of Radix Value</h2>
<p>使用 2 bit 的基数时，如下图所示，每次迭代使用两个比特将键分发到存储桶。因此，两次迭代就可以对 4 bit 键进行完全排序。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEBaa1313e289f139eb041b02b86260874b?method=download&amp;shareKey=6a9fbd43b0fe2c1926459a7a6ba87d92" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEBaa1313e289f139eb041b02b86260874b?method=download&amp;shareKey=6a9fbd43b0fe2c1926459a7a6ba87d92" alt="Radix Sort Example with 2-bit Radix">
    </a><figcaption>Radix Sort Example with 2-bit Radix</figcaption></figure></p>
<p>为了内存合并访问，如下图所示，每个线程块可以在共享内存中对其键进行本地排序，然后将每个本地桶中的键的数量写入表中。和 13.4 节一样，对于 r 位基数，对具有 2^r 行的表执行排除扫描操作。最后以合并的方式将本地 bucket 写入全局内存。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEB7943d691aa80d8cf1d4cc9d9055dad8c?method=download&amp;shareKey=b1c724f7996b46a5b15f81c91d6a88d3" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEB7943d691aa80d8cf1d4cc9d9055dad8c?method=download&amp;shareKey=b1c724f7996b46a5b15f81c91d6a88d3" alt="Optimizing 2-bit Radix Sorting for Memory Coalescing Using the Shared Memory">
    </a><figcaption>Optimizing 2-bit Radix Sorting for Memory Coalescing Using the Shared Memory</figcaption></figure></p>
<p>使用更大的基数也有缺点</p>
<ol>
<li>每个线程块有更多的本地桶，每个桶有更少的键。这样就会向多个全局内存块进行写入，但每一部分写入的数据变少，不利于内存合并。</li>
<li>进行排除扫描的表会随着基数的增大而变大，扫描的开销随着基数的增加而增加。</li>
</ol>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEB3df7c81b854884404a6b583c1fbb99fa?method=download&amp;shareKey=82b507cb68c828d45eb81bf4b8be6e5a" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEB3df7c81b854884404a6b583c1fbb99fa?method=download&amp;shareKey=82b507cb68c828d45eb81bf4b8be6e5a" alt="Finding the Destination of Each Block&rsquo;s Local Buckets for a 2-bit Radix">
    </a><figcaption>Finding the Destination of Each Block&#39;s Local Buckets for a 2-bit Radix</figcaption></figure></p>
<h2 id="136-thread-coarsening-to-improve-coalescing">13.6 Thread Coarsening to Improve Coalescing</h2>
<p>跨多个线程块并行化基数排序的一个代价是对全局内存的写的访问合并很差。每个线程块都有自己的本地桶，并将其写入全局内存。拥有更多的线程块意味着每个线程块拥有更少的键，这意味着本地存储桶将更小，从而在将它们写入全局内存时合并机会更少。另一个代价是执行全局排除扫描以识别每个线程块的本地桶的存储位置的开销。通过应用线程粗化，可以减少块的数量，从而减少表的大小和排除扫描操作的开销。
下图展示了如何将线程粗化应用于 2 位基数排序。每个线程被分配给输入列表中的多个键。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEBc83cef230dd49ea34fafa2da625e2181?method=download&amp;shareKey=551310570976f664cdbd714653b982b2" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEBc83cef230dd49ea34fafa2da625e2181?method=download&amp;shareKey=551310570976f664cdbd714653b982b2" alt="Radix Sort for a 2-bit Radix with Thread Coarsening">
    </a><figcaption>Radix Sort for a 2-bit Radix with Thread Coarsening</figcaption></figure></p>
<h2 id="137-parallel-merge-sort">13.7 Parallel Merge Sort</h2>
]]></content:encoded>
    </item>
    <item>
      <title>PMPP Learning-Chapter 12 Merge-An Introduction to Dynamic Input Data Identification</title>
      <link>http://localhost:1313/blogs/courselearning/pmpp/pmpp-ch12/</link>
      <pubDate>Fri, 13 Sep 2024 22:58:03 +0800</pubDate>
      <guid>http://localhost:1313/blogs/courselearning/pmpp/pmpp-ch12/</guid>
      <description>Personal notebook 12 of Programming Massively Parallel</description>
      <content:encoded><![CDATA[<h1 id="12-merge-an-introduction-to-dynamic-input-data-identification">12 Merge-An Introduction to Dynamic Input Data Identification</h1>
<p>有序归并操作接受两个有序列表并生成一个合并后的有序列表。</p>
<h2 id="121-background">12.1 Background</h2>
<p>假设数组中的每个元素都有一个键并且键定义了一个用 ≤ 表示的顺序关系。下图展示了基于数字排序关系的简单归并函数的操作。一般来说，如果键值相等的元素在输出中的顺序与其在输入中的顺序相同，则称排序操作是稳定的。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEB412d47f606b473f210d022c42a5bfb5a?method=download&amp;shareKey=615ec66182adab314c2bd9f9dbe85bc1" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEB412d47f606b473f210d022c42a5bfb5a?method=download&amp;shareKey=615ec66182adab314c2bd9f9dbe85bc1" alt="Example of a Merge Operation">
    </a><figcaption>Example of a Merge Operation</figcaption></figure></p>
<h2 id="122-a-sequential-merge-algorithm">12.2 A Sequential Merge Algorithm</h2>
<p>归并操作可以用如下一个简单的顺序算法来实现。顺序归并函数访问 A 和 B 的每个输入元素一次，并向 C 中每个位置写入一次。其算法复杂度为 O(m+n).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">merge_sequential</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">A</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">B</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">C</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// Indices for A, B, and C
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">C</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">C</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// Done with A[], handling remaining B
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="n">C</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">else</span> <span class="p">{</span>  <span class="c1">// Done with B[], handling remaining A
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="n">C</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="123-a-parallelization-approach">12.3 A Parallelization Approach</h2>
<p>每个线程首先确定它将要负责的输出位置范围，并使用该输出范围作为 <code>co-rank</code> 函数的输入，以确定所负责 C 输出范围的对应的 A 和 B 输入范围。这样每个线程在它们的子数组上执行顺序合并函数，从而并行地进行合并。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEBcd07196d1e74562f5e44926357511c97?method=download&amp;shareKey=cdae7d4e37b42cde506885c860e9fb5b" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEBcd07196d1e74562f5e44926357511c97?method=download&amp;shareKey=cdae7d4e37b42cde506885c860e9fb5b" alt="Examples of Observations">
    </a><figcaption>Examples of Observations</figcaption></figure></p>
<ul>
<li><strong>Observation 1</strong>：子数组 <code>C[0]-C[k-1]</code> (k 个元素) 是 <code>A[0]-A[i-1]</code> (i 个元素) 和 <code>B[0]-B[k-i-1]</code> (k-i 个元素) 的归并结果。</li>
<li><strong>Observation 2</strong>：对于任意满足 0≤k≤m+n 的 k，我们可以找到唯一的 i 和 j 使得 k=i+j, 0≤i≤m, 0≤j≤n，并且子数组 <code>C[0]-C[k-1]</code> 是子数组 <code>A[0]-A[i-1]</code> 和子数组 <code>B[0]-B[j-1]</code> 合并的结果。唯一的索引 i 和 j 被称 <code>C[k]</code> 的 co-rank.</li>
</ul>
<p>我们可以通过将输出数组划分为子数组，并让每个线程负责一个子数组的生成来划分工作。由于并行归并算法中每个线程使用的输入元素的范围取决于实际的输入值使得我们需要辅助函数来完成。</p>
<h2 id="124-co-rank-function-implementation">12.4 Co-rank Function Implementation</h2>
<p>将 co-rank 函数定义为接受输出数组 C 中元素的位置 k 和两个输入数组 A 和 B的信息，并返回输入数组 A 对应的 co-rank 值 i.
以下图为例，假设线程 1 的 co-rank 函数的目标是为其秩 k1=4 确定 co-rank值 i1=3 和 j1=1. 也就是说，从 <code>C[4]</code> 开始的子数组将由从 <code>A[3]</code> 和  <code>B[1]</code> 开始的子数组合并生成。我们可以发现线程 t 使用的输入子数组由线程 t 和线程 t+1 的 co-rank 确定。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEBc24a7460cb3237cd2404a21d2f9984f9?method=download&amp;shareKey=09ff2b105b2d3b266478ce1b840d92bb" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEBc24a7460cb3237cd2404a21d2f9984f9?method=download&amp;shareKey=09ff2b105b2d3b266478ce1b840d92bb" alt="Example of co-rank Function Execution">
    </a><figcaption>Example of co-rank Function Execution</figcaption></figure></p>
<p>目标是找到使得 <code>A[i - 1] &lt;= B[j]</code> 并且 <code>B[j - 1] &lt;= A[i]</code> 的索引。</p>
<ul>
<li>如果 <code>A[i-1] &gt; B[j]</code>，说明 <code>A[i]</code> 太大，需要减少 i，并增加 j。</li>
<li>如果 <code>B[j-1] &gt; A[i]</code>，说明 <code>B[j]</code> 太大，需要减少 j，并增加 i。
每次调整时，i 和 j 都按照二分方式调整，即调整的步长是 delta / 2. i 和 i_low 确定了当前正在搜索的数组 A 的范围。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">co_rank</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">A</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">B</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// C[k] comes from A[i] of B[j]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// k = i + j
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="o">?</span> <span class="nl">k</span> <span class="p">:</span> <span class="n">m</span><span class="p">;</span>  <span class="c1">// max starting search value for A, i.e. A[k-1] &lt; B[0]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">int</span> <span class="n">i_low</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="n">n</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">k</span> <span class="o">-</span> <span class="n">n</span><span class="p">;</span>  <span class="c1">// when B is done, min starting search value for A is k-n
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">k</span> <span class="o">-</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">j_low</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="n">m</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="n">m</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">delta</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">bool</span> <span class="n">active</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">while</span> <span class="p">(</span><span class="n">active</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// Binary search for C[k]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">delta</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">i_low</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="n">j_low</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="n">j</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="n">i</span> <span class="o">-=</span> <span class="n">delta</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="o">&amp;&amp;</span> <span class="n">B</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">delta</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">j_low</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="n">i_low</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="n">i</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="n">j</span> <span class="o">-=</span> <span class="n">delta</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>  <span class="c1">// Found the correct position for C[k]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="n">active</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="125-a-basic-parallel-merge-kernel">12.5 A Basic Parallel Merge Kernel</h2>
<p>在剩下的小节里，我们假设输入数组 A 和 B 存储在全局内存中，一个内核被启动用来合并两个输入数组，输出一个同样位于全局内存中的数组 C.
下面内核是并行归并的直接实现。它首先通过计算当前线程 (<code>k_curr</code>) 和下一个线程 (<code>k_next</code>) 产生的输出子数组的起点来确定负责输出的范围。然后分别调用自己和后一个线程的 co_rank 函数来确定对应的 A 和 B 输入子数组的范围。最后调用顺序合并函数来合并两个输入子数组，并将结果写入输出子数组。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">__global__</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">mergre_basic_kernel</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">A</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">B</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">C</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// Each thread handles a section of C
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">int</span> <span class="n">tid</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">elementsPerThread</span> <span class="o">=</span> <span class="n">ceil</span><span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">tid</span> <span class="o">*</span> <span class="n">elementsPerThread</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">elementsPerThread</span><span class="p">,</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Determin the range of A and B to be merged for this thread
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">int</span> <span class="n">i_curr</span> <span class="o">=</span> <span class="n">co_rank</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">i_next</span> <span class="o">=</span> <span class="n">co_rank</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">j_curr</span> <span class="o">=</span> <span class="n">start</span> <span class="o">-</span> <span class="n">i_curr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">j_next</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">i_next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">merge_sequential</span><span class="p">(</span><span class="n">A</span> <span class="o">+</span> <span class="n">i_curr</span><span class="p">,</span> <span class="n">B</span> <span class="o">+</span> <span class="n">j_curr</span><span class="p">,</span> <span class="n">C</span> <span class="o">+</span> <span class="n">start</span><span class="p">,</span> <span class="n">i_next</span> <span class="o">-</span> <span class="n">i_curr</span><span class="p">,</span> <span class="n">j_next</span> <span class="o">-</span> <span class="n">j_curr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面的基本归并内核有 2 个问题：</p>
<ol>
<li>warp 中的相邻线程在读写输入和输出子数组元素时不会访问相邻的内存位置。</li>
<li>线程在执行 co-rank 函数时还需要从全局内存访问 A 和 B 的元素。</li>
</ol>
<h2 id="126-a-tiled-merge-kernel-to-improve-coalescing">12.6 A Tiled Merge Kernel to Improve Coalescing</h2>
<p>注意到相邻线程使用的 A 和 B 子数组在内存中彼此相邻。我们可以为为每个块调用 co-rank 函数来获得其 A 和 B 子数组的起始和结束位置。
<style type="text/css">
     
    .notice {
        --title-color: #fff;
        --title-background-color: #6be;
        --content-color: #444;
        --content-background-color: #e7f2fa;
    }

    .notice.info {
        --title-background-color: #fb7;
        --content-background-color: #fec;
    }

    .notice.tip {
        --title-background-color: #5a5;
        --content-background-color: #efe;
    }

    .notice.warning {
        --title-background-color: #c33;
        --content-background-color: #fee;
    }

     
    @media (prefers-color-scheme:dark) {
        .notice {
            --title-color: #fff;
            --title-background-color: #069;
            --content-color: #ddd;
            --content-background-color: #023;
        }

        .notice.info {
            --title-background-color: #a50;
            --content-background-color: #420;
        }

        .notice.tip {
            --title-background-color: #363;
            --content-background-color: #121;
        }

        .notice.warning {
            --title-background-color: #800;
            --content-background-color: #400;
        }
    }

    body.dark .notice {
        --title-color: #fff;
        --title-background-color: #069;
        --content-color: #ddd;
        --content-background-color: #023;
    }

    body.dark .notice.info {
        --title-background-color: #a50;
        --content-background-color: #420;
    }

    body.dark .notice.tip {
        --title-background-color: #363;
        --content-background-color: #121;
    }

    body.dark .notice.warning {
        --title-background-color: #800;
        --content-background-color: #400;
    }

     
    .notice {
        padding: 18px;
        line-height: 24px;
        margin-bottom: 24px;
        border-radius: 4px;
        color: var(--content-color);
        background: var(--content-background-color);
    }

    .notice p:last-child {
        margin-bottom: 0
    }

     
    .notice-title {
        margin: -18px -18px 12px;
        padding: 4px 18px;
        border-radius: 4px 4px 0 0;
        font-weight: 700;
        color: var(--title-color);
        background: var(--title-background-color);
    }

     
    .icon-notice {
        display: inline-flex;
        align-self: center;
        margin-right: 8px;
    }

    .icon-notice img,
    .icon-notice svg {
        height: 1em;
        width: 1em;
        fill: currentColor;
    }

    .icon-notice img,
    .icon-notice.baseline svg {
        top: .125em;
        position: relative;
    }
</style><div class="notice info" >
    <p class="notice-title">
        <span class="icon-notice baseline">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="92 59.5 300 300">
  <path d="M292 303.25V272c0-3.516-2.734-6.25-6.25-6.25H267v-100c0-3.516-2.734-6.25-6.25-6.25h-62.5c-3.516 0-6.25 2.734-6.25 6.25V197c0 3.516 2.734 6.25 6.25 6.25H217v62.5h-18.75c-3.516 0-6.25 2.734-6.25 6.25v31.25c0 3.516 2.734 6.25 6.25 6.25h87.5c3.516 0 6.25-2.734 6.25-6.25Zm-25-175V97c0-3.516-2.734-6.25-6.25-6.25h-37.5c-3.516 0-6.25 2.734-6.25 6.25v31.25c0 3.516 2.734 6.25 6.25 6.25h37.5c3.516 0 6.25-2.734 6.25-6.25Zm125 81.25c0 82.813-67.188 150-150 150-82.813 0-150-67.188-150-150 0-82.813 67.188-150 150-150 82.813 0 150 67.188 150 150Z"/>
</svg>

        </span>Info</p><p>回忆一下改进内核内存合并的主要策略有三种:</p>
<ul>
<li>重新组织线程到数据的映射。</li>
<li>重新组织数据本身。</li>
<li>以合并的方式在全局内存和共享内存之间传输数据，并在共享内存中执行不规则访问。</li>
</ul></div>
</p>
<p>下图展示了分段合并内核的块级别设计。A_S 和 B_S 可能无法覆盖块的整个输入子数组，因此在每次迭代期间，块中的所有线程将协作从块的 A 和 B 子数组中加载 x 个元素。这样每个块有足够的输入元素来生成至少 x 个输出数组元素 (<strong>在最坏的情况下，当前输出部分的所有元素可能都来自 A 或 B 的子数组</strong>)。假设每个块负责 y 个输出元素，则需要进行 y/x 次归并。每个块中的线程将在每次迭代中使用 A_S 的一部分和 B_S 的一部分 (深灰色部分)</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEB176c6f865fd366df31615935a842b2ab?method=download&amp;shareKey=bc8caa12fb14b0e5829a1fd57c3b8a14" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEB176c6f865fd366df31615935a842b2ab?method=download&amp;shareKey=bc8caa12fb14b0e5829a1fd57c3b8a14" alt="Design of a Tiled Merge Kernel">
    </a><figcaption>Design of a Tiled Merge Kernel</figcaption></figure></p>
<p>下面是分段合并内核的实现的第一部分。本质上是线程级基本合并内核的块级版本的代码。每个块的第一个线程负责计算当前块和下一个块的开始输出索引的位置以及他们的 co-rank. 结果被放入共享内存中，以便块中的所有线程都可以看到。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">__global__</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">merge_tiled_kernel</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">A</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">B</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">C</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tile_size</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="cm">/* Part 1: Identify block-level output &amp; input subarrays */</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Use extern keywords to determine 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// the shared memory size at runtime rather than compilation
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">extern</span> <span class="n">__shared__</span> <span class="kt">int</span> <span class="n">shared_AB</span><span class="p">[];</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span><span class="o">*</span> <span class="n">A_s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">shared_AB</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>  <span class="c1">// Start index of ShareA
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">int</span><span class="o">*</span> <span class="n">B_s</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">shared_AB</span><span class="p">[</span><span class="n">tile_size</span><span class="p">];</span>  <span class="c1">// Start index of ShareB
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">int</span> <span class="n">C_curr</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">ceil</span><span class="p">((</span><span class="n">m</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>  <span class="c1">// Start index of C for this block
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">int</span> <span class="n">C_next</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">C_curr</span> <span class="o">+</span> <span class="kt">int</span><span class="p">(</span><span class="n">ceil</span><span class="p">((</span><span class="n">m</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">)),</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span><span class="p">);</span>  <span class="c1">// End index of C for this block
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">A_s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">co_rank</span><span class="p">(</span><span class="n">C_curr</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>  <span class="c1">// Make block level co-rank values visible
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">A_s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">co_rank</span><span class="p">(</span><span class="n">C_next</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>  <span class="c1">// Next threads co-rank values in the block
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">__synctyhreads</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">A_curr</span> <span class="o">=</span> <span class="n">A_s</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">A_next</span> <span class="o">=</span> <span class="n">A_s</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">B_curr</span> <span class="o">=</span> <span class="n">C_curr</span> <span class="o">-</span> <span class="n">A_curr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">B_next</span> <span class="o">=</span> <span class="n">C_next</span> <span class="o">-</span> <span class="n">A_next</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>第二部分线程使用它们的 <code>threadIdx.x</code> 的值来确定要加载的元素，因此连续的线程加载连续的元素，内存访问是合并的。每次迭代从 A 和 B 数组中加载当前tile的起始点取决于块的所有线程在之前的迭代中消耗的 A 和 B 元素的总数。下图说明了 while 循环第二次迭代的索引计算。每个块在第一次迭代中消耗的 A 元素部分 为 A 子数组开头的白色小部分 (用竖条标记)。if 语句确保线程只加载 A 子数组剩余部分中的元素。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cm">/* Part 2: Loading A &amp; B elements into the shared memory */</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">lenC</span> <span class="o">=</span> <span class="n">C_next</span> <span class="o">-</span> <span class="n">C_curr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">lenA</span> <span class="o">=</span> <span class="n">A_next</span> <span class="o">-</span> <span class="n">A_curr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">lenB</span> <span class="o">=</span> <span class="n">B_next</span> <span class="o">-</span> <span class="n">B_curr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">num_iterations</span> <span class="o">=</span> <span class="n">ceil</span><span class="p">(</span><span class="n">lenC</span> <span class="o">/</span> <span class="n">tile_size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// index of completed merge in 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">int</span> <span class="n">C_completed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">A_completed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">B_completed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">while</span> <span class="p">(</span><span class="n">counter</span> <span class="o">&lt;</span> <span class="n">num_iterations</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// Each iter threads in a block will generate tile_size C elements
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// Loading tile_size A and B elements into shared memory
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tile_size</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// Coalecsing loading from global memory
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">lenA</span> <span class="o">-</span> <span class="n">A_completed</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="n">A_s</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">A_curr</span> <span class="o">+</span> <span class="n">A_completed</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">lenB</span> <span class="o">-</span> <span class="n">B_completed</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="n">B_s</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">B</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">B_curr</span> <span class="o">+</span> <span class="n">B_completed</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="n">__syncthreads</span><span class="p">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>第三部分则是每个块的线程对共享内存的数组进行归并。在更新索引的部分中最后一次迭代中 A_s 和 B_s 可能没有 tile_size 个元素，调用 co-rank 可能会得到错误结果。但是，由于 while 循环不会进一步迭代，因此不会使用结果，因此不会造成任何影响。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">		<span class="cm">/* Part 3: All threads merge their subarrays in prallel */</span>
</span></span><span class="line"><span class="cl">		<span class="kt">int</span> <span class="n">c_curr</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="n">tile_size</span> <span class="o">/</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>  <span class="c1">// Output index in shared memory
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="kt">int</span> <span class="n">c_next</span> <span class="o">=</span> <span class="n">c_curr</span> <span class="o">+</span> <span class="p">(</span><span class="n">tile_size</span> <span class="o">/</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="n">c_curr</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_curr</span> <span class="o">&lt;=</span> <span class="n">lenC</span> <span class="o">-</span> <span class="n">C_completed</span><span class="p">)</span> <span class="o">?</span> <span class="nl">c_curr</span> <span class="p">:</span> <span class="n">lenC</span> <span class="o">-</span> <span class="n">C_completed</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">c_next</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_next</span> <span class="o">&lt;=</span> <span class="n">lenC</span> <span class="o">-</span> <span class="n">C_completed</span><span class="p">)</span> <span class="o">?</span> <span class="nl">c_next</span> <span class="p">:</span> <span class="n">lenC</span> <span class="o">-</span> <span class="n">C_completed</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// find co-rank for c_curr and c_next
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="kt">int</span> <span class="n">a_curr</span> <span class="o">=</span> <span class="n">co_rank</span><span class="p">(</span><span class="n">c_curr</span><span class="p">,</span> <span class="n">A_s</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">tile_size</span><span class="p">,</span> <span class="n">lenA</span> <span class="o">-</span> <span class="n">A_completed</span><span class="p">),</span> 
</span></span><span class="line"><span class="cl">								<span class="n">B_s</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">tile_size</span><span class="p">,</span> <span class="n">lenB</span> <span class="o">-</span> <span class="n">B_completed</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">		<span class="kt">int</span> <span class="n">b_curr</span> <span class="o">=</span> <span class="n">c_curr</span> <span class="o">-</span> <span class="n">a_curr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="kt">int</span> <span class="n">a_next</span> <span class="o">=</span> <span class="n">co_rank</span><span class="p">(</span><span class="n">c_next</span><span class="p">,</span> <span class="n">A_s</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">tile_size</span><span class="p">,</span> <span class="n">lenA</span> <span class="o">-</span> <span class="n">A_completed</span><span class="p">),</span> 
</span></span><span class="line"><span class="cl">								<span class="n">B_s</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">tile_size</span><span class="p">,</span> <span class="n">lenB</span> <span class="o">-</span> <span class="n">B_completed</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">		<span class="kt">int</span> <span class="n">b_next</span> <span class="o">=</span> <span class="n">c_next</span> <span class="o">-</span> <span class="n">a_next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// merge the subarrays
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">merge_sequential</span><span class="p">(</span><span class="n">A_s</span> <span class="o">+</span> <span class="n">a_curr</span><span class="p">,</span> <span class="n">B_s</span> <span class="o">+</span> <span class="n">b_curr</span><span class="p">,</span> <span class="n">C</span> <span class="o">+</span> <span class="n">C_curr</span> <span class="o">+</span> <span class="n">C_completed</span> <span class="o">+</span> <span class="n">c_curr</span><span class="p">,</span> <span class="n">a_next</span> <span class="o">-</span> <span class="n">a_curr</span><span class="p">,</span> <span class="n">b_next</span> <span class="o">-</span> <span class="n">b_curr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Update completed indices
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">C_completed</span> <span class="o">+=</span> <span class="n">tile_size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">A_completed</span> <span class="o">+=</span> <span class="n">co_rank</span><span class="p">(</span><span class="n">tile_size</span><span class="p">,</span> <span class="n">A_s</span><span class="p">,</span> <span class="n">tile_size</span><span class="p">,</span> <span class="n">B_s</span><span class="p">,</span> <span class="n">tile_size</span><span class="p">);</span>  <span class="c1">// Idx of A_s to generate tile_size Idx of merged A_s and B_s
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">B_completed</span> <span class="o">+=</span> <span class="n">tile_size</span> <span class="o">-</span> <span class="n">A_completed</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="127-a-circular-buffer-merge-kernel">12.7 A Circular Buffer Merge Kernel</h2>
<p>上一节的内核不是那么高效因为下一次迭代 tile 的一部分已经被加载到共享内存中，但是我们每次迭代从全局内存中重新加载整个块，并覆盖掉前一次迭代中的这些元素。下图展示了 merge_circular_buffer_kernel 的主要思想，添加了两个额外的变量 A_S_start 和B_S_start，使得 while 循环的每次迭代动态确定从 A 和 B 的哪个位置开始加载，这样可以利用前一次迭代中剩余的 A_s 和 B_s 元素。修改后每个 for 循环都只加载 A_S_consumed 表示的填充 tile 所需的元素数量。因此，线程在第 i 次 for 循环迭代中加载的A 元素是 <code>A[A_curr+A_S_consumed+i+threadIdx.x]</code>. 取模(%) 操作检查索引值是否大于或等于 tile_size.</p>
<p>!A Circular Buffer Scheme for Managing the Shared Memory Tiles<a href="https://note.youdao.com/yws/api/personal/file/WEB5fab19bd6ec3f60e15cd82672ed06008?method=download&amp;shareKey=8ad20192216748affc4e2f15a1b01b8d" title="A Circular Buffer Scheme for Managing the Shared Memory Tiles"></a></p>
<h2 id="128-thread-coarsening-for-merge">12.8 Thread Coarsening for Merge</h2>
<p>多个线程并行执行归并的代价是每个线程必须执行自己的二进制搜索操作来识别其输出索引的 co-rank. 本章中介绍的所有内核都已经应用了线程粗化，因为它们都是为每个线程处理多个元素而设计的。在完全未粗化的内核中，每个线程将负责单个输出元素。</p>
]]></content:encoded>
    </item>
    <item>
      <title>PMPP Learning-Chapter 11 Prefix sum (scan)-An Introduction to Work Efficiency in Parallel Algorithms</title>
      <link>http://localhost:1313/blogs/courselearning/pmpp/pmpp-ch11/</link>
      <pubDate>Wed, 11 Sep 2024 23:03:03 +0800</pubDate>
      <guid>http://localhost:1313/blogs/courselearning/pmpp/pmpp-ch11/</guid>
      <description>Personal notebook 11 of Programming Massively Parallel</description>
      <content:encoded><![CDATA[<h1 id="11-prefix-sum-scan-an-introduction-to-work-efficiency-in-parallel-algorithms">11 Prefix sum (scan)-An Introduction to Work Efficiency in Parallel Algorithms</h1>
<p>一般来说，如果计算本质上可以被描述为数学递归，即序列中的每一项都是根据前一项定义的，那么它可能被并行化为并行扫描 (<em>parallel scan</em>) 运算。</p>
<h2 id="111-background">11.1 Background</h2>
<p>包含扫描 (<em>inclusive scan</em>) 操作接收一个二元可交换运算符 $\oplus$ 和一个包含 n 个元素的输入数组  $[x_0,x_1,\ldots,x_{n-1}]$，输出数组 $[x_0,(x_0\oplus x_1),\ldots,(x_0\oplus x_1\oplus\ldots\oplus x_{n-1})]$ . 包含扫描的名称体现在输出数组每个位置的结果都有对应输入元素参与。考虑包含扫描的一种直观方式是，接收一组所需香肠的长度的订单，并一次性得出所有所有订单对应的切割点。
排除扫描操作类似于包含扫描操作，只是输出数组的排列略有不同: $[i,x_0,(x_0\oplus x_1),\ldots,(x_0\oplus x_1\oplus\ldots\oplus x_{n-2})]$ . 每个输出元素的计算都与相应输入元素无关。
用包含扫描函数计算排除扫描的结果时，只需将所有元素向右移动，并为第 0 个元素填充恒等值。反之，只需要将所有元素向左移动，并用排除扫描结果的最后一个元素 $\oplus$ 最后一个输入元素来填充最后一个元素。</p>
<h2 id="112-parallel-scan-with-the-kogge-stone-algorithm">11.2 Parallel Scan with the Kogge-Stone Algorithm</h2>
<p>计算位置 i 的输出元素 需要进行 i 次加法运算，因此除非找到一种方法来共享不同输出元素的归约树的部分和，否则这种方法计算复杂度为 $O(N^2)$.
Kogge-Stone 算法最初是为了设计快速加法器电路而发明的，如下图所示，它是一种就地扫描算法，它对最初包含输入元素的数组 XY 进行操作。经过 k 次迭代后，<code>XY[i]</code> 将包含在该位置及之前的最多 <code>2^k</code> 个输入元素的和。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEBabaa1819ea6455c00659abbdd350e12e?method=download&amp;shareKey=804e364d2be685b4e8a02798a814eb2a" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEBabaa1819ea6455c00659abbdd350e12e?method=download&amp;shareKey=804e364d2be685b4e8a02798a814eb2a" alt="A Parallel Inclusive Scan Algorithm Based on Kogge-Stone Adder Design">
    </a><figcaption>A Parallel Inclusive Scan Algorithm Based on Kogge-Stone Adder Design</figcaption></figure></p>
<p>对应的内核函数如下，假设输入最初位于全局内存数组 X 中。让每个线程计算其全局数据索引，即其负责计算输出数组的位置。每个个活动线程首先将其位置的部分和存储到一个临时变量中(在寄存器中)。当步幅值大于 threadIdx.x 时，意味着线程分配的 XY 位置已经累加了所有所需的输入值，退出活动状态。需要额外的 <code>temp</code> 和 <code>__syncthreads()</code> 因为更新中存在读后写数据依赖竞争关系。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#define SECTION_SIZE 32
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="n">__global__</span> 
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">Kogge_Stone_Scan_Kernel</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">X</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">Y</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">N</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">__shared__</span> <span class="kt">float</span> <span class="n">XY</span><span class="p">[</span><span class="n">SECTION_SIZE</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="cm">/* Exclusive kernel initilization
</span></span></span><span class="line"><span class="cl"><span class="cm">	if (i &lt; N &amp;&amp; threadIdx.x != 0) {
</span></span></span><span class="line"><span class="cl"><span class="cm">		XY[threadIdx.x] = X[i];
</span></span></span><span class="line"><span class="cl"><span class="cm">	} else {
</span></span></span><span class="line"><span class="cl"><span class="cm">		XY[threadIdx.x] = 0.0f;
</span></span></span><span class="line"><span class="cl"><span class="cm">	}
</span></span></span><span class="line"><span class="cl"><span class="cm">	*/</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">XY</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">XY</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">stride</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">stride</span> <span class="o">&lt;</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">;</span> <span class="n">stride</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">__syncthreads</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">		<span class="kt">float</span> <span class="n">temp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="n">stride</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">temp</span> <span class="o">=</span> <span class="n">XY</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">+</span> <span class="n">XY</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">stride</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="n">__syncthreads</span><span class="p">();</span> <span class="c1">// write-after-read dependence
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="n">stride</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// Only N - stride threads are active
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="n">XY</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">XY</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Kogge-Stone 算法重用了横跨归约树的部分和来降低计算复杂度。在上一章的归约内核中，活动线程在迭代中写入的元素不会在同一迭代中被任何其他活动线程读取，因此不存在读后写竞争条件。如果希望避免在每次迭代中都有 barrier 同步，那么克服竞争条件的另一种方法是为输入和输出使用单独的数组。这种方法需要两个共享内存缓冲区。交替变化不能输入/输出缓冲区的角色，直到迭代完成。这种优化称为双缓冲 (<em>double buffering</em>).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#define SECTION_SIZE 32
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="n">__global__</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">DF_Kogge_Stone_Scan_Kernel</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">X</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">Y</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">N</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">__shared__</span> <span class="kt">float</span> <span class="n">XY_in</span><span class="p">[</span><span class="n">SECTION_SIZE</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="n">__shared__</span> <span class="kt">float</span> <span class="n">XY_out</span><span class="p">[</span><span class="n">SECTION_SIZE</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Initialization
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">XY_in</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">XY_in</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kt">bool</span> <span class="n">read_in</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>  <span class="c1">// Alternating ther role of XY_in and XY_out
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">stride</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">stride</span> <span class="o">&lt;</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">;</span> <span class="n">stride</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">read_in</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="n">stride</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="n">XY_out</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">XY_in</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">+</span> <span class="n">XY_in</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">stride</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="n">XY_out</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">XY_in</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="n">stride</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="n">XY_in</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">XY_out</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">+</span> <span class="n">XY_out</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">stride</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="n">XY_in</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">XY_out</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="n">read_in</span> <span class="o">=</span> <span class="o">!</span><span class="n">read_in</span><span class="p">;</span>  <span class="c1">// 切换数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 将结果写回全局内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">read_in</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">XY_in</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">XY_out</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="113-speed-and-work-efficiency-consideration">11.3 Speed and Work Efficiency Consideration</h2>
<p>算法的工作效率（<em>work efficiency</em>）是指算法所完成的工作接近于计算所需的最小工作量的程度。在每次迭代中，非活动线程的数量等于步长。因此我们可以计算出工作量为</p>
$$
\sum_{stride}(N-\mathrm{stride}), \text{for strides} 1, 2, 4, \ldots N/2(\mathrm{log}_2N \text{terms}) = N\log_2N - (N-1)
$$<p>因此，Kogge-Stone 算法的计算复杂度为 $O(N\log_2N)$.</p>
<p>使用计算步数 (compute steps) 的概念作为比较扫描算法的近似指标。顺序扫描用 N-1 步来处理 N 个输入元素；若 CUDA 设备有 P 个执行单元，Kogge-Stone 内核执行需要步数为 $O(N\log_2N)/P$. Kogge-Stone 内核相比串行代码所做的额外工作有两个问题。首先，使用硬件执行并行内核的效率要低得多。第二，所有额外的工作消耗额外的能量，不利于移动应用等场景。Kogge-Stone 内核的强大之处在于，当有足够的硬件资源时，它可以达到非常好的执行速度。</p>
<h2 id="114-parallel-scan-with-the-brent-kung-algorithm">11.4 Parallel Scan with the Brent-Kung Algorithm</h2>
<p>对一组值进行求和最快的方法是使用归约树，如果有足够的执行单元，就可以在 $O(N\log_2N)$  时间内计算 N 个值的求和结果。该树还可以生成几个子序列的和，它们可用于计算某些扫描输出值。
下图展示了基于 Brent-Kung 加法器设计的并行包含扫描算法的步骤。图中上半部分，花 4 步计算所有 16 个元素的和。下半部分是使用反向树将部分和分配到可以使用部分和的位置，以计算这些位置的结果。约简树中的求和总是在对一个连续的范围内的输入元素进行。因此，求和累积到 XY 的每个位置的值总是可以表示为输入元素的一个 xi…xj 的范围，其中 xi 是开始位置， xj 是结束位置 (包括)。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEBda8f1aa90d4fcd75e9b2a976aec9f4c3?method=download&amp;shareKey=3887f9dfcd0ffaacbd1a9ce6a0554d38" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEBda8f1aa90d4fcd75e9b2a976aec9f4c3?method=download&amp;shareKey=3887f9dfcd0ffaacbd1a9ce6a0554d38" alt="A Parallel Inclusive Scan Algorithm Based on the Brent–Kung Adder Design">
    </a><figcaption>A Parallel Inclusive Scan Algorithm Based on the Brent–Kung Adder Design</figcaption></figure></p>
<p>下图展示了反向树中每个位置 (列) 的状态，包括已经累积到该位置的值以及在反向树的每级 (行) 上需要的额外输入元素值 (浅灰色表示 2，深灰色表示 1，黑色表示 0).</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEBff0a3e454e8d276a662e5c76b155939b?method=download&amp;shareKey=70741f95168876e0d97cae8bd475d933" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEBff0a3e454e8d276a662e5c76b155939b?method=download&amp;shareKey=70741f95168876e0d97cae8bd475d933" alt="Progression of Values in XY After Each Level of Additions in the Reverse Tree.">
    </a><figcaption>Progression of Values in XY After Each Level of Additions in the Reverse Tree.</figcaption></figure></p>
<p>上半部分归约树的内核代码如下，和第十章不同的是</p>
<ol>
<li>我们把求和结果写到最大索引的位置。</li>
<li>我们将线程索引组织成 $2^n-1$ 的形式 (n 为树的高度)。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">stride</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">stride</span> <span class="o">&lt;</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">;</span> <span class="n">stride</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">__syncthreads</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">((</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">stride</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">XY</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">+=</span> <span class="n">XY</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">stride</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这种归约方式的一个缺点是存在控制发散问题。因此需要将线程的连续部分映射到索引为 $k*2^n-1$ 形式的 XY 位置。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// Mapping a continous section of threads to the XY positions
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">stride</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">stride</span> <span class="o">&lt;=</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">;</span> <span class="n">stride</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">__syncthreads</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">stride</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// index of the left child
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">SECTION_SIZE</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">XY</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">+=</span> <span class="n">XY</span><span class="p">[</span><span class="n">index</span> <span class="o">-</span> <span class="n">stride</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>反向树的实现要复杂一些。步长从 <code>SECTION_SIZE/4</code> 减小到 1. 在每次迭代中，我们需要将 XY 元素索引值从步长减去 1 后的两倍的位置向右推到距离其一个步长的位置。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// Reverse tree stride value decreases from SECTION_SIZE / 4 to 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">stride</span> <span class="o">=</span> <span class="n">SECTION_SIZE</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span> <span class="n">stride</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">stride</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">__syncthreads</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">stride</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// index of the left child
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="n">stride</span> <span class="o">&lt;</span> <span class="n">SECTION_SIZE</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">XY</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="n">stride</span><span class="p">]</span> <span class="o">+=</span> <span class="n">XY</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们可以看到 Brent-Kung 算法无论在归约阶段还是分发阶段，都不需要超过 <code>SECTION_SIZE/2</code> 的线程。并行扫描中的运算总数，包括归约树 (N-1 次) 和反向树 ( $N-1-log_2N$ 次) 阶段，总共 $2N-2-log_2N$ 次。当输入长度变大时，Brent-Kung 算法执行的操作数量永远不会超过顺序算法执行的操作数量的 2 倍。</p>
<p>Brent-Kung 算法的活动线程的数量通过归约树比 Kogge-Stone 算法下降得快得多。然而，一些非活动线程可能仍然会消耗 CUDA 设备中的执行资源，因为它们通过 SIMD 绑定到其他活动线程。这使得在 CUDA 设备上前者工作效率上的优势不那么明显。在有充足执行资源的情况下，由于需要额外的步骤来执行反向树阶段，Brent-Kung 的时间是 Kogge-Stone 的两倍。</p>
<h2 id="115-coarsening-for-even-more-work-efficiency">11.5 Coarsening for Even More Work Efficiency</h2>
<p>如下图所示，粗化扫描分为三个阶段。在第一阶段，我们让每个线程对其相邻的子线程执行串行扫描。需要注意如果每个线程通过访问全局内存的输入直接执行扫描，则它们的访问不会合并。所以我们以合并的方式在共享内存和全局内存之间传输数据，并在共享内存中执行不是那么好的内存访问模式。在第二阶段，每个块中的所有线程协作并对由每个部分的最后一个元素组成的逻辑数组执行扫描操作。在第三阶段，每个线程将其前一个部分的最后一个元素的新值与自身部分除最后一个的所有元素相加。对应的内核代码如下。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEB169e018f54e6c49c493de068d8a5f3f6?method=download&amp;shareKey=a54b5ab82631a6c403d2709f702f48c0" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEB169e018f54e6c49c493de068d8a5f3f6?method=download&amp;shareKey=a54b5ab82631a6c403d2709f702f48c0" alt="A Three-phase Parallel Scan for Higher Work Efficiency">
    </a><figcaption>A Three-phase Parallel Scan for Higher Work Efficiency</figcaption></figure></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#define CORASE_FACTOR 4
</span></span></span><span class="line"><span class="cl"><span class="cp">#define SUBSECTION_SIZE (SECTION_SIZE / CORASE_FACTOR)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="n">__global__</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">Corasened_Scan_Kernel</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">X</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">Y</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">N</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// Partition X into blockDim.x subsections
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Load X into shared memory in coalesced fashion
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">__shared__</span> <span class="kt">float</span> <span class="n">XY</span><span class="p">[</span><span class="n">SECTION_SIZE</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="n">__shared__</span> <span class="kt">float</span> <span class="n">subXY</span><span class="p">[</span><span class="n">SUBSECTION_SIZE</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SECTION_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">+=</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">XY</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">__syncthreads</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Part 1: Compute prefix sum of each subsection in sequenial 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SUBSECTION_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">XY</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">SUBSECTION_SIZE</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">XY</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">SUBSECTION_SIZE</span> <span class="o">+</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">__syncthreads</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Part 2: Compute prefix sum of the last element of each subsection in parallel
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lastElemId</span> <span class="o">=</span> <span class="p">(</span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">CORASE_FACTOR</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">subXY</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">XY</span><span class="p">[(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">SUBSECTION_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="kt">float</span> <span class="n">temp</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">stride</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">stride</span> <span class="o">&lt;</span> <span class="n">SUBSECTION_SIZE</span><span class="p">;</span> <span class="n">stride</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">__syncthreads</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="n">stride</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">temp</span> <span class="o">=</span> <span class="n">subXY</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">+</span> <span class="n">subXY</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">stride</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="n">__syncthreads</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="n">stride</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">subXY</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">__syncthreads</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Part 3: Add the reduction sum of the previous subsection to the current subsection (except the last element)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SUBSECTION_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">XY</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">SUBSECTION_SIZE</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">subXY</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">__syncthreads</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Store back to Y
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SECTION_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">+=</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">Y</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">XY</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="116-segmented-parallel-scan-for-arbitrary-length-inputs">11.6 Segmented Parallel Scan for Arbitrary-length Inputs</h2>
<p>对于长度很大的输入数据，我们首先将其划分为多个部分，以便每个部分都可以放入流多处理器的共享内存中，并由单个块进行处理。如下图所示，第一步在每个块内部先进行扫描，完成后每个扫描块的最后一个输出元素为该扫描块的所有输入元素的和。第二步将每个扫描块的最后一个结果元素收集到一个数组中，并对这些输出元素执行扫描。第三步将第二步扫描输出值与其对应扫描块的值相加。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEB22da8ba64a41795b1047cae1caf6f6d3?method=download&amp;shareKey=99c2a7dcbbdeaf1be80feb644be643c0" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEB22da8ba64a41795b1047cae1caf6f6d3?method=download&amp;shareKey=99c2a7dcbbdeaf1be80feb644be643c0" alt="A Hierarchical Scan for Arbitrary Length Inputs">
    </a><figcaption>A Hierarchical Scan for Arbitrary Length Inputs</figcaption></figure></p>
<p>我们可以用三个内核实现分段扫描。第一个内核与 11.5 节的内核基本相同，第二个内核只是单个线程块的并行扫描内核，第三个内核将 S 数组和 Y 数组作为输入，并将其输出写回 Y.</p>
<h2 id="117-single-pass-scan-for-memory-access-efficiency">11.7 Single-pass Scan for Memory Access Efficiency</h2>
]]></content:encoded>
    </item>
    <item>
      <title>PMPP Learning-Chapter 10 Reduction and Minimizing Divergence</title>
      <link>http://localhost:1313/blogs/courselearning/pmpp/pmpp-ch10/</link>
      <pubDate>Tue, 10 Sep 2024 21:07:12 +0800</pubDate>
      <guid>http://localhost:1313/blogs/courselearning/pmpp/pmpp-ch10/</guid>
      <description>Personal notebook 10 of Programming Massively Parallel</description>
      <content:encoded><![CDATA[<h1 id="10-reduction-and-minimizing-divergence">10 Reduction and Minimizing Divergence</h1>
<p>归约 (<em>Reduction</em>) 是从输入数组计算出一个数的运算。</p>
<h2 id="101-background">10.1 Background</h2>
<p>归约是从输入数组计算出一个数的运算，通常是通过对数组中的元素进行某种二元运算来实现的。如果二元操作符具有定义良好的恒等值 (例如加法中的 0，乘法中的 1)，则可以为基于该操作符进行运算的一个数组中的值定义归约操作。可以通过顺序遍历数组的每个元素来进行归约。下面伪代码为运算符的一般归约形式，它被定义为接受两个输入并返回一个值的函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">acc</span> <span class="o">=</span> <span class="n">IDENTITY</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">acc</span> <span class="o">=</span> <span class="n">Operator</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span> <span class="n">input</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="102-reduction-trees">10.2 Reduction Trees</h2>
<p>并行归约的基本思想如下图所示，时间竖直向下增加，水平方向为线程在每个时间点并行执行的活动。并行约简假定输出不随着输入值进行运算的顺序而改变 (即具有交换律)。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEB3cdc79f24938b60e8ec694cf1efa2314?method=download&amp;shareKey=81f05475b6bb20cc0a5a2f767e1c4d51" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEB3cdc79f24938b60e8ec694cf1efa2314?method=download&amp;shareKey=81f05475b6bb20cc0a5a2f767e1c4d51" alt="A Parallel Max Reduction Tree">
    </a><figcaption>A Parallel Max Reduction Tree</figcaption></figure></p>
<p>上图中的并行归约模式被称为归约树 (<em>reduction tree</em>)，因为它看起来像一棵叶子是原始输入元素，根是最终结果的树。归约树的边是无实际意义，只是反映了从一个时间步执行的操作到下一个时间步执行的操作的信息流。执行的操作总数是一个几何级数 $\frac{1}{2}N + \frac{1}{2^2}N + \cdots + \frac{1}{N}N = N-1$. 归约树需要 $log_{2}{N}$ 步骤来完成。完成计算所需的资源数量随着时间步的增加而迅速减少，每个时间步的并行度与所需的执行单元数量相同。并行度和资源消耗随着时间步长的剧烈变化让归约树成为一种具有挑战性的并行模式。</p>
<h2 id="103-a-simple-reduction-kernel">10.3 A Simple Reduction Kernel</h2>
<p>从实现一个<strong>在单个线程块内</strong>执行求和归约树的内核开始。其并行执行的情况如下图所示，假设输入数组位于全局内存中，并且在调用内核函数时将其指针作为输入参数传入。每个线程被分配到索引<code>2*threadIdx.x</code> 处，每一步归约的结果也会被写入此处。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEB1a32016b07d2b257c2c1aa0bdd008b25?method=download&amp;shareKey=618b57308d448ccbd4dcb5e12b391ac0" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEB1a32016b07d2b257c2c1aa0bdd008b25?method=download&amp;shareKey=618b57308d448ccbd4dcb5e12b391ac0" alt="Threads Arrangment of the Input Array in the Simple Kernel">
    </a><figcaption>Threads Arrangment of the Input Array in the Simple Kernel</figcaption></figure></p>
<p>对应的内核代码如下所示，for 循环中的 __syncthreads() 确保任何一个线程开始下一次迭代之前，所有线程都已经完成了上一次迭代的计算。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">__global__</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">SimpleReductionKernel</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span> <span class="n">input</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">output</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// launch single block with  1/2 #elements threads
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">stride</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">stride</span> <span class="o">=</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">;</span> <span class="n">stride</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">input</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">input</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">stride</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="n">__syncthreads</span><span class="p">();</span>  <span class="c1">// Ensure partial sums have been written to the destinition.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="o">*</span><span class="n">output</span> <span class="o">=</span> <span class="n">input</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="104-minimizing-control-divergence">10.4 Minimizing Control Divergence</h2>
<p>上面代码在每次迭代中对活动和非活动线程的管理导致了控制发散。只有那些线程的 <code>threadIdx.x</code> 为偶数的线程在第二次迭代中执行加法操作。由于控制发散造成的执行资源浪费随着迭代次数的增加而增加，第二次迭代中每个 warp 只有一半的线程执行加法操作，但消耗的计算资源却是相同的。如果输入数组的大小大于32，整个 warp 将在第五次迭代后不再执行加法操作。消耗的执行资源的总数与所有迭代中活动 warp 的总数成正比，计算方式如下。</p>
$$\text{active warps} = (5+\frac{1}{2}+\frac{1}{4}+\cdots+1)*\frac{N}{64}*32$$<p>其中 N/64 代表启动的 warp 总数。每个 warp 在前五次迭代中都处于活动状态，之后每次迭代都只有上次一半的线程在活动状态，直到只剩最后一个。
每次迭代中活动线程计算出的结果个数等于活动线程的总数</p>
$$\text{active threads} = \frac{N}{64}*(32+16+8+4+2+1)+\frac{N}{64}*\frac{1}{2}*1+\frac{N}{64}*\frac{1}{4}*1+\cdots+1$$<p>每个 warp 在前五次迭代中处于活动状态的线程数减半，之后每次迭代中每个处于活动状态的 warp 只有一个线程处于活动状态。这个结果应该非常直观的，因为其正等于完成归约所需的操作总数。
由此我们可以得出当输入大小为 256 时，执行资源利用率为 255/736 = 0.35. 如下图所示，为了减少控制分散应该安排线程和它们计算的位置使得能够随着时间的推移而彼此靠近。也就是说，我们希望步幅随着时间的推移而减少，而不是增加。修改后的内核函数如下，每次迭代中执行加法操作的线程数是相同的，但直到同时进行加法的线程数小于 32 之前，一个 warp 的线程数所走的分支相同。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEB284d0ca9febf8b2fdd3644aee218b475?method=download&amp;shareKey=a97e91212ca491a84532186a3398b9a4" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEB284d0ca9febf8b2fdd3644aee218b475?method=download&amp;shareKey=a97e91212ca491a84532186a3398b9a4" alt="Arrangement with Less Control Divergence">
    </a><figcaption>Arrangement with Less Control Divergence</figcaption></figure></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">__global__</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">ConvergentSumReductionKernel</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span> <span class="n">input</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">output</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">stride</span> <span class="o">=</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">;</span> <span class="n">stride</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">stride</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// Decrease stride to reduce control divergence
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">stride</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">input</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">input</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">stride</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="n">__syncthreads</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="o">*</span><span class="n">output</span> <span class="o">=</span> <span class="n">input</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这种情况下的进行规约操作消耗的计算资源总数为
</p>
$$(\frac{N}{64}*1 + \frac{N}{64}*\frac{1}{2}*1 + \frac{N}{64}*\frac{1}{4}*1 + \cdots + 1 + 5*1) * 32 $$<p>
5*1 代表最后的五次迭代，只有一个活动的warp，并且它的所有32个线程都消耗执行资源，即使只有一小部分线程是活动状态。执行资源的利用率为 255/384 = 0.66.</p>
<h2 id="105-minimizing-memory-divergence">10.5 Minimizing Memory Divergence</h2>
<p>上面的内核还有内存分散的问题。在每次迭代中，每个线程对全局内存执行 2 次读取和 1 次写入。第一次从自己的位置读取，第二次从离自己 stride 的位置读取，相加后写入到自己的位置。
<a href="/blogs/courselearning/pmpp/pmpp-ch10/#10-3-A-Simple-Reduction-Kernel">10.3</a> 节的内核代码中，第一次迭代每个 warp 中的相邻线程间隔 2 个元素，因此要访问 2 个内存位置，此后每次迭代 stride 都增加，直到第六次迭代时，每个 warp 都只有一个线程处于活动状态，只用访问 1 个位置。因此进行内存访问的总次数为
</p>
$$(5*\frac{N}{64}*2+\frac{N}{64}*1+\frac{N}{64}*\frac{1}{2}*1+\cdots+1)*3$$<p>
<a href="/blogs/courselearning/pmpp/pmpp-ch10/#10-4-Minimizing-Control-Divergence">10.4</a> 节的内核代码中，每个 warp 在任何读或写时只进行一个全局内存请求，直到该 warp 中的所有线程都处于非活动状态。最后五次迭代的线程都位于一个 warp 中，因此进行内存访问的总次数为
</p>
$$((\frac{N}{64}*1+\frac{N}{64}*\frac{1}{2}*1+\frac{N}{64}*\frac{1}{4}*1+\cdots+1)+5)*3$$<p>
对于长度为 2048 的输入，前者和后者全局内存请求的总数分别为 1149 和 204. 后者在使用 DRAM 带宽方面也具有更高的效率。</p>
<h2 id="106-minimizing-global-memory-accesses">10.6 Minimizing Global Memory Accesses</h2>
<p>通过使用共享内存，可以进一步改进 <a href="/blogs/courselearning/pmpp/pmpp-ch10/#10-4-Minimizing-Control-Divergence">10.4</a> 节的内核。在每次迭代中，线程将它们的部分和结果值写入全局内存，这些值在下一次迭代中由相同的线程和其他线程重新读取。如下图所示，通过将部分和结果保存在共享内存中，可以进一步提高执行速度。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEB73d407923a5daa0e9e69860be0089c98?method=download&amp;shareKey=b6e4d5ed19de5a3712f1ed1eed127674" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEB73d407923a5daa0e9e69860be0089c98?method=download&amp;shareKey=b6e4d5ed19de5a3712f1ed1eed127674" alt="Use Shared Memory to Reduce Accesses from the Global Memory">
    </a><figcaption>Use Shared Memory to Reduce Accesses from the Global Memory</figcaption></figure>
对应的代码如下，每个线程从全局内存加载并 2 个输入元素并将部分和写入共享内存。剩下的所有迭代中的计算都在共享内存中进行。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#define BLOCK_DIM 512
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="n">__global__</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">SharedMemoryReductionKernel</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span> <span class="n">input</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">__shared__</span> <span class="kt">float</span> <span class="n">input_s</span><span class="p">[</span><span class="n">BLOCK_DIM</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">input_s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">input</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">input</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">];</span>  <span class="c1">// Partial sum of first iteration
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">stride</span> <span class="o">=</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">stride</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">stride</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">__syncthreads</span><span class="p">();</span>  <span class="c1">// Ensure all partial sums have been written to shared memory
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">stride</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">input_s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">input_s</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">stride</span><span class="p">];</span>  <span class="c1">// Partial sum of subsequent iterations
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">input</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">input_s</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>  <span class="c1">// Write final sum to output
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>全局内存访问的次数减少到初始加载输入数组和最终写入 <code>input[0]</code>，总共只有 (N/32) + 1 个全局内存请求。</p>
<h2 id="107-hierarchical-reduction-for-arbitrary-input-length">10.7 Hierarchical Reduction for Arbitrary Input Length</h2>
<p>由于 <code>__syncthreads()</code> 只对同一块中的线程有效，因此无法在不同块之间同步。下图展示了如何使用分级归约来解决这个问题，其思想是将输入数组划分为多个适合于线程块大小的段。然后，所有块都独立地执行归约树，并使用原子加法操作将它们的结果累积到最终输出。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEB857e94f9f4cbf28c1f9a7980fdd83536?method=download&amp;shareKey=29a4f000e0073fa0ae1ee6e4b8e08852" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEB857e94f9f4cbf28c1f9a7980fdd83536?method=download&amp;shareKey=29a4f000e0073fa0ae1ee6e4b8e08852" alt="Segmented Multiblock Reduction Using Atomic Operations">
    </a><figcaption>Segmented Multiblock Reduction Using Atomic Operations</figcaption></figure>
对应的内核代码如下。每个线程块处理 <code>2*blockDim.x</code> 个元素。在每个线程块内，我们通过线程所属块的段起始位置加上 <code>threadIdx.x</code> 为每个线程分配其输入元素的位置。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">__global__</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">SegmentedSumReductionKernel</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span> <span class="n">input</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">output</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">__shared__</span> <span class="kt">float</span> <span class="n">input_s</span><span class="p">[</span><span class="n">BLOCK_DIM</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">segment</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>  <span class="c1">// Each block processes 2*blockDim.x elements
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">segment</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">input_s</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">input</span><span class="p">[</span><span class="n">t</span> <span class="o">+</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">];</span>  <span class="c1">// Partial sum of first iteration of each block
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">stride</span> <span class="o">=</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">stride</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">stride</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">__syncthreads</span><span class="p">();</span>  <span class="c1">// Ensure all partial sums have been written to shared memory
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="n">stride</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">input_s</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">+=</span> <span class="n">input_s</span><span class="p">[</span><span class="n">t</span> <span class="o">+</span> <span class="n">stride</span><span class="p">];</span>  <span class="c1">// Partial sum of subsequent iterations
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">atomicAdd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">output</span><span class="p">,</span> <span class="n">input_s</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>  <span class="c1">// Write final sum to output
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="108-thread-coarsening-for-reduced-overhead">10.8 Thread Coarsening for Reduced Overhead</h2>
<p>到目前为止，我们使用过的归约内核都试图通过使用尽可能多的线程来最大化并行性。若线程块大小为 1024 个线程，则需要启动的线程块数量为 N/2048.
下图展示了如何将线程粗化。线程独立地添加它们负责的四个元素，它们不需要同步，直到将所有的四个元素相加之后才能将部分和结果写入共享内存。剩下的步骤与 10.7 节后续相同。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEB4358648a96bbd27f045c7beb2f736e73?method=download&amp;shareKey=770c7cecefe849a2acfe2353f538504a" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEB4358648a96bbd27f045c7beb2f736e73?method=download&amp;shareKey=770c7cecefe849a2acfe2353f538504a" alt="Thread Coarsening in Reduction">
    </a><figcaption>Thread Coarsening in Reduction</figcaption></figure>
对应的内核如下，我们乘以 <code>COARSE_FACTOR</code> 来表示每个线程块的负责的段的大小是原来的 <code>COARSE_FACTOR</code> 倍。部分和累加到局部变量 <code>sum</code> 中，并且因为线程是独立运行的，在循环中不会调用 <code>__syncthreads()</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#define COARSE_FACTOR 2
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="n">__global__</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">CoarsenedSumReductionKernel</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span> <span class="n">input</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">output</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">__shared__</span> <span class="kt">float</span> <span class="n">input_s</span><span class="p">[</span><span class="n">BLOCK_DIM</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">segment</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">COARSE_FACTOR</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">segment</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">float</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">input</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">tile</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="n">tile</span> <span class="o">&lt;</span> <span class="n">COARSE_FACTOR</span><span class="p">;</span> <span class="n">tile</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// Partitial sum is accumulated independently
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">sum</span> <span class="o">+=</span> <span class="n">input</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">tile</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">input_s</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">stride</span> <span class="o">=</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">stride</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">stride</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">__syncthreads</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="n">stride</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">input_s</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">+=</span> <span class="n">input_s</span><span class="p">[</span><span class="n">t</span> <span class="o">+</span> <span class="n">stride</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">atomicAdd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">output</span><span class="p">,</span> <span class="n">input_s</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>下图比较了两个原始线程块在没有进行线程粗化下被硬件顺序执行情况，图 A 当第一个线程块完成后，硬件调度第二个线程块，在不同的数据段上执行相同的步骤。图 B 的这个线程块开始需要三个步骤，其中每个线程对它负责的四个元素求和。剩下的三个步骤执行归约树，每个步骤中有一半的线程退出活动状态。相比图 A，图 B 只需要6个步骤 (而不是 8 个)，其中 3 个步骤 (而不是 2 个) 充分利用了硬件。
当我们粗化线程时，并行完成的工作就会减少。因此，增加粗化因子将减少硬件正在利用的数据并行性的数量。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEBa50e84d0dc2bb278fdf643ea81cfd694?method=download&amp;shareKey=c8899f1ad2ad8059daf269e68a9dac2c" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEBa50e84d0dc2bb278fdf643ea81cfd694?method=download&amp;shareKey=c8899f1ad2ad8059daf269e68a9dac2c" alt="Comparing Parallel Reduction with and without Thread Coarsening">
    </a><figcaption>Comparing Parallel Reduction with and without Thread Coarsening</figcaption></figure></p>
]]></content:encoded>
    </item>
    <item>
      <title>PMPP Learning-Chapter 8 Stencil</title>
      <link>http://localhost:1313/blogs/courselearning/pmpp/pmpp-ch8/</link>
      <pubDate>Mon, 09 Sep 2024 10:27:42 +0800</pubDate>
      <guid>http://localhost:1313/blogs/courselearning/pmpp/pmpp-ch8/</guid>
      <description>Personal notebook 8 of Programming Massively Parallel Processors.</description>
      <content:encoded><![CDATA[<h1 id="8-stencil">8 Stencil</h1>
<p>在流体动力学、热传导、燃烧、天气预报、气候模拟和电磁学等应用领域，模板是求解偏微分方程的数值方法的基础。模板方法的基本思想是，将偏微分方程的求解转化为求解一个局部的线性方程组，然后在该局部进行迭代求解，最后得到全局解。由于求解微分问题时对数值精度的要求，模板处理的数据往往是高精度的浮动数据，对于 tiling 技术来说，这需要消耗更多的片上内存。</p>
<h2 id="backgroud">Backgroud</h2>
<p>用计算机数值计算和求解函数、模型、变量和方程的第一步是将它们转换成离散的表示形式。表示的保真度或这些近似插值技术的函数值的准确性取一方面决于网格点之间的间距:间距越小，近似越准确。离散表示的保真度还取决于所使用数字的精度。本章中将重点关注计算模式，其中模板应用于所有相关的输入网格点以生成所有网格点的输出值，这将被称为模板扫描 (<em>stencil sweep</em>).</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEB148a72c6a7b7556806a321b46ad917b7?method=download&amp;shareKey=72f1615fc5c62f3e23a68a3a7738feac" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEB148a72c6a7b7556806a321b46ad917b7?method=download&amp;shareKey=72f1615fc5c62f3e23a68a3a7738feac" alt="One-dimensional Stencil Example">
    </a><figcaption>One-dimensional Stencil Example</figcaption></figure></p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEB71159c58a69685bed08948350c22dfcf?method=download&amp;shareKey=20517947036fd220df2744f0d4fbad08" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEB71159c58a69685bed08948350c22dfcf?method=download&amp;shareKey=20517947036fd220df2744f0d4fbad08" alt="Two-dimensional &amp; Three-dimensional Stencil Example">
    </a><figcaption>Two-dimensional &amp; Three-dimensional Stencil Example</figcaption></figure></p>
<h2 id="82-parallel-stencil-a-basic-algorithm">8.2 Parallel stencil: A Basic Algorithm</h2>
<p>2D 情况下输出网格的 tiling 如下图所示，其中每个线程块负责一个 <code>4*4</code> 大小的输出 tile. 一个基本的 3D stencil 内核函数如下，其中每个线程块负责计算一个输出 tile 的值，每个线程用于计算一个元素。每个线程执行13次浮点操作 (7 次乘法和 6 次加法)，并加载 7 个输入元素 (每个 4 字节)。因此，这个内核的浮点对计算访存比是 13 / (7*4) = 0.46 OP/B.</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEBb784ac30b171fdcf2a3ec27e6b4351dd?method=download&amp;shareKey=518a1c8267ed726cce9d05ebbe087bce" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEBb784ac30b171fdcf2a3ec27e6b4351dd?method=download&amp;shareKey=518a1c8267ed726cce9d05ebbe087bce" alt="2D 5-point Stencil Tiling for Output Grid">
    </a><figcaption>2D 5-point Stencil Tiling for Output Grid</figcaption></figure></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">__global__</span> 
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">stencil_kernel</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span> <span class="n">in</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">out</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">N</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">z</span><span class="o">*</span><span class="n">blockDim</span><span class="p">.</span><span class="n">z</span><span class="o">+</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">y</span><span class="o">*</span><span class="n">blockDim</span><span class="p">.</span><span class="n">y</span><span class="o">+</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="o">*</span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="o">+</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">out</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">N</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">c0</span> <span class="o">*</span> <span class="n">in</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">N</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="n">k</span><span class="p">]</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">                                    <span class="n">c1</span> <span class="o">*</span> <span class="n">in</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">N</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">c2</span> <span class="o">*</span> <span class="n">in</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">N</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">                                    <span class="n">c3</span> <span class="o">*</span> <span class="n">in</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">N</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">c4</span> <span class="o">*</span> <span class="n">in</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">N</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="n">k</span><span class="p">]</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">                                    <span class="n">c5</span> <span class="o">*</span> <span class="n">in</span><span class="p">[(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">N</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">c6</span> <span class="o">*</span> <span class="n">in</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">N</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="n">k</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="83-shared-memory-tiling-for-stencil-sweep">8.3 Shared Memory Tiling for Stencil Sweep</h2>
<p>下图展示了二维五点模板的输入和输出 tile，可以发现五点模板的输入 tile 不包括四个角落的元素。因为每个输出网格点值只使用输入 tile 的 5 个元素，而 <code>3*3</code> 卷积使用 9 个元素。而 3D 情况下七点模板相对于 <code>3*3*3</code> 卷积从将输入网格点加载到共享内存中能获得的收益更低。由于为卷积加载输入 tile 的所有策略都直接应用于模板扫描，下面给出了一个加载到共享内存版本的内核函数，线程块的大小与输入 tile 相同，在计算输出 tile 点值时没有使用部分线程。每个表达式中减去的值1是因为内核假设一个3D七点模板，每边有一个网格点</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEB248ae00a16c8ed3da3dc8832ced6ebc0?method=download&amp;shareKey=40a18c41ed91dacafbde0c5beac0aaf6" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEB248ae00a16c8ed3da3dc8832ced6ebc0?method=download&amp;shareKey=40a18c41ed91dacafbde0c5beac0aaf6" alt="Input and Output Tiles for a 2D 5-point Stencil">
    </a><figcaption>Input and Output Tiles for a 2D 5-point Stencil</figcaption></figure></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#define IN_TILE_DIM 16
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="n">__global__</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">stencil_shared_mem_tiling_kernel</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span> <span class="n">in</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">out</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">N</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// upper left corner of input tile
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">z</span><span class="o">*</span><span class="n">blockDim</span><span class="p">.</span><span class="n">z</span><span class="o">+</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">z</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">y</span><span class="o">*</span><span class="n">blockDim</span><span class="p">.</span><span class="n">y</span><span class="o">+</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="o">*</span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="o">+</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">__shared__</span> <span class="kt">float</span> <span class="n">in_s</span><span class="p">[</span><span class="n">IN_TILE_DIM</span><span class="p">][</span><span class="n">IN_TILE_DIM</span><span class="p">][</span><span class="n">IN_TILE_DIM</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">IN_TILE_DIM</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">IN_TILE_DIM</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">IN_TILE_DIM</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">in_s</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">z</span><span class="p">][</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">][</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">in</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">N</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="n">k</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">__syncthreads</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">&gt;=</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">IN_TILE_DIM</span><span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> 
</span></span><span class="line"><span class="cl">            <span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">&gt;=</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">IN_TILE_DIM</span><span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> 
</span></span><span class="line"><span class="cl">            <span class="n">threadIdx</span><span class="p">.</span><span class="n">z</span> <span class="o">&gt;=</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">z</span> <span class="o">&lt;</span> <span class="n">IN_TILE_DIM</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 7 point template
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="n">out</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">N</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">c0</span> <span class="o">*</span> <span class="n">in_s</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">z</span><span class="p">][</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">][</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">                                    <span class="n">c1</span> <span class="o">*</span> <span class="n">in_s</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">z</span><span class="p">][</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">][</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">c2</span> <span class="o">*</span> <span class="n">in_s</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">z</span><span class="p">][</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">][</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">                                    <span class="n">c3</span> <span class="o">*</span> <span class="n">in_s</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">z</span><span class="p">][</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">+</span> <span class="n">c4</span> <span class="o">*</span> <span class="n">in_s</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">z</span><span class="p">][</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">                                    <span class="n">c5</span> <span class="o">*</span> <span class="n">in_s</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">z</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">][</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">+</span> <span class="n">c6</span> <span class="o">*</span> <span class="n">in_s</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">z</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">][</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>硬件限制每个块最大为 1024 ，因此 tile 通常比较小。一般 tile 的边长为8，每个块的大小为 512 个线程。相反，卷积通常用于处理二维图像，可以使用更大的 tile 尺寸 (32x32).
第一个缺点是由于 halo cell 的开销，重用率随着 tile 大小的降低而降低。第二个缺点是它对内存合并有不利影响。对于一个 8x8x8 tile，每 warp 的线程将访问全局内存中至少四行 (8<em>8</em>8*4 bytes, 32 threads, 64 bits/DRAM = 4)</p>
<h2 id="84-thread-coarsening">8.4 Thread Coarsening</h2>
<p>下图假设每个输入 tile 由 6x6x6 个网格点组成。为了使输入 tile的内部可见，块的前、左和上面没有画出。假设每个输出 tile 由 4x4x4个网格点组成。分配给处理该 tile 的线程块由与输入 tile 的一个x-y平面 (即 6x6) 相同数量的线程组成。程序一开始，每个块需要将包含计算输出块平面值所需的所有点的三个输入块平面加载到共享内存中。在每次迭代期间，块中的所有线程将处理输出 tile 与迭代值相同的 z 索引对应的 x-y 平面。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEBec24cfc7edeb84a1a010b315f5ac49e0?method=download&amp;shareKey=edc686e7586e2c3b7f55e32af7bbd83d" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEBec24cfc7edeb84a1a010b315f5ac49e0?method=download&amp;shareKey=edc686e7586e2c3b7f55e32af7bbd83d" alt="Mapping of Shared Memory Array after First Iteration">
    </a><figcaption>Mapping of Shared Memory Array after First Iteration</figcaption></figure></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#define OUT_TILE_DIM IN_TILE_DIM - 2
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="n">__global__</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">stencil_thread_coarsening_kernel</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span> <span class="n">in</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">out</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">N</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">iStart</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">z</span> <span class="o">*</span> <span class="n">OUT_TILE_DIM</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">__shared__</span> <span class="kt">float</span> <span class="n">inPrev_s</span><span class="p">[</span><span class="n">IN_TILE_DIM</span><span class="p">][</span><span class="n">IN_TILE_DIM</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="n">__shared__</span> <span class="kt">float</span> <span class="n">inCurr_s</span><span class="p">[</span><span class="n">IN_TILE_DIM</span><span class="p">][</span><span class="n">IN_TILE_DIM</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="n">__shared__</span> <span class="kt">float</span> <span class="n">inNext_s</span><span class="p">[</span><span class="n">IN_TILE_DIM</span><span class="p">][</span><span class="n">IN_TILE_DIM</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">iStart</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">iStart</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">inPrev_s</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">][</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">in</span><span class="p">[(</span><span class="n">iStart</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">N</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="n">k</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">iStart</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">iStart</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">inCurr_s</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">][</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">in</span><span class="p">[</span><span class="n">iStart</span> <span class="o">*</span> <span class="n">N</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="n">k</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">OUT_TILE_DIM</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">i</span> <span class="o">+=</span> <span class="n">iStart</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">inNext_s</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">][</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">in</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">N</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="n">k</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="n">__syncthreads</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">			<span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">IN_TILE_DIM</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">			<span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">IN_TILE_DIM</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="n">out</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">N</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">c0</span> <span class="o">*</span> <span class="n">inCurr_s</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">][</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">				<span class="n">c1</span> <span class="o">*</span> <span class="n">inCurr_s</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">][</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">c2</span> <span class="o">*</span> <span class="n">inCurr_s</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">][</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">				<span class="n">c3</span> <span class="o">*</span> <span class="n">inCurr_s</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">+</span> <span class="n">c4</span> <span class="o">*</span> <span class="n">inCurr_s</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">				<span class="n">c5</span> <span class="o">*</span> <span class="n">inPrev_s</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">][</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">+</span> <span class="n">c6</span> <span class="o">*</span> <span class="n">inNext_s</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">][</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">inPrev_s</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">][</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">inCurr_s</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">][</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="n">inCurr_s</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">][</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">inNext_s</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">][</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>线程粗化内核的优点是，它不要求输入 tile 的所有平面都出现在共享内存中。在任意时刻，只有三层输入 tile 需要在共享内存中。</p>
<h2 id="85-register-tiling">8.5 Register Tiling</h2>
<p>根据计算过程可以发现每个 <code>inPrev_s</code> 和 <code>inNext_s</code> 的元素仅由一个线程在计算具有相同 x-y 索引的输出 tile 网格点时使用。只有 inCurr_s 的元素被多个线程访问，真正需要位于共享内存中。因此我们可以修改内涵函数如下，寄存器变量 <code>inPrev</code> 和 <code>inNext</code> 分别替换共享内存数组 <code>inPrev_s</code> 和 <code>inNext_s</code>. 保留了 <code>inCurr_s</code> 以允许在线程之间共享 x-y 平面相邻网格点值。这样这个内核使用的共享内存量减少到原来的 1/3.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">stencil_register_tiling_coarsening_kernel</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span> <span class="n">in</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">out</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">N</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">iStart</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">z</span> <span class="o">*</span> <span class="n">OUT_TILE_DIM</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kt">float</span> <span class="n">inPrev</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">float</span> <span class="n">inCurr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">float</span> <span class="n">inNext</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">	<span class="n">__shared__</span> <span class="kt">float</span> <span class="n">inCurr_s</span><span class="p">[</span><span class="n">IN_TILE_DIM</span><span class="p">][</span><span class="n">IN_TILE_DIM</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">iStart</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">iStart</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">inPrev</span> <span class="o">=</span> <span class="n">in</span><span class="p">[(</span><span class="n">iStart</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">N</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="n">k</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">iStart</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">iStart</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">inCurr</span> <span class="o">=</span> <span class="n">in</span><span class="p">[</span><span class="n">iStart</span> <span class="o">*</span> <span class="n">N</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="n">k</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">		<span class="n">inCurr_s</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">][</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">inCurr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">OUT_TILE_DIM</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">i</span> <span class="o">+=</span> <span class="n">iStart</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">inNext</span> <span class="o">=</span> <span class="n">in</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">N</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="n">k</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="n">__syncthreads</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">			<span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">IN_TILE_DIM</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">			<span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">IN_TILE_DIM</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="n">out</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">N</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">c0</span> <span class="o">*</span> <span class="n">inCurr</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">				<span class="n">c1</span> <span class="o">*</span> <span class="n">inCurr_s</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">][</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">c2</span> <span class="o">*</span> <span class="n">inCurr_s</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">][</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">				<span class="n">c3</span> <span class="o">*</span> <span class="n">inCurr_s</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">+</span> <span class="n">c4</span> <span class="o">*</span> <span class="n">inCurr_s</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">				<span class="n">c5</span> <span class="o">*</span> <span class="n">inPrev</span> <span class="o">+</span> <span class="n">c6</span> <span class="o">*</span> <span class="n">inNext</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">__syncthreads</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="n">inPrev</span> <span class="o">=</span> <span class="n">inCurr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">inCurr</span> <span class="o">=</span> <span class="n">inNext</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">inCurr_s</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">][</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">inNext</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>首先，许多对共享内存的读写现在被转移到寄存器中。其次，每个块只消耗三分之一的共享内存。当然，这是以每个线程多使用 3 个寄存器为代价实现的。需要注意<strong>全局内存访问的数量没有改变</strong>。</p>
]]></content:encoded>
    </item>
    <item>
      <title>PMPP Learning-Chapter 9 Parallel Histogram-An Introduction to Atomic Operations and Privatization</title>
      <link>http://localhost:1313/blogs/courselearning/pmpp/pmpp-ch9/</link>
      <pubDate>Mon, 09 Sep 2024 10:27:42 +0800</pubDate>
      <guid>http://localhost:1313/blogs/courselearning/pmpp/pmpp-ch9/</guid>
      <description>Personal notebook 9 of Programming Massively Parallel Processors.</description>
      <content:encoded><![CDATA[<h1 id="9-parallel-histogram-an-introduction-to-atomic-operations-and-privatization">9 Parallel Histogram-An Introduction to Atomic Operations and Privatization</h1>
<p>本章介绍并行直方图计算模式，其中每个输出元素都可以由任何线程更新。因此，当线程更新输出元素时必须注意线程之间的协调，避免任何可能破坏最终结果的干扰。</p>
<h2 id="91-background">9.1 Background</h2>
<p>直方图是数据集中数据值出现的数量计数或百分比的显示。在最常见的直方图形式中，间隔区间沿水平轴绘制，每个间隔中的数据值计数表示为从水平轴上升的矩形或条形的高度。
许多应用领域依赖于直方图来总结数据集进行数据分析。其中一个领域就是计算机视觉。图像子区域直方图的计算过程是计算机视觉中特征 (图像中感兴趣的模式) 提取的重要方法。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEBf1b2ad27e9184b6ecf628e068c42e7e4?method=download&amp;shareKey=a44ec6cce3fffb07208a7a67ee8005a5" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEBf1b2ad27e9184b6ecf628e068c42e7e4?method=download&amp;shareKey=a44ec6cce3fffb07208a7a67ee8005a5" alt="A Histogram Representation of  “programming massively parallel processors”">
    </a><figcaption>A Histogram Representation of  “programming massively parallel processors”</figcaption></figure></p>
<h2 id="92-atomic-operations-and-a-basic-histogram-kernel">9.2 Atomic Operations and A Basic Histogram Kernel</h2>
<p>如下图所示，并行化直方图计算的最直接的方法是启动数据一样多的线程，让每个线程处理一个元素。每个线程读取其分配的输入元素，并增加对应的隔计数器的值。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEBd162f505e52265f5421f0fa883e5d19b?method=download&amp;shareKey=4d8e366384fcc19aebe518ad8fecdc7d" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEBd162f505e52265f5421f0fa883e5d19b?method=download&amp;shareKey=4d8e366384fcc19aebe518ad8fecdc7d" alt="Basic Parallelization of a Histogram">
    </a><figcaption>Basic Parallelization of a Histogram</figcaption></figure></p>
<p>histo 数组中间隔计数器的增加是对内存位置的更新或 read-modify-write 操作。该操作包括读取内存位置(读)，在原始值上加 1(修改)，并将新值写回内存位置 (写)。在实际过程中会出现读-修改-写竞争条件 (<em>read-modify-write race condition</em>)，在这种情况下，两个或多个同步更新操作的结果会根据所涉及的操作的相对时间而变化。
下图 A 中线程 1 在时间段 1~3 期间完成了其读-修改-写序列的所有三个部分，然后线程 2 在时间段 4 开始，最后结果正确。在图 B 中，两个线程的读-修改-写顺序重叠。线程 1 在时间段 4 时将新值写入 <code>histo[x]</code>。当线程 2 在时间段 3 读取 <code>histo[x]</code>时，它的值仍然是 0，因此最后的写入的值是 1.</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEBfcb1b1249b8c3eaa4b079cc3c6211f60?method=download&amp;shareKey=6c860292730da34f80c4f3020f5e709c" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEBfcb1b1249b8c3eaa4b079cc3c6211f60?method=download&amp;shareKey=6c860292730da34f80c4f3020f5e709c" alt="Race Condition in Updating a histo Array Element">
    </a><figcaption>Race Condition in Updating a histo Array Element</figcaption></figure></p>
<p>原子操作 (<em>atomic operation</em>) 的读、修改和写部分构成一个不可分割的单元，因此称为原子操作。对该位置的其他读-修改-写序列不能与其在时间上有重叠。需要注意<em>原子操作在线程之间不强制任何特定的执行顺序</em>，比如线程 1 可以在线程 2 之前或之后运行。CUDA内核可以通过函数调用对内存位置执行原子加法操作:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">atomicAdd</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">address</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>atomicAdd</code> 是一个内建函数 (intrinsic function)，它被编译成一个硬件原子操作指令。该指令读取全局或共享内存中 <code>address</code> 参数所指向的32位字，将 <code>val</code> 加上旧值中并写入结果回相同地址的内存中。该函数返回地址处的旧值。</p>
<details class="custom-details">
    <summary class="custom-summary">Intrinsic Functions</summary>
    <div>现代处理器通常提供特殊指令，这些指令要么执行关键功能 (如原子操作)，要么大幅提高性能 (如矢量指令)。这些指令通常作为内建函数暴露给程序员，从程序员的角度来看，这些是库函数。然而，它们被编译器以一种特殊的方式处理。每个这样的调用都被翻译成相应的特殊指令。在最终代码中没有函数调用，只有与用户代码一致的特殊指令。</div>
</details><br>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">__global__</span> 
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">histo_kernel</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span> <span class="n">histo</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kt">int</span> <span class="n">alphabet_position</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">alphabet_position</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">alphabet_position</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">atomicAdd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">histo</span><span class="p">[</span><span class="n">alphabet_position</span> <span class="o">/</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="93-latency-and-throughput-of-atomic-operations">9.3 Latency and Throughput of Atomic Operations</h2>
<p>高内存访问吞吐量的关键是同时进行许多 DRAM 访问。然而，当许多原子操作更新相同的内存位置时，一个后面线程的读-修改-写序列在前一个线程的写操作结束之前不能开始，即如下图所示，同时只能有一个线程在同一内存位置执行原子操作。更新这些间隔的大量争用流量会使得吞吐量降低。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEBe7de6cb4432d570997a5d51a354269df?method=download&amp;shareKey=244ed14ff414262053d92e3b884321b4" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEBe7de6cb4432d570997a5d51a354269df?method=download&amp;shareKey=244ed14ff414262053d92e3b884321b4" alt="The Execution of Atomic Operations at the Same Location">
    </a><figcaption>The Execution of Atomic Operations at the Same Location</figcaption></figure></p>
<p>提高原子操作吞吐量的一种方法是减少对竞争严重的位置的访问延迟。现代 GPU 允许在被所有 SM 共享的最后一级缓存中执行原子操作。由于对最后一级缓存的访问时间是几十个周期而不是几百个周期，因此原子操作的吞吐量与早期GPU相比至少提高了一个数量级。</p>
<h2 id="94-privatization">9.4 Privatization</h2>
<p>提高原子操作吞吐量的另一种方法是通过引导流量远离竞争严重的位置。这可以通过一种称为私有化 (<em>privatization</em>) 的技术来实现。其思想是将高度竞争的输出数据结构复制到私有副本中，以便线程的每个子集都可以更新其私有副本。
下图展示了如何将私有化应用于直方图统计。每个线程块由 8 个线程组成，争用只会在同一块中的线程之间以及在最后合并私有副本时发生，而不是更新相同直方图 bin 的所有线程之间发生争用。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEBb7aa2df247e5dc432476efa8b601df20?method=download&amp;shareKey=82f3b5074429b6bf29ca79a092a0044d" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEBb7aa2df247e5dc432476efa8b601df20?method=download&amp;shareKey=82f3b5074429b6bf29ca79a092a0044d" alt="Reduce Contention of Atomic Operations by Private Copies of Histogram">
    </a><figcaption>Reduce Contention of Atomic Operations by Private Copies of Histogram</figcaption></figure></p>
<p>一个私有化版本的代码如下，为 histo 数组分配足够的设备内存 (<code>gridDim.x*NUM_BINS*4</code> bytes) 来保存直方图的所有私有副本。在执行结束时，每个线程块将把私有副本中的值提交到 块 0 的部分。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#define NUM_BINS 7  </span><span class="c1">// # histo bins 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">__global__</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">histo_private_kernel</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span> <span class="n">histo</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kt">int</span> <span class="n">alphabet_position</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">alphabet_position</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">alphabet_position</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">atomicAdd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">histo</span><span class="p">[</span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="mi">7</span> <span class="o">+</span> <span class="n">alphabet_position</span> <span class="o">/</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">__syncthreads</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">		<span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bin</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span> <span class="n">bin</span> <span class="o">&lt;</span> <span class="n">NUM_BINS</span><span class="p">;</span> <span class="n">bin</span> <span class="o">+=</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">binValue</span> <span class="o">=</span> <span class="n">histo</span><span class="p">[</span><span class="n">blockIdx</span> <span class="o">*</span> <span class="n">NUM_BINS</span> <span class="o">+</span> <span class="n">bin</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">			<span class="n">atomicAdd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">histo</span><span class="p">[</span><span class="n">bin</span><span class="p">],</span> <span class="n">binValue</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在每个线程块的基础上创建直方图的私有副本的一个好处是线程可以在提交自己的统计结果之前使用 <code>__syncthreads()</code> 来等待彼此。另一个好处是，如果直方图中的 bin 数量足够小，则可以在共享内存中声明直方图的私有副本 (每个线程块一个)。下面代码直方图在共享内存中分配私有副本 <code>histo_s</code> 数组，并由块的线程并行初始化为 0.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">__global__</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">histo_shared_private_kernel</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span> <span class="n">histo</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Initializing private bins
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">__shared__</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">histo_s</span><span class="p">[</span><span class="n">NUM_BINS</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bin</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span> <span class="n">bin</span> <span class="o">&lt;</span> <span class="n">NUM_BINS</span><span class="p">;</span> <span class="n">bin</span> <span class="o">+=</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">histo_s</span><span class="p">[</span><span class="n">bin</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">__syncthreads</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Histogram
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kt">int</span> <span class="n">alphabet_position</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">alphabet_position</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">alphabet_position</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">atomicAdd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">histo_s</span><span class="p">[</span><span class="n">alphabet_position</span> <span class="o">/</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">__syncthreads</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Commit to global memory
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bin</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span> <span class="n">bin</span> <span class="o">&lt;</span> <span class="n">NUM_BINS</span><span class="p">;</span> <span class="n">bin</span> <span class="o">+=</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kt">unsigned</span> <span class="n">binValue</span> <span class="o">=</span> <span class="n">histo_s</span><span class="p">[</span><span class="n">bin</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">binValue</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">atomicAdd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">histo</span><span class="p">[</span><span class="n">bin</span><span class="p">],</span> <span class="n">binValue</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="95-coarsening">9.5 Coarsening</h2>
<p>私有化的开销是需要将私有副本提交到公共副本。每个线程块都会执行一次提交操作，因此，使用的线程块越多，这个开销就越大。如下图所示，我们可以通过减少块的数量来减少私有副本的数量，从而减少提交到公共副本的次数，让每个线程处理多个输入元素。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEB685390a635126cba569f8c85254bcfc5?method=download&amp;shareKey=bf894427e4a2c0fdce32f9bf00094c52" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEB685390a635126cba569f8c85254bcfc5?method=download&amp;shareKey=bf894427e4a2c0fdce32f9bf00094c52" alt="Contiguous Partition of Input Elements">
    </a><figcaption>Contiguous Partition of Input Elements</figcaption></figure></p>
<p>下面代码是一个连续分区 (<em>contiguous partition</em>) 策略的示例，输入被连续划分成多个段，每个段被分配给一个线程，每个线程从 <code>tid*CFACTOR</code> 迭代到 <code>(tid+1)*CFACTOR</code> 进行所负责部分的统计。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#define CFACTOR 3
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="n">__global__</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">histo_shared_private_contiguous_kernel</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span> <span class="n">histo</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Initializing private bins
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">__shared__</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">histo_s</span><span class="p">[</span><span class="n">NUM_BINS</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bin</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span> <span class="n">bin</span> <span class="o">&lt;</span> <span class="n">NUM_BINS</span><span class="p">;</span> <span class="n">bin</span> <span class="o">+=</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">histo_s</span><span class="p">[</span><span class="n">bin</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">__syncthreads</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Histogram
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">unsigned</span> <span class="n">tid</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">tid</span> <span class="o">*</span> <span class="n">CFACTOR</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">tid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">CFACTOR</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kt">int</span> <span class="n">alphabet_position</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">alphabet_position</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">alphabet_position</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">atomicAdd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">histo_s</span><span class="p">[</span><span class="n">alphabet_position</span> <span class="o">/</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">__syncthreads</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Commit to global memory
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bin</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span> <span class="n">bin</span> <span class="o">&lt;</span> <span class="n">NUM_BINS</span><span class="p">;</span> <span class="n">bin</span> <span class="o">+=</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kt">unsigned</span> <span class="n">binValue</span> <span class="o">=</span> <span class="n">histo_s</span><span class="p">[</span><span class="n">bin</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">binValue</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">atomicAdd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">histo</span><span class="p">[</span><span class="n">bin</span><span class="p">],</span> <span class="n">binValue</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上述在 GPU 上连续分区的思路会导致内存不友好的访问模式，因为 threadIdx 相同的线程访问的不是一块连续的内存区域。因此我们要采用交错分区 (<em>interleaved partition</em>)，如下图所示，即不同线程要处理的分区彼此交错。实际应用中每个线程在每次迭代中应该处理 4 个 char (一个 32 位字)，以充分利用缓存和 SMs 之间的互连带宽。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEB166097c6dec3a7d7eed2c82d5706bf55?method=download&amp;shareKey=79fb19c70cf16d76fdc9113eeefd12e8" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEB166097c6dec3a7d7eed2c82d5706bf55?method=download&amp;shareKey=79fb19c70cf16d76fdc9113eeefd12e8" alt="Interleaved Partition of Input Elements">
    </a><figcaption>Interleaved Partition of Input Elements</figcaption></figure></p>
<p>下面代码是一个交错分区的示例。在循环的第一次迭代中，每个线程使用其全局线程索引访问数据数组:线程 0 访问元素 0，线程 1 访问元素 1，线程 2 访问元素 2&hellip;所有线程共同处理输入的第一个 <code>blockDim.x*gridDim.x</code> 元素。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">__global__</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">histo_shared_private_interleaved_kernel</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span> <span class="n">histo</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Initializing private bins
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">__shared__</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">histo_s</span><span class="p">[</span><span class="n">NUM_BINS</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bin</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span> <span class="n">bin</span> <span class="o">&lt;</span> <span class="n">NUM_BINS</span><span class="p">;</span> <span class="n">bin</span> <span class="o">+=</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">histo_s</span><span class="p">[</span><span class="n">bin</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">__syncthreads</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Histogram
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">unsigned</span> <span class="n">tid</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">tid</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kt">int</span> <span class="n">alphabet_position</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">alphabet_position</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">alphabet_position</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">atomicAdd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">histo_s</span><span class="p">[</span><span class="n">alphabet_position</span> <span class="o">/</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">__syncthreads</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Commit to global memory
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bin</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span> <span class="n">bin</span> <span class="o">&lt;</span> <span class="n">NUM_BINS</span><span class="p">;</span> <span class="n">bin</span> <span class="o">+=</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kt">unsigned</span> <span class="n">binValue</span> <span class="o">=</span> <span class="n">histo_s</span><span class="p">[</span><span class="n">bin</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">binValue</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">atomicAdd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">histo</span><span class="p">[</span><span class="n">bin</span><span class="p">],</span> <span class="n">binValue</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="96-aggregation">9.6 Aggregation</h2>
<p>一些数据集在局部区域有大量相同的数据值。如此高度集中的相同值会导致严重的争用，并降低并行直方图计算的吞吐量。一个简单而有效的优化是，如果每个线程正在更新直方图的相同元素，则将连续的更新聚合为单个更新。下面的代码展示了聚合的直方图计算。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">__global__</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">histo_shared_private_interleaved_aggregated_kernel</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span> <span class="n">histo</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Initializing private bins
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">__shared__</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">histo_s</span><span class="p">[</span><span class="n">NUM_BINS</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bin</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span> <span class="n">bin</span> <span class="o">&lt;</span> <span class="n">NUM_BINS</span><span class="p">;</span> <span class="n">bin</span> <span class="o">+=</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">histo_s</span><span class="p">[</span><span class="n">bin</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">__syncthreads</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Histogram
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">accumulator</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">prevBinIdx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="n">tid</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">tid</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kt">int</span> <span class="n">alphabet_position</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">alphabet_position</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">alphabet_position</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="kt">int</span> <span class="n">currBinIdx</span> <span class="o">=</span> <span class="n">alphabet_position</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="n">currBinIdx</span> <span class="o">!=</span> <span class="n">prevBinIdx</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// Update previous statistics
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="k">if</span> <span class="p">(</span><span class="n">accumulator</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="n">atomicAdd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">histo_s</span><span class="p">[</span><span class="n">prevBinIdx</span><span class="p">],</span> <span class="n">accumulator</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">				<span class="n">accumulator</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">				<span class="n">prevBinIdx</span> <span class="o">=</span> <span class="n">currBinIdx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>  <span class="c1">// Accumulate statistics
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="n">accumulator</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">accumulator</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// Update last bin
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">atomicAdd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">histo_s</span><span class="p">[</span><span class="n">prevBinIdx</span><span class="p">],</span> <span class="n">accumulator</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">__syncthreads</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Commit to global memory
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bin</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span> <span class="n">bin</span> <span class="o">&lt;</span> <span class="n">NUM_BINS</span><span class="p">;</span> <span class="n">bin</span> <span class="o">+=</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kt">unsigned</span> <span class="n">binValue</span> <span class="o">=</span> <span class="n">histo_s</span><span class="p">[</span><span class="n">bin</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">binValue</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">atomicAdd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">histo</span><span class="p">[</span><span class="n">bin</span><span class="p">],</span> <span class="n">binValue</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看出聚合内核需要更多的语句和变量。添加的 if 语句可能会出现控制发散。然而，如果没有争用或存在严重的争用，就很少有控制发散，因为线程要么都在增加累加器值，要么都在连续刷新。</p>
]]></content:encoded>
    </item>
    <item>
      <title>PMPP Learning-Chapter 7 Convolution-An Introduction to Constant Memory and Caching</title>
      <link>http://localhost:1313/blogs/courselearning/pmpp/pmpp-ch7/</link>
      <pubDate>Fri, 06 Sep 2024 10:50:42 +0800</pubDate>
      <guid>http://localhost:1313/blogs/courselearning/pmpp/pmpp-ch7/</guid>
      <description>Personal notebook 7 of Programming Massively Parallel Processors.</description>
      <content:encoded><![CDATA[<h1 id="7-convolution-an-introduction-to-constant-memory-and-caching">7 Convolution-An Introduction to Constant Memory and Caching</h1>
<p>卷积的每个输出数据元素可以相互独立地计算，这是并行计算的理想特性。另一方面，在处理具有边界条件的输出数据元素时，有大量的输入数据共享。这使得卷积可以实现复杂的 tiling 方法和输入数据分段方法。</p>
<h2 id="71-background">7.1 Background</h2>
<p>输入数据向量 $[x_0, x_1, \cdots, x_{n-1}]$ 和包含 2r+1 个元素的 filter 数组 $[f_0, f_1, \cdots, f_{2r}]$， 1D卷积计算公式为
</p>
$$y_i=\sum_{j=-r}^rf_{i+j}\times x_i$$<p>
同样对于 <code>n*n</code> 大小的二维输入，和 <code>r*r</code> 大小的 filter，2D 卷积计算公式为
</p>
$$P_{y,x}=\sum_{j=-r_y}^{r_y}\sum_{k=-r_x}^{r_x}f_{y+j,x+k}\times N_{y,x}$$<h2 id="72-parallel-convolution-a-basic-algorithm">7.2 Parallel Convolution: a Basic Algorithm</h2>
<p>假设二维卷积内核接收五个参数: 输入数组 N 的指针; 滤波器 F 的指针; 输出数组 P 的指针; 方形滤波器的半径 r; 输入输出数组的宽度; 输入和输出数组的高度。如下图所示，一个简单的并行方式是网格中的每个线程计算与自身坐标相同的输出像素。对应的内核函数代码如下，浮点计算与全局内存访问的比仅为 0.25 OP/B (每加载 8 字节执行 2 次运算)</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEBb705cd006867704636e9e5261467570f?method=download&amp;shareKey=d5710b7dee0a3c91d67011d92b623557" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEBb705cd006867704636e9e5261467570f?method=download&amp;shareKey=d5710b7dee0a3c91d67011d92b623557" alt="Parallelization and Thread Organization for 2D Convolution">
    </a><figcaption>Parallelization and Thread Organization for 2D Convolution</figcaption></figure></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">__global__</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">convolution_2D_basic_kernel</span> <span class="p">(</span><span class="kt">float</span> <span class="o">*</span><span class="n">N</span><span class="p">,</span> <span class="kt">float</span> <span class="o">*</span><span class="n">F</span><span class="p">,</span> <span class="kt">float</span> <span class="o">*</span><span class="n">P</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">									<span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">outCol</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">outRow</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">Pvalue</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">fRow</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">fRow</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">*</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">fRow</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">fCol</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">fCol</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">fCol</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="kt">int</span> <span class="n">inRow</span> <span class="o">=</span> <span class="n">outRow</span> <span class="o">-</span> <span class="n">r</span> <span class="o">+</span> <span class="n">fRow</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="kt">int</span> <span class="n">inCol</span> <span class="o">=</span> <span class="n">outCol</span> <span class="o">-</span> <span class="n">r</span> <span class="o">+</span> <span class="n">fCol</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="n">inRow</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">inRow</span> <span class="o">&lt;</span> <span class="n">height</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">				<span class="n">inCol</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">inCol</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="n">Pvalue</span> <span class="o">+=</span> <span class="n">P</span><span class="p">[</span><span class="n">inRow</span> <span class="o">*</span> <span class="n">width</span> <span class="o">+</span> <span class="n">inCol</span><span class="p">]</span> <span class="o">*</span> <span class="n">F</span><span class="p">[</span><span class="n">fRow</span> <span class="o">*</span> <span class="n">r</span> <span class="o">+</span> <span class="n">fCol</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">P</span><span class="p">[</span><span class="n">outRow</span> <span class="o">*</span> <span class="n">width</span> <span class="o">+</span> <span class="n">outCol</span><span class="p">]</span> <span class="o">=</span> <span class="n">Pvalue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="73-constant-memory-and-caching">7.3 Constant Memory and Caching</h2>
<p>可以发现卷积核 F 通常很小，在整个卷积内核的执行过程中不会改变，所有线程都以相同的顺序访问其元素。因此我们可以考虑将其存储在常量内存里，之前说过它和全局内存的区别是线程不能修改常量内存变量的值并且常量内存非常小，目前为 64 KB.
假设已经在主机代码里分配好 F_h 的内存，可以通过 <code>cudaMemcpyToSymbol()</code> 将其从主机内存传输到设备常量内存中。内核函数以全局变量的形式访问常量内存变量。因此，它们的指针不需要作为参数传递给内核函数。</p>
<p><strong>如果主机代码和内核代码位于不同的文件中，内核代码文件必须包含相关的外部声明的头文件，以确保声明对内核可见。</strong></p>
<p>CUDA runtime 知道常量内存变量在内核执行期间不会被修改，因此会让硬件在内核执行期间直接缓存常量内存变量。在不需要支持写的情况下，可以在减小芯片面积和降低功耗的情况下设计用于常量内存变量的专用缓存，被称为常量缓存 (<code>constant caching</code>).</p>
<h2 id="74-tiled-convolution-with-halo-cells">7.4 Tiled Convolution with Halo Cells</h2>
<p>我们定义输出 tile 为每个块处理的输出元素，输入 tile 为计算输出 tile 中元素所需的输入元素的集合。下图给出了一个例子，可以看到输入 tile 大小和输出 tile 大小之间的差异使 tile 卷积核的设计变得复杂。有两种线程组织可以处理这种差异。</p>
<ul>
<li>启动与输入 tile 具有相同维度的线程块。这样因为每个线程只需要加载一个输入元素。但由于输入 tile 比对应的输出 tile 大，在计算输出元素时需要禁用一些线程，降低了资源利用率。</li>
<li>启动与输出 tile 具有相同维度的线程块。这样线程需要迭代以确保加载所有输入 tile 元素。但简化了输出元素的计算。</li>
</ul>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEBda4dfd50e011362c0cc68caaf130a16d?method=download&amp;shareKey=b534279430a6d88b51d9523c3cdf486b" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEBda4dfd50e011362c0cc68caaf130a16d?method=download&amp;shareKey=b534279430a6d88b51d9523c3cdf486b" alt="Input Tile vs. Output Tile in 2D Convolution">
    </a><figcaption>Input Tile vs. Output Tile in 2D Convolution</figcaption></figure></p>
<p>第一种线程组织方式的内核如下。现在每个块中的线程共同执行 <code>OUT_TILE_DIM^2*(2*FILTER_RADIUS+1)</code> 次浮点运算。分配给输入 tile 元素的每个线程加载一个4字节的输入值。因此每个block加载 <code>IN_TILE_DIM^2*4=(OUT_TILE_DIM+2*FILTER_RADIUS)^2*4</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#define IN_TILE_DIM 32
</span></span></span><span class="line"><span class="cl"><span class="cp">#define FILTER_RADIUS 5
</span></span></span><span class="line"><span class="cl"><span class="cp">#define OUT_TILE_DIM (IN_TILE_DIM - 2*(FILTER_RADIUS))
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="n">__constant__</span> <span class="kt">float</span> <span class="n">F_c</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">FILTER_RADIUS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">FILTER_RADIUS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">__global__</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">convolution_tiled_2D_constant_mem_kernel_1</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="kt">float</span><span class="o">*</span> <span class="n">N</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">P</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Upper left input tile coord
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">OUT_TILE_DIM</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">FILTER_RADIUS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">OUT_TILE_DIM</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">FILTER_RADIUS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Loading input tile
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">__shared__</span> <span class="kt">float</span> <span class="n">N_s</span><span class="p">[</span><span class="n">IN_TILE_DIM</span><span class="p">][</span><span class="n">IN_TILE_DIM</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">row</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">height</span> <span class="o">&amp;&amp;</span> <span class="n">col</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">N_s</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">][</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">N</span><span class="p">[</span><span class="n">row</span> <span class="o">*</span> <span class="n">width</span> <span class="o">+</span> <span class="n">col</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">N_s</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">][</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">__syncthreads</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Calculate output elements
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">int</span> <span class="n">tileCol</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">FILTER_RADIUS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">tileRow</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">FILTER_RADIUS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">row</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">height</span> <span class="o">&amp;&amp;</span> <span class="n">col</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">width</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">		<span class="n">tileCol</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">tileCol</span> <span class="o">&lt;</span> <span class="n">OUT_TILE_DIM</span> <span class="o">&amp;&amp;</span> <span class="n">tileRow</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">tileRow</span> <span class="o">&lt;</span> <span class="n">OUT_TILE_DIM</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="kt">float</span> <span class="n">Pvalue</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">fRow</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">fRow</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">FILTER_RADIUS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">fRow</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">fCol</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">fCol</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">FILTER_RADIUS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">fCol</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="n">Pvalue</span> <span class="o">+=</span> <span class="n">F_c</span><span class="p">[</span><span class="n">fRow</span><span class="p">][</span><span class="n">fCol</span><span class="p">]</span> <span class="o">*</span> <span class="n">N_s</span><span class="p">[</span><span class="n">tileRow</span> <span class="o">+</span> <span class="n">fRow</span><span class="p">][</span><span class="n">tileCol</span> <span class="o">+</span> <span class="n">fCol</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="n">P</span><span class="p">[</span><span class="n">row</span> <span class="o">*</span> <span class="n">width</span> <span class="o">+</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">Pvalue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>第二种线程组织方式的内核如下，每个线程现在可能需要加载多个输入 tile 的元素。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">__global__</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">convolution_tiled_2D_constant_mem_kernel_2</span><span class="p">(</span>  <span class="c1">// OUT_TILE_DIM^2 threads per block
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">float</span><span class="o">*</span> <span class="n">N</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">P</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Upper left output tile coord
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">OUT_TILE_DIM</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">OUT_TILE_DIM</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Each thread may need to load multiple elements into shared memory
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">__shared__</span> <span class="kt">float</span> <span class="n">N_s</span><span class="p">[</span><span class="n">IN_TILE_DIM</span><span class="p">][</span><span class="n">IN_TILE_DIM</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">IN_TILE_DIM</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">OUT_TILE_DIM</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">IN_TILE_DIM</span><span class="p">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="n">OUT_TILE_DIM</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="kt">int</span> <span class="n">in_col</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">OUT_TILE_DIM</span> <span class="o">+</span> <span class="n">j</span> <span class="o">-</span> <span class="n">FILTER_RADIUS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="kt">int</span> <span class="n">in_row</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">OUT_TILE_DIM</span> <span class="o">+</span> <span class="n">i</span> <span class="o">-</span> <span class="n">FILTER_RADIUS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="n">in_row</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">in_row</span> <span class="o">&lt;</span> <span class="n">height</span> <span class="o">&amp;&amp;</span> <span class="n">in_col</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">in_col</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="n">N_s</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">N</span><span class="p">[</span><span class="n">in_row</span> <span class="o">*</span> <span class="n">width</span> <span class="o">+</span> <span class="n">in_col</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="n">N_s</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">__syncthreads</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Calculate output elements
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">OUT_TILE_DIM</span> <span class="o">&amp;&amp;</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">OUT_TILE_DIM</span> <span class="o">&amp;&amp;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">height</span> <span class="o">&amp;&amp;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kt">float</span> <span class="n">Pvalue</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">fRow</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">fRow</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">FILTER_RADIUS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">fRow</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">fCol</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">fCol</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">FILTER_RADIUS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">fCol</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="n">Pvalue</span> <span class="o">+=</span> <span class="n">F_c</span><span class="p">[</span><span class="n">fRow</span><span class="p">][</span><span class="n">fCol</span><span class="p">]</span> <span class="o">*</span> <span class="n">N_s</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">fRow</span><span class="p">][</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">fCol</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="n">P</span><span class="p">[</span><span class="n">row</span> <span class="o">*</span> <span class="n">width</span> <span class="o">+</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">Pvalue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="75-tiled-convolution-using-caches-for-halo-cells">7.5 Tiled Convolution Using Caches for Halo Cells</h2>
<p>当一个块需要它的 halo cell 时，由于相邻块的访问，它们已经在二级缓存中了。因此，对这些  halo cell 的内存访问可以从 L2 缓存提供，而不会造成额外的 DRAM 流量。我们可以对原来的 N 进行这些 halo cell 的访问，而不是将它们加载到 <code>N_ds</code> 中。代码如下，加载 N_s 变得更简单，因为每个线程可以简单地加载与其分配的输出元素具有相同坐标的输入元素。然而，计算P个元素的循环体变得更加复杂。它需要添加条件来检查 helo cell 和 ghost cell.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">__global__</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">convolution_tiled_cached_2D_shared_mem_kernel</span><span class="p">(</span>  <span class="c1">// OUT_TILE_DIM^2 threads per block
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">float</span><span class="o">*</span> <span class="n">N</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">P</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">col</span> <span class="o">=</span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">OUT_TILE_DIM</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">row</span> <span class="o">=</span><span class="n">blockIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">OUT_TILE_DIM</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// loading input tile
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">__shared__</span> <span class="kt">float</span> <span class="n">N_s</span><span class="p">[</span><span class="n">IN_TILE_DIM</span><span class="p">][</span><span class="n">IN_TILE_DIM</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">row</span> <span class="o">&lt;</span> <span class="n">height</span> <span class="o">&amp;&amp;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">N_s</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">][</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">N</span><span class="p">[</span><span class="n">row</span> <span class="o">*</span> <span class="n">width</span> <span class="o">+</span> <span class="n">col</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">N_s</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">][</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">__syncthreads</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Calculate output elements
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">col</span> <span class="o">&lt;</span> <span class="n">width</span> <span class="o">&amp;&amp;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">float</span> <span class="n">Pvalue</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// turning off the threads at the edge of the block
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">fRow</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">fRow</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">FILTER_RADIUS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">fRow</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">fCol</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">fCol</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">FILTER_RADIUS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">fCol</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">fCol</span> <span class="o">-</span> <span class="n">FILTER_RADIUS</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">                    <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">fCol</span> <span class="o">-</span> <span class="n">FILTER_RADIUS</span> <span class="o">&lt;</span> <span class="n">IN_TILE_DIM</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">                    <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">fRow</span> <span class="o">-</span> <span class="n">FILTER_RADIUS</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">                    <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">fRow</span> <span class="o">-</span> <span class="n">FILTER_RADIUS</span> <span class="o">&lt;</span> <span class="n">IN_TILE_DIM</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    <span class="n">Pvalue</span> <span class="o">+=</span> <span class="n">F_c</span><span class="p">[</span><span class="n">fRow</span><span class="p">][</span><span class="n">fCol</span><span class="p">]</span> <span class="o">*</span> <span class="n">N_s</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">fRow</span><span class="p">][</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">fCol</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="k">if</span> <span class="p">(</span><span class="n">row</span> <span class="o">-</span> <span class="n">FILTER_RADIUS</span> <span class="o">+</span> <span class="n">fRow</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">                        <span class="n">row</span> <span class="o">-</span> <span class="n">FILTER_RADIUS</span> <span class="o">+</span> <span class="n">fRow</span> <span class="o">&lt;</span> <span class="n">height</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">                        <span class="n">col</span> <span class="o">-</span> <span class="n">FILTER_RADIUS</span> <span class="o">+</span> <span class="n">fCol</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">                        <span class="n">col</span> <span class="o">-</span> <span class="n">FILTER_RADIUS</span> <span class="o">+</span> <span class="n">fCol</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                        <span class="n">Pvalue</span> <span class="o">+=</span> <span class="n">F_c</span><span class="p">[</span><span class="n">fRow</span><span class="p">][</span><span class="n">fCol</span><span class="p">]</span> <span class="o">*</span> <span class="n">N</span><span class="p">[(</span><span class="n">row</span> <span class="o">-</span> <span class="n">FILTER_RADIUS</span> <span class="o">+</span> <span class="n">fRow</span><span class="p">)</span> <span class="o">*</span> <span class="n">width</span> <span class="o">+</span> <span class="p">(</span><span class="n">col</span> <span class="o">-</span> <span class="n">FILTER_RADIUS</span> <span class="o">+</span> <span class="n">fCol</span><span class="p">)];</span>
</span></span><span class="line"><span class="cl">                    <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">N</span><span class="p">[</span><span class="n">row</span> <span class="o">*</span> <span class="n">width</span> <span class="o">+</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">Pvalue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>Halo Cell: 实际计算区域周围添加的一圈额外的单元格。本质上是 &ldquo;虚拟&rdquo; 单元格，存在于不直接关注的区域之外。</li>
<li>Ghost Cell: 存储来自相邻 tile 的数据副本，使得 block 在无需直接访问彼此的内存的情况下访问相邻的必要数据。</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>PMPP Learning-Chapter 6 Performance Considerations</title>
      <link>http://localhost:1313/blogs/courselearning/pmpp/pmpp-ch6/</link>
      <pubDate>Thu, 05 Sep 2024 22:22:12 +0800</pubDate>
      <guid>http://localhost:1313/blogs/courselearning/pmpp/pmpp-ch6/</guid>
      <description>Personal notebook 6 of Programming Massively Parallel</description>
      <content:encoded><![CDATA[<h1 id="6-performance-considerations">6 Performance Considerations</h1>
<p>并行程序的执行速度根据程序的资源需求和硬件的资源约束之间的相互制约会有很大的变化。管理并行代码和硬件资源约束之间的交互对于在几乎所有并行编程模型中实现高性能非常重要。</p>
<h2 id="61-memory-coalescing">6.1 Memory Coalescing</h2>
<p>影响 CUDA 内核性能最重要的因素之一是访问全局内存中的数据，有限的带宽可能成为瓶颈。CUDA 设备的全局内存是用 DRAM 实现的。数据存储在DRAM单元中，访问时间通常是纳秒级别，相对于亚纳秒级别的时钟周期来说很慢。现代 DRAM 通过并行化设计来提高数据访问速率，通常称为内存访问吞吐量 (<em>memory access throughput</em>).</p>
<details class="custom-details">
    <summary class="custom-summary">Why Are DRAMs So Slow</summary>
    <div><p>DRAM 通过一个个 CMOS 晶体管 (称为 <code>cell</code>) 来存储 0/1. 当给晶体管最上面的一端 (称作栅极) 加上电压或是取消电压，晶体管两端就可以流过电流。cell 中的小电容是存储信息的关键，小电容可以存储电荷，当电容存有电荷，cell 存储 1；当电容不存电荷，存储 0.
当要读取 cell 的存储值，首先打开晶体），然后根据导通后的电容是否会进行充放电信息获得存储值。如果 cell 存储 1，即电容存有电荷，那么当打开开关时电容就会放电；反之则不会。
一个 cell 只能存储 1 比特信息，为了存储大量信息，需要构建起如图所示的 cell 阵列。可以看到每行 cell 的晶体管的栅极都是连在一起的，即都连在字线 (<em>word line</em>) 上，这意味着给字线施加电压，字线对应的一行cell都会被打开。当一行 cell 被打开，cell 电容就会向位线 (<em>bit line</em>) 充放电，一行中的每个 cell 都与一条位线直接相连，读取位线的电压变化，即可知道 cell 的存储信息。</p>
<ul>
<li>字线：用来控制读取哪一个字，一个字由 4字节组成。之所以叫字线，是因为给这根线通电，一行 cell 都会被打开.多个 cell 组合起来就是多个字，因为这根线可以打开多个字，所以叫字线</li>
<li>位线：在读取信息时，每一根线上的电压波动都代表一位比特信息，所以叫做位线。
cell 的读取依靠小电容充放电，电容充放电导致位线产生电压波动，通过读取位线电压波动即可获取信息。小电容充放电所产生的电压波动是很微弱的，充放电所造成的电压波动的时间也是很短的，因此很难直接读取充放电信息，为此 cell 阵列的读取使用到了 sense amplifier，即读出放大器。读出放大器可以捕捉到微弱的电压波动，并根据电压波动的情况在本地还原出 cell 的电容电压，而且放大器内还有锁存器，可以把还原出来的电容电压值保存起来，这样一来 cell 保存的信息就从 cell 电容转移到了放大器本地。
每条位线都要接到一个放大器中。在读取 cell 行前，需要把每根位线都预充电 (precharge) 到电容电压/供电电压最大值的一半。在 DRAM 芯片中，读出放大器把 cell 阵列分成了两半，因为其采用的是差分放大器，需要同时接入两根位线。放大信号波动时需要用一个基准和待测线作比较，接到放大器上的两条位线的其中一条就作为基准。在读出数据之后，根据放大器锁存的值，把各条位线拉到供电电压或接到地，然后 cell 电容就会根据位线电压进行充电或放电，当 cell 电容充放电结束，就可以断开字线，宣告本次 DRAM 读取结束。
简单来说读取一个比特的总体流程是：获得行号，译码行号，开启单元行，放大位线电压波动并暂存数据到放大器，获得列号并根据列号选择一位进行输出，写回数据，关闭字线，重新预充电。而写一个比特的总体流程是：获得行号，译码行号，开启单元行，放大位线电压波动并暂存数据到放大器，获得列号并输入写入数据，根据列号把写入数据送到放大器并改写暂存值，写回数据，关闭字线，重新预充电。
其中花费时间最久的两项是开启单元行和放大电压波动并暂存数据。开启单元行时行地址译码器需要拉高一条字线，然后用这一条字线拉高单元行上所有晶体管的栅极电压，相当于给一个很大的电容充电，非常花费时间。放大器大部分是模拟电路，工作速度不快，因此放大电压波动并暂存数据也很花费时间。</li>
</ul>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEB6667e871e68ba1c132af4f6531083e10?method=download&amp;shareKey=3a67fa6fac6a2e83fa7f0e5f0bf2c01c" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEB6667e871e68ba1c132af4f6531083e10?method=download&amp;shareKey=3a67fa6fac6a2e83fa7f0e5f0bf2c01c" alt="DRAM Cell Array">
    </a><figcaption>DRAM Cell Array</figcaption></figure></p>
</div>
</details><br>
<p>由于读取非常耗时，DRAM 每次读取数据都会存储在放大器本地缓存 (<em>row buffer</em> / <em>cache line</em>). 缓存行内的各个字在内存上是相邻的，每当读取 cell 阵列中的一个比特会把其所在缓存行的所有比特都送到输出缓存，这种读取方式叫做突发 (<em>burst</em>). 当 warp 中的所有线程访问连续的全局内存位置时，硬件将所有这些访问合并 (colaesce) 为对连续 DRAM 位置的访问 (即行地址)。
有各种优化策略来实现内存合并。</p>
<ul>
<li>重新排列线程到数据的映射。</li>
<li>重新排列数据本身的布局。</li>
<li><em>corner turning</em>: 以合并的方式在全局内存和共享内存之间传输数据，并在共享内存中执行不利的访问模式。共享内存是用SRAM技术实现的，不需要合并，因此不是连续的地址访问带来的影响不大。
内存合并的主要优点是，能通过将多个内存访问合并为单个访问来减少全局内存流量。</li>
</ul>
<h2 id="62-hiding-memory-latency">6.2 Hiding memory latency</h2>
<p>一个 cell 阵列一次可以提供一个比特，那么 8 个 cell 阵列就可以一次提供 8 个比特，他们共享一组行地址和列地址，被称作一个 <em>bank</em>. 处理器包含一个或多个通道 (<em>channel</em>). 每个通道都是一个带有总线的内存控制器，该总线将一组 DRAM 组连接到处理器。
如下图所示当两个 bank 连接到通道总线时，当第一个 bank 为另一个访问提供服务时，可以在第二个 bank 发起访问。一般来说，如果 cell 阵列访问延迟与数据传输时间之比为 R，则充分利用信道总线的数据传输带宽至少需要 R+1 个 bank 。更多的 bank 减少了针对同一 bank 的多个同时访问的概率，这种现象称为 bank 冲突 (<em>bank conflict</em>). 由于每个 bank 一次只能译码一行字线，因此这些冲突访问的单元阵列访问延迟不能再重叠。拥有更多数量的 bank 会增加这些访问分散到多个 bank 的可能性。第二个原因是每个 cell 阵列的大小限制了每个 bank 可以提供的比特数。因此第四章所说的最大化占用率还有一个额外的好处，那就是确保发出足够的内存访问请求来隐藏 DRAM 访问延迟。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEB1ca208a23c106f7778f72d2d9a329c34?method=download&amp;shareKey=705ee6d9699bf36549f5740c33688ce0" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEB1ca208a23c106f7778f72d2d9a329c34?method=download&amp;shareKey=705ee6d9699bf36549f5740c33688ce0" alt="Banking Improves the Utilization of Data Transfer Bandwidth of a Channel">
    </a><figcaption>Banking Improves the Utilization of Data Transfer Bandwidth of a Channel</figcaption></figure></p>
<p>分布方案存储如下图所示，通常称为交错数据分布 (<em>interleaved data distribution</em>). 对于一个 4*4 的矩阵，每输出矩阵的每个元素计算将对通道 0 中的两个 bank 以及通道 2 中的两个 bank 进行合并访问。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEB0ff74f917a82000ff47b38ea6ca53b82?method=download&amp;shareKey=def9f25f25bee24133ae10ac5eee4696" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEB0ff74f917a82000ff47b38ea6ca53b82?method=download&amp;shareKey=def9f25f25bee24133ae10ac5eee4696" alt="An Example of Interleaved Data Distribution">
    </a><figcaption>An Example of Interleaved Data Distribution</figcaption></figure></p>
<h2 id="63-thread-coarsening">6.3 Thread Coarsening</h2>
<p>以最细粒度并行化工作的缺点在于，并行化工作需要付出代价，例如不同线程块对数据的重复加载、冗余工作、同步开销等。如果硬件最由于资源不足而顺序执行，那么这个代价是不必要的。部分序列化工作，减少为并行性付出的代价。因此可以通过为每个线程分配多个最细粒度的工作来解决，通常被称为线程粗化 (<em>thread coarsening</em>).
如下图所示，在之前的 tiled 矩阵乘法里，由于共享内存内容不能跨块共享，每个块必须加载矩阵 M 的 tile 副本。因此可以让块中的每个线程处理两个输出元素。这样，粗化的线程块将加载 M 的 tile 一次，并将它们用于计算为多个输出 tile.</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEBd0127fed6f7a89006a4338bcd85b6c84?method=download&amp;shareKey=701002f69c07f74fa723fbe036467ff9" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEBd0127fed6f7a89006a4338bcd85b6c84?method=download&amp;shareKey=701002f69c07f74fa723fbe036467ff9" alt="Thread Coarsening for Tiled Matrix Multiplication">
    </a><figcaption>Thread Coarsening for Tiled Matrix Multiplication</figcaption></figure></p>
<p>下面的代码展示了线程粗化的矩阵乘法内核函数，在 <code>width/TILE_WIDTH</code> 的每次迭代中，一个线程计算原来 <code>COARSE_FACTOR</code> 个线程对应位置的输出。</p>
<p>使用线程粗化时要注意：</p>
<ul>
<li>不要在不必要的时候使用，当并行化的代价可以通过粗化来降低时，粗化是有益的。</li>
<li>不要使用过多的粗化，以免硬件资源得不到充分利用。</li>
<li>避免将资源消耗增加到损害占用的程度。根据内核的不同，线程粗化可能需要每个线程使用更多的寄存器或每个线程块使用更多的共享内存。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">__global__</span> 
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">CoarsingMatrixMulKernel</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span> <span class="n">M</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">N</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">P</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">__shared__</span> <span class="kt">float</span> <span class="n">Mds</span><span class="p">[</span><span class="n">TILE_WIDTH</span><span class="p">][</span><span class="n">TILE_WIDTH</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="n">__shared__</span> <span class="kt">float</span> <span class="n">Nds</span><span class="p">[</span><span class="n">TILE_WIDTH</span><span class="p">][</span><span class="n">TILE_WIDTH</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">bx</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span> <span class="kt">int</span> <span class="n">by</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">tx</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span> <span class="kt">int</span> <span class="n">ty</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Identify the row and column of the P element to work on
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="n">by</span> <span class="o">*</span> <span class="n">TILE_WIDTH</span> <span class="o">+</span> <span class="n">ty</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">colStart</span> <span class="o">=</span> <span class="n">bx</span> <span class="o">*</span> <span class="n">TILE_WIDTH</span> <span class="o">*</span> <span class="n">COARSE_FACTOR</span> <span class="o">+</span> <span class="n">tx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Initialize Pvalue for all output elements
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">float</span> <span class="n">Pvalue</span><span class="p">[</span><span class="n">COARSE_FACTOR</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">COARSE_FACTOR</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">Pvalue</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Loop over the M and N tiles required to compute P element
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">ph</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ph</span> <span class="o">&lt;</span> <span class="n">width</span><span class="o">/</span><span class="n">TILE_WIDTH</span><span class="p">;</span> <span class="n">ph</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// the COARSE_FACTOR tiles of N needs the same tile of M
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">Mds</span><span class="p">[</span><span class="n">ty</span><span class="p">][</span><span class="n">tx</span><span class="p">]</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="n">row</span> <span class="o">*</span> <span class="n">width</span> <span class="o">+</span> <span class="n">ph</span> <span class="o">*</span> <span class="n">TILE_WIDTH</span> <span class="o">+</span> <span class="n">tx</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">COARSE_FACTOR</span><span class="p">;</span> <span class="n">c</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="n">colStart</span> <span class="o">+</span> <span class="n">c</span> <span class="o">*</span> <span class="n">TILE_WIDTH</span><span class="p">;</span>  <span class="c1">// Value to be computed in the c th tile
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// Collaborative loading of N tile into shared memory
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="n">Nds</span><span class="p">[</span><span class="n">ty</span><span class="p">][</span><span class="n">tx</span><span class="p">]</span> <span class="o">=</span> <span class="n">N</span><span class="p">[(</span><span class="n">ph</span> <span class="o">*</span> <span class="n">TILE_WIDTH</span> <span class="o">+</span> <span class="n">ty</span><span class="p">)</span> <span class="o">*</span> <span class="n">width</span> <span class="o">+</span> <span class="n">col</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">			<span class="n">__syncthreads</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">TILE_WIDTH</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="n">Pvalue</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">+=</span> <span class="n">Mds</span><span class="p">[</span><span class="n">ty</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">Nds</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">tx</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="n">__syncthreads</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">COARSE_FACTOR</span><span class="p">;</span> <span class="n">c</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="n">colStart</span> <span class="o">+</span> <span class="n">c</span> <span class="o">*</span> <span class="n">TILE_WIDTH</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="n">P</span><span class="p">[</span><span class="n">row</span> <span class="o">*</span> <span class="n">width</span> <span class="o">+</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">Pvalue</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div>]]></content:encoded>
    </item>
    <item>
      <title>PMPP Learning-Chapter 4 Compute Architecture and Scheduling</title>
      <link>http://localhost:1313/blogs/courselearning/pmpp/pmpp-ch4/</link>
      <pubDate>Thu, 05 Sep 2024 09:18:11 +0800</pubDate>
      <guid>http://localhost:1313/blogs/courselearning/pmpp/pmpp-ch4/</guid>
      <description>Personal notebook 3 of Programming Massively Parallel</description>
      <content:encoded><![CDATA[<h1 id="compute-architecture-and-scheduling">Compute Architecture and Scheduling</h1>
<p>本章介绍 GPU 计算架构，并说明灵活资源分配、块调度和占用的概念。然后将深入讨论线程调度、延迟容忍、控制发散和同步。</p>
<h2 id="41-architecture-of-a-modern-gpu">4.1 Architecture of a modern GPU</h2>
<p>下图展示了 CUDA GPU 架构，它被组织成一个流式多处理器 (<em>Streaming Multiprocessors, SMs</em>) 数组。每个 SM 都有几个处理单元，称为流处理器或 CUDA core (简称为 <em>core</em>)，如图中 SMs 内部的小块所示，它们共享控制逻辑和内存资源。</p>
<p>SMs 还带有不同的片上存储结构，统称为内存。GPU 还带有千兆字节的片外设备内存，称为全局内存 (<em>global memory</em>).</p>
<blockquote>
<p>虽然旧的GPU使用 DDR DRAM，但从 NVIDIA 的 Pascal 架构开始 GPU 可能使用HBM (High-Bandwidth Memory) 或 HBM2，它们由 DRAM 模块组成，与GPU紧密集成在同一个封装中。</p></blockquote>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEB4312b496c54bae36f2978ad5ef0fbe56?method=download&amp;shareKey=6caf263b9392411f7d50e7f4d5bcaf80" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEB4312b496c54bae36f2978ad5ef0fbe56?method=download&amp;shareKey=6caf263b9392411f7d50e7f4d5bcaf80" alt="Architecture of a CUDA-capable GPU">
    </a><figcaption>Architecture of a CUDA-capable GPU</figcaption></figure></p>
<h2 id="42-block-scheduling">4.2 Block Scheduling</h2>
<p>当调用内核时，CUDA runtime 系统启动执行内核代码的线程网格，<strong>块中的所有线程同时分配给同一个的 SM</strong>. 下图中每个 SM 分配了三个块，但是块需要占用硬件资源来执行，因此同时只能将有限数量的块分配给给定的 SM. 为了确保网格中的所有块都得到执行，runtime 系统维护一个需要执行的块列表，并在先前分配的块完成执行后再将新块分配给 SMs. 以块为基本单元将线程分配给 SMs 保证了<strong>同一块中的线程在同一SM上同时被调度</strong>。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEBba45a5209304777991608711b3734d55?method=download&amp;shareKey=59a8744be11db1fad3afad00c6b06363" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEBba45a5209304777991608711b3734d55?method=download&amp;shareKey=59a8744be11db1fad3afad00c6b06363" alt="Thread Block Assignment to SMs">
    </a><figcaption>Thread Block Assignment to SMs</figcaption></figure></p>
<h2 id="43-synchronization-and-transparent-scalability">4.3 Synchronization and Transparent Scalability</h2>
<p>CUDA 允许同一块中的线程使用 barrier 同步函数 <code>__syncthreads()</code> 来协调其行动。下图展示了屏障同步的执行情况，箭头表示线程各自执行运行的时间。弯曲线标记了每个线程开始执行 <code> __syncthreads()</code> 的时间。弯曲线右侧的空白区域表示每个线程等待所有线程完成所需的时间。竖线标志着最后一个线程执行 <code> __syncthreads()</code> 的时间，之后所有线程都被允许继续执行 <code> __syncthreads()</code> 之后的代码。</p>
<p>不要在分支语句中使用 <code>__syncthreads()</code></p>
<ul>
<li>放在 if 语句中时，块中的所有线程要么全执行包含 <code>__syncthreads()</code> 的路径，要么都不执行。</li>
<li>if-else 语句中的两个分支都存在，块中的所有线程要么全执行 if 情况下的 <code>__syncthreads()</code> 的路径，要么全执行 else 下的路径。</li>
</ul>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEB973934d16ec550ef1e8998134754ea69?method=download&amp;shareKey=eb626fd61b25664d6884d1c701e58756" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEB973934d16ec550ef1e8998134754ea69?method=download&amp;shareKey=eb626fd61b25664d6884d1c701e58756" alt="A Example Execution of Barrier Synchronization">
    </a><figcaption>A Example Execution of Barrier Synchronization</figcaption></figure></p>
<p>系统需要确保所有参与 barrier 同步的线程都能访问足够资源以到达 barrier. 否则，那些到达不了线程可能会导致死锁。因此只有当 runtime 系统确保了块中所有线程有完成执行所需的所有资源时，一个块才能开始执行。
通过禁止不同块中的线程一起执行 barrier 同步，CUDA runtime 系统可以以任何顺序执行块。如下图所示，在只有少量执行资源的系统中，一次执行两个块。反之，可以同时执行多个块。这种在不同硬件上使用不同数量的执行资源执行相同的代码的能力被称为透明可扩展性 (<em>transparent scalability</em>)</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEB415e750cfd1c8bd730783cf2aadeafa0?method=download&amp;shareKey=1a0f812fee9a129ac6972abb6a59a12d" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEB415e750cfd1c8bd730783cf2aadeafa0?method=download&amp;shareKey=1a0f812fee9a129ac6972abb6a59a12d" alt="Transparent Scalability of CUDA Programs">
    </a><figcaption>Transparent Scalability of CUDA Programs</figcaption></figure></p>
<h2 id="44-warps-and-simd-hardware">4.4 Warps and SIMD Hardware</h2>
<p>当一个块被分配给一个 SM 时，它会被进一步划分为 32 个线程为一组的单元，称为 <em>warp</em>. 在 SMs 中，warp 是线程调度的单位。下图展示了一个划分的例子。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEBbc426e6de3199b6cd4706becd8760ec5?method=download&amp;shareKey=1c78a595dc3474b5fe3314455b89f2cc" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEBbc426e6de3199b6cd4706becd8760ec5?method=download&amp;shareKey=1c78a595dc3474b5fe3314455b89f2cc" alt="Blocks are Partitioned into Warps for Thread Scheduling">
    </a><figcaption>Blocks are Partitioned into Warps for Thread Scheduling</figcaption></figure></p>
<p>由多维度的线程组成的块，将被投影到线性化的行主布局中来划分。线性布局是以 (z, y, x) 坐标升序的方式排列。下图展示了一个大小为 4*4 块的线性化视图。前 4 个线程的 <code>threadIdx.y</code> 为 0，它们以 <code>threadIdx.x</code> 升序的方式排列。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEBd0a03a116716e7f5420af4be591a86ad?method=download&amp;shareKey=1d455651d0780cc68f3bfa1138a4b705" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEBd0a03a116716e7f5420af4be591a86ad?method=download&amp;shareKey=1d455651d0780cc68f3bfa1138a4b705" alt="Linear Layout of 2D Threads">
    </a><figcaption>Linear Layout of 2D Threads</figcaption></figure></p>
<p>SM 是单指令多数据 (SIMD) 模型，按顺序执行所有线程，<strong>warp 中的所有线程同时执行一条指令</strong>。下图展示了 SM 中的内核如何被分组为处理块，其中每 8 个内核构成一个处理块 (<em>processing block</em>) 并共享一个指令获取/调度单元。同一 warp 中的线程被分配到相同的处理块，该处理块获取指令并让 warp 中的所有线程对各自负责数据的部分执行该指令。这种设计允许较小比例的硬件专注于控制，而较大比例的硬件专注于提高计算吞吐量。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEB9402f58e22b5fbc96784b8fddd078fa6?method=download&amp;shareKey=cad59438c3ce64bf22e7f18cd0d9591c" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEB9402f58e22b5fbc96784b8fddd078fa6?method=download&amp;shareKey=cad59438c3ce64bf22e7f18cd0d9591c" alt="Processing Blocks Organization">
    </a><figcaption>Processing Blocks Organization</figcaption></figure></p>
<h2 id="45-control-divergence">4.5 Control divergence</h2>
<p>当同一 warp 中的线程执行不同的路径时，这些线程的行为被称作控制发散 (<em>control divergence</em>). 下图展示了一个 warp 在遇到分支语句时的执行方式，即通过两次 pass (执行代码的阶段) 来分别执行 then-path 和 else-path，最终实现所有线程的汇合。</p>
<ul>
<li>Pascal 及之前架构中，warp 需要顺序执行两个 pass，一个 pass 执行完才能开始下一个 pass。
<ul>
<li>Pass 1： 线程 0-23 执行 then-path 的代码 A，线程 24-31 处于 inactive 状态。</li>
<li>Pass 2： 线程 24-31 执行 else-path 的代码 B，线程 0-23 处于 inactive 状态。</li>
<li>Pass 3： 所有线程汇合，执行后续代码 C。</li>
</ul>
</li>
<li>Volta 及之后架构中，warp 可以同时执行两个 pass，不同的线程可以交错执行不同的代码路径。
<ul>
<li>Pass 1： 线程 0-23 开始执行 A 的第一个指令，线程 24-31 开始执行 B 的第一个指令。</li>
<li>Pass 2： 线程 0-23 执行 A 的第二个指令，线程 24-31 执行 B 的第二个指令。</li>
<li>&hellip;</li>
<li>Pass N： 线程 0-23 执行完 A 的所有指令，线程 24-31 执行完 B 的所有指令。</li>
<li>Pass N+1： 所有线程汇合，执行后续代码 C。</li>
</ul>
</li>
</ul>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEB2991b223f66252dc4c44389e5eb3fa54?method=download&amp;shareKey=cb1261dd30f5d7573db9be0049648223" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEB2991b223f66252dc4c44389e5eb3fa54?method=download&amp;shareKey=cb1261dd30f5d7573db9be0049648223" alt="Example of a Warp Diverging at an if-else Statement">
    </a><figcaption>Example of a Warp Diverging at an if-else Statement</figcaption></figure></p>
<p>发散也可能出现在其他控制流中。下图展示了 warp 如何执行发散 for 循环。通常来说如果判断条件基于 <code>threadIdx</code> 的值，那么控制语句可能会导致线程发散。由于线程总数需要是线程块大小的倍数，而数据大小可以是任意的，因此具有线程控制发散的控制流程很常见。由以上两个例子可以看出不能假设 warp 中的所有线程都具有相同的执行时间。如果 warp 中的所有线程都必须完成执行的一个阶段，然后才能继续前进，则必须使用 barrier 同步机制 (如 <code>__syncwarp()</code> )来确保正确性。</p>
<p>控制发散对性能的影响随着被处理向量大小的增加而减小。例如对于长度为 100 的向量，4个 warp 中有 1 个将会控制发散 (25%)；对于大小为1000的矢量，32 个 warp 中只有 1 个将会控制发散 (3.125%).</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEB46f65b52c565fcb503d299083c33932e?method=download&amp;shareKey=56a12c21eb2f91c9ac6b3e6cefc6a6df" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEB46f65b52c565fcb503d299083c33932e?method=download&amp;shareKey=56a12c21eb2f91c9ac6b3e6cefc6a6df" alt="Example of a Warp Diverging at a for-loop">
    </a><figcaption>Example of a Warp Diverging at a for-loop</figcaption></figure></p>
<h2 id="46-warp-scheduling-and-latency-tolerance">4.6 Warp scheduling and latency tolerance</h2>
<p>当将线程分配给 SMs 时，分配给 SM 的线程通常比 SM 中 core 的个数还要多，导致每个 SM 只能同时执行分配给它的所有线程的一部分。当要由 warp 执行的指令需要等待先前启动的操作的结果时，不会选择该 warp 执行。而是选择执行另一个不用等待先前指令结果的 warp。这种用其他线程的工作填充某些线程操作延迟时间的机制通常称为延迟容忍 (<em>latency tolerance</em>) 或者延迟隐藏 (<em>latency hiding</em>). 而选择准备执行的 warp 不会在执行时间线中引入任何空闲或浪费的时间的策略被称为零开销线程调度 (<em>zero-overhead thread scheduling</em>). 这种容忍长操作延迟的能力是 GPU 不像 CPU 那样为缓存和分支预测机制分配那么多芯片面积的主要原因，因此可以更专注于浮点数计算和内存读取。</p>
<details class="custom-details">
    <summary class="custom-summary">Threads, Context-switching, and Zero-overhead Scheduling</summary>
    <div>之前介绍过线程由程序的代码、正在执行的代码中的指令、变量的值和数据结构组成。在基于冯·诺伊曼模型的计算机中，程序的代码存储在存储器中。PC (Program Counter) 跟踪正在执行的程序指令的地址。IR (Instruction Register) 保存正在执行的指令。寄存器和内存保存变量和数据结构的值。
现代处理器的设计允许上下文切换 (<em>Context-switching</em>)，多个线程可以通过轮流执行的方式分时复用一个处理器。通过保存和恢复 PC 值以及寄存器和内存的内容，可以暂停线程的执行，并在稍后正确恢复线程的执行。不过保存和恢复寄存器内容可能会增加大量执行时间。
传统的 CPU 从一个线程切换到另一个线程需要将执行状态 (例如被切换线程的寄存器内容) 保存到<font color="red;"><strong>内存</strong></font>中，稍后再从内存中加载，这样会产生空闲周期。GPU SMs 通过在硬件<font color="red;"><strong>寄存器</strong></font>中保存指定 warp 的所有执行状态来实现零开销调度，因此不需要保存和恢复状态。</div>
</details><br>
<h2 id="47-resource-partitioning-and-occupancy">4.7 Resource partitioning and occupancy</h2>
<p>给 SM 分配其所支持的最大 warp 数并不总是可行。分配给 SM 的 warp 数量与其支持的 warp 数量之比称为占用率 (<em>occupancy</em>). 例如，Ampere A100 GPU 每个 SM 最多支持 32 个 block，每个 SM 最多支持 64 个 warp (2048 个线程)，每个 block 最多支持 1024 个线程。意味着块大小可以从 64<del>1024 不等，每个 SM 分别可以有 32</del>2 个块。在这些情况下，分配给SM的线程总数为2048，这使占用率最大化。
SM 中的执行资源包括寄存器、共享内存线程块槽 (每个 SM 最大能被分配的线程块数量) 和线程槽 (每个线程块最大能被分配的线程数量)，这些资源在线程之间动态分配。资源的动态分配可能导致他们之间相互制约，使得资源利用不足。</p>
<ul>
<li>硬件资源支持的影响。当每个块有32个线程时。Ampere A100 GPU 会将 2048 个线程槽分配给 64 个块。然而 Volta SM 只支持 32 个线程块槽，导致占用率只有 50%.</li>
<li>当每个块的最大线程数不能整除块大小时。当块大小为 768，SM 将只能容纳 2 个线程块 (1536个线程)，剩下512个线程槽未使用，占用率为 75%.</li>
<li>寄存器资源限制对占用率的影响。Ampere A100 GPU 允许每个 SM 最多占有 65,536个寄存器。为了达到满占用率每个线程不应该使用超过 32 个寄存器。
这种限制导致资源使用的轻微增加可能导致并行性和性能的显著降低，称为 performance cliff.</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>PMPP Learning-Chapter 5 Memory Architecture and Data Locality</title>
      <link>http://localhost:1313/blogs/courselearning/pmpp/pmpp-ch5/</link>
      <pubDate>Thu, 05 Sep 2024 09:18:11 +0800</pubDate>
      <guid>http://localhost:1313/blogs/courselearning/pmpp/pmpp-ch5/</guid>
      <description>Personal notebook 5 of Programming Massively Parallel</description>
      <content:encoded><![CDATA[<h1 id="5-memory-architecture-and-data-locality">5 Memory Architecture and Data Locality</h1>
<p>之前章节所写的 CUDA 内核只能达到底层硬件峰值算里的一小部分。因为全局内存 (通常使用片外 DRAM 实现) 往往具有较长的访问延迟 (数百个时钟周期) 和有限的访问带宽。</p>
<h2 id="51-importance-of--memory-access-efficiency">5.1 Importance of  Memory Access Efficiency</h2>
<p>在之前矩阵乘法的内核函数中，每次迭代里执行一次浮点乘法和一次浮点加法需要访问全局内存两次。因此，从全局内存访问的浮点操作次数 (FLOP) 与字节数 (B) 的比率为 2 FLOP-to-8 B，即 0.25FLOP/B. 计算访存比 (<em>compute to global memory access ratio</em>) 定义为在程序的一个区域内对全局内存访问的单位字节执行的 FLOPS 数。
计算访存比对 CUDA 内核的性能有重大影响。A100 GPU 的全局内存带宽峰值为 1555 GB/s，矩阵乘法内核计算访存比为 0.25 OP/B，因此内核可以执行的单精度 FLOPs 的吞吐量为 389 GFLOPS，仅为 A100 GPU 峰值单精度运算吞吐量 (19,500 GFLOPS) 的 2%. 我们把执行速度受内存带宽限制的程序称为内存瓶颈 (<em>memory bound</em>) 程序。</p>
<details class="custom-details">
    <summary class="custom-summary">Roofline Model</summary>
    <div><p>Rooline 模型用于评估应用程序相在其所运行的硬件的限制上达到的性能。如下图所示，x 轴表示算术或计算强度 (<em>computational intensity</em>)，单位为 FLOP/B. y 轴表示以 GFLOPS 为单位的计算吞吐量。横线表示硬件可以提供的峰值计算吞吐量。
硬件通常关注两个指标:</p>
<ul>
<li>算力 π：也称为计算平台的性能上限，指的是一个计算平台倾尽全力每秒钟所能完成的浮点运算数。单位是 FLOP/s。</li>
<li>带宽 ß：即计算平台的带宽上限，指的是一个计算平台倾尽全力每秒所能完成的内存交换量。单位是Byte/s。
两个指标相除即可得到计算平台的计算强度上限 I_max = π / ß，它描述的是在这个计算平台上，单位内存交换最多用来进行多少次计算。</li>
</ul>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEB6d519969c36c2ceb8f94fda0644c984a?method=download&amp;shareKey=f85b96fc7fa07712421487c9b01f7e1b" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEB6d519969c36c2ceb8f94fda0644c984a?method=download&amp;shareKey=f85b96fc7fa07712421487c9b01f7e1b" alt="Roofline Model">
    </a><figcaption>Roofline Model</figcaption></figure></p>
<p>从图中可以看出算力决定“屋顶”的高度（绿色线段），带宽决定“房檐”的斜率（红色线段）。</p>
<ul>
<li>Memory-Bound: 当模型的计算强度 I 小于硬件的计算强度上限 I_max 时，由于此时模型位于“房檐”区间，因此模型理论性能 P 的大小完全由硬件的带宽上限 ß （房檐的斜率）以及模型自身的计算强度 I 所决定，因此这时候就称模型处于 Memory-Bound 状态。</li>
<li>Compute-Bound: 不管模型的计算强度 I 有多大，它的理论性能 P 最大只能等于硬件的算力 π 。当模型的计算强度 I 大于硬件的计算强度上限 I_max 时，模型在当前硬件处于 Compute-Bound 状态</li>
</ul>
</div>
</details><br>
<p>为了让内核具有更高的性能，需要通过减少内核执行的全局内存访问次数来增加计算访存比。</p>
<h2 id="52-cuda-memory-types">5.2 CUDA memory types</h2>
<p>下图展示了 CUDA 设备的内存。全局内存和常量内存这两种类型的内存都可以被主机写入 (W) 和读取 (R) 。全局内存也可以被设备读写，而常量内存只支持设备对其读取。
另一种类型的内存是本地内存，也可以被读写。<strong>本地内存实际上放在全局内存中</strong>，具有相似的访问延迟，但它不是跨线程共享的。每个线程都有自己的全局内存部分，将其用作自己的私有本地内存，存放私有但不能在寄存器中分配的数据。
寄存器 (<em>register</em>) 和共享内存 (<em>shared memory</em>) 是片上内存。存储在这些类型内存中的变量可以以高度并行的方式以高速访问。其中每个线程只能访问自己的寄存器。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEB6b7cbeee7a8279269c480cc3dd307c92?method=download&amp;shareKey=c9a05598ffe57e76def11f1ea20593fa" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEB6b7cbeee7a8279269c480cc3dd307c92?method=download&amp;shareKey=c9a05598ffe57e76def11f1ea20593fa" alt="Overview of CUDA Memory Model">
    </a><figcaption>Overview of CUDA Memory Model</figcaption></figure></p>
<p>与基于冯·诺伊曼模型的计算机类比，CUDA 设备中的全局内存对应于内存框，寄存器对应于寄存器堆。与访问全局内存相比，每次访问寄存器所涉及的指令更少。当算术指令的操作数在寄存器中时，不需要额外的指令使算术逻辑单元(ALU)可以使用该操作数的值。如果操作数值在全局内存中，处理器需要执行内存加载操作让 ALU 能使用操作数。并且从寄存器堆访问所消耗的能量至少比从全局内存访问低一个数量级。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEB976785b7c8c819c9e53543306299645d?method=download&amp;shareKey=6af41bb3bef56687bcbe90e6d21f1204" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEB976785b7c8c819c9e53543306299645d?method=download&amp;shareKey=6af41bb3bef56687bcbe90e6d21f1204" alt="Memory vs. Registers in a Modern Computer Based on the von Neumann Model">
    </a><figcaption>Memory vs. Registers in a Modern Computer Based on the von Neumann Model</figcaption></figure></p>
<p>下图展示了 CUDA 设备中的共享内存和寄存器。共享内存实际上是一种暂存存储器 (<em>scratchpad memory</em>)，作为片上内存的一部分。当处理器访问存储在共享内存中的数据时，需要执行内存加载操作。CUDA 中共享内存和寄存器之间的一个重要区别是，存储在共享内存中的变量可以被块中的所有线程访问，而寄存器数据是线程私有的。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEB9683f5c9b3fdd69aa62d8c8751be45f7?method=download&amp;shareKey=62797256af4f18ce4ebf652d411de315" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEB9683f5c9b3fdd69aa62d8c8751be45f7?method=download&amp;shareKey=62797256af4f18ce4ebf652d411de315" alt="Shared Memory vs. Registers in a CUDA Device SM">
    </a><figcaption>Shared Memory vs. Registers in a CUDA Device SM</figcaption></figure></p>
<p>下表给出了将程序变量声明为各种内存类型的 CUDA 语法。</p>
<ul>
<li>所有在内核和设备函数中声明的 automatic scalar variables 都被放入寄存器中。</li>
<li>Automatic array variables 存储在线程的本地内存中。如果所有访问都使用常量索引值，编译器可能决定将将其存储到寄存器中。</li>
<li>块中的所有线程都看到 shared variable 的相同版本。内核执行期间每个块会创建和使用一个私有版本。通常使用共享变量来保存在内核执行阶段经常使用和重用的全局内存数据部分。</li>
<li>Constant variables 通常用于向核函数提供输入。内核函数不能修改常量变量的值。</li>
<li>Global variables 通常用于将信息从一个内核调用传递到另一个内核调用。</li>
</ul>
<table>
  <thead>
      <tr>
          <th>Variable Declaration</th>
          <th>Memory</th>
          <th>Scope</th>
          <th>Lifetime</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Automatic variables other than arrays</td>
          <td>Register</td>
          <td>Thread</td>
          <td>Kernel</td>
      </tr>
      <tr>
          <td>Automatic  array variables</td>
          <td>Local</td>
          <td>Thread</td>
          <td>Kernel</td>
      </tr>
      <tr>
          <td><code>__device__ __shared__ int SharedVar;</code></td>
          <td>Shared</td>
          <td>Block</td>
          <td>Kernel</td>
      </tr>
      <tr>
          <td><code>__device__ int GlobalVar;</code></td>
          <td>Global</td>
          <td>Grid</td>
          <td>Application</td>
      </tr>
      <tr>
          <td><code>__device__ __constant__ int ConstantVar;</code></td>
          <td>Constant</td>
          <td>Grid</td>
          <td>Application</td>
      </tr>
  </tbody>
</table>
<p>在 CUDA 中，指针可以用来指向全局内存中的数据对象，通常有以下两种情况会使用</p>
<ul>
<li>对象由主机函数分配，指向对象的指针由内存分配函数 (如 <code>cudaMalloc</code>) 初始化，作为参数传递给内核函数。</li>
<li>将在全局内存中声明的变量的地址赋给指针变量。</li>
</ul>
<h2 id="53-tiling-for-reduced-memory-traffic">5.3 Tiling for Reduced Memory Traffic</h2>
<p>一种常见的策略是将数据划分为称为 <em>tile</em> 的子集，以便每个 tile 都适合共享内存。能进行划分的一个重要的标准是这些 tile 上的内核计算可以彼此独立地完成。
下图展示了 block(0,0) 的四个线程所完成的计算。这四个线程计算P(0,0), P(0,1), P(1,0) 和 P(1,1). 每个线程在执行过程中访问 M 的 4 个元素和 N 的 4 个元素，可以看出有明显重复的部分。将每个块需要访问的数据先加载到共享内存，这样可以避免每个线程从全局内存里加载重复的数据。全局内存流量的减少与块的维度成正比。每个块大小为 Width*Width 时，全局内存流量将减少为原来的 1/Width.</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEB3ed7adc0960b337ea099f2d34a5474db?method=download&amp;shareKey=18100aa957fb01bf5f29920b908fd02f" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEB3ed7adc0960b337ea099f2d34a5474db?method=download&amp;shareKey=18100aa957fb01bf5f29920b908fd02f" alt="A Small Example of Matrix Multiplication">
    </a><figcaption>A Small Example of Matrix Multiplication</figcaption></figure></p>
<p>按 tile 进行矩阵乘法的基本思想是让线程在各自使用元素来进行内积计算之前，将 M 和 N 元素的子集加载到共享内存中。如下图所示把 M 和 N 分成大小为 <code>2*2</code> 的块。每个线程执行的内积计算现在被划分为几个阶段。在每个阶段，一个块中的所有线程协作将对应的 M 和 N 的 tile 加载到共享内存中。这样每个阶段关注的是输入矩阵元素的一个小子集。这种集中的访问行为称为局部性 (<em>locality</em>).</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEBae4e4638b9bd98256ba51c1f67530364?method=download&amp;shareKey=d9458ef5fa7b14ad19e1f0e72defa1b7" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEBae4e4638b9bd98256ba51c1f67530364?method=download&amp;shareKey=d9458ef5fa7b14ad19e1f0e72defa1b7" alt="Tiling M and N to Utilize Shared Memory">
    </a><figcaption>Tiling M and N to Utilize Shared Memory</figcaption></figure></p>
<h2 id="54-a-tiled-matrix-multiplication-kernel">5.4 A Tiled Matrix Multiplication Kernel</h2>
<p>按照上述方法编写的内核函数如下。如下图所示，x 轴方向上坐标为 bx 和 tx 的线程应该负责计算 P 中索引为 <code>bx * tile_width + tx</code> 元素。类似地，y 轴方向上线程要处理的 P 中索引为 <code>by * tile_width + ty</code>. 外循环的每次迭代对应于计算的一个阶段。两次调用 <code>__syncthreads()</code> 的原因不同，第一次被称为写后读 (<em>read-after-write</em>) 依赖关系，因为线程在尝试读取数据之前必须等待其他线程将数据写入正确的位置。第二种被称为读后写 (<em>write-after-read</em>) 依赖，因为线程必须等待所有需要它的线程读取数据，然后才能覆盖它。</p>
<p>写后读依赖是一种真正依赖 (<em>true dependence</em>)，因为读线程确实需要写线程提供的数据，所以它别无选择，只能等待。读后写依赖关系是伪依赖 (<em>false dependence</em>) 关系，因为写线程不需要来自读线程的任何数据。这种依赖性是因为它们访问相同的内存地址，如果它们访问不同的地址，则不存在这种依赖性。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">__global__</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">TilingMatrixMulKernel</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span> <span class="n">M</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">N</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">P</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">__shared__</span> <span class="kt">float</span> <span class="n">Mds</span><span class="p">[</span><span class="n">TILE_WIDTH</span><span class="p">][</span><span class="n">TILE_WIDTH</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="n">__shared__</span> <span class="kt">float</span> <span class="n">Nds</span><span class="p">[</span><span class="n">TILE_WIDTH</span><span class="p">][</span><span class="n">TILE_WIDTH</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">bx</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>  <span class="kt">int</span> <span class="n">by</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">tx</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span> <span class="kt">int</span> <span class="n">ty</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Identify the row and column of the P element to work on
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">int</span> <span class="n">Row</span> <span class="o">=</span> <span class="n">by</span> <span class="o">*</span> <span class="n">TILE_WIDTH</span> <span class="o">+</span> <span class="n">ty</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">Col</span> <span class="o">=</span> <span class="n">bx</span> <span class="o">*</span> <span class="n">TILE_WIDTH</span> <span class="o">+</span> <span class="n">tx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kt">float</span> <span class="n">Pvalue</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Loop over the M and N tiles required to compute the P elemrnt
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">ph</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ph</span> <span class="o">&lt;</span> <span class="n">width</span><span class="o">/</span><span class="n">TILE_WIDTH</span><span class="p">;</span> <span class="n">ph</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Collaborative loading of M and N tiles into shared memory
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">Mds</span><span class="p">[</span><span class="n">ty</span><span class="p">][</span><span class="n">tx</span><span class="p">]</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="n">Row</span> <span class="o">*</span> <span class="n">width</span> <span class="o">+</span> <span class="n">ph</span> <span class="o">*</span> <span class="n">TILE_WIDTH</span> <span class="o">+</span> <span class="n">tx</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">		<span class="n">Nds</span><span class="p">[</span><span class="n">ty</span><span class="p">][</span><span class="n">tx</span><span class="p">]</span> <span class="o">=</span> <span class="n">N</span><span class="p">[(</span><span class="n">ph</span> <span class="o">*</span> <span class="n">TILE_WIDTH</span> <span class="o">+</span> <span class="n">ty</span><span class="p">)</span> <span class="o">*</span> <span class="n">width</span> <span class="o">+</span> <span class="n">Col</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">		<span class="n">__syncthreads</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">TILE_WIDTH</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">Pvalue</span> <span class="o">+=</span> <span class="n">Mds</span><span class="p">[</span><span class="n">ty</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">Nds</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">tx</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="n">__syncthreads</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">		<span class="n">P</span><span class="p">[</span><span class="n">Row</span> <span class="o">*</span> <span class="n">width</span> <span class="o">+</span> <span class="n">Col</span><span class="p">]</span> <span class="o">=</span> <span class="n">Pvalue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Tiling 技术并不是 GPU 上才能实现。CPU 上的 tiling 依赖缓存来将重用的数据保留在芯片上，而 GPU 上的 tiling 则直接地使用共享内存来存储片上数据。CPU 核心通常只运行一个或两个线程，因此线程可以依赖于缓存来保存最近使用的数据。相反，GPU SM 同时运行多个线程以隐藏延迟，些线程会竞争缓存槽，使得 GPU 缓存不太可靠。</p>
<h2 id="55-boundary-checks">5.5 Boundary Checks</h2>
<p>我们需要扩展 tiling 矩阵乘法内核使其处理任意大小的矩阵。下图展示了 block(0,0) 在 phase 1 的内存访问模式。在不进行边界检查时 thead(0,1) 试图访问 M(0,3) 时实际上获得的是 M(1,0). 同样在 Block(1,1) 在 phase 0 访问时也会出现类似的问题。因此在加载所需的 M 和 N 的 tile 时边界条件为两个索引都小于 Width: <code>Row &lt; Width &amp;&amp; (ph * TILE_WIDT + tx) &lt; Width</code>，否则将 0.0f 存入对应位置。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEB3510a9da44c7c085a52a178e1a9f1381?method=download&amp;shareKey=ba4ad85a9a2fa48d75e5911e34f0342e" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEB3510a9da44c7c085a52a178e1a9f1381?method=download&amp;shareKey=ba4ad85a9a2fa48d75e5911e34f0342e" alt="Memory Access of Block(0,0) in Phase 1">
    </a><figcaption>Memory Access of Block(0,0) in Phase 1</figcaption></figure></p>
<p>扩展为一般的矩阵乘法内核是很容易的。将 Width 参数替换为三个无符号整数参数: m, k, n; 将用于指代 M 的行数/列数和 P 的行数/列数的 Width 替换为 m/n；将用于指代 M 的列数和 P 的行数的 Width 替换为 k. 修改后代码如下</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEB4072b51d6111b15f740c4efb83237a0f?method=download&amp;shareKey=629c82b8ccd78e137a597b5a3e364c4b" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEB4072b51d6111b15f740c4efb83237a0f?method=download&amp;shareKey=629c82b8ccd78e137a597b5a3e364c4b" alt="Calculation of the Matrix Indexes in Tiled Multiplication">
    </a><figcaption>Calculation of the Matrix Indexes in Tiled Multiplication</figcaption></figure></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">__global__</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">GEMMKernel</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span> <span class="n">M</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">N</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">P</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">__shared__</span> <span class="kt">float</span> <span class="n">Mds</span><span class="p">[</span><span class="n">TILE_WIDTH</span><span class="p">][</span><span class="n">TILE_WIDTH</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="n">__shared__</span> <span class="kt">float</span> <span class="n">Nds</span><span class="p">[</span><span class="n">TILE_WIDTH</span><span class="p">][</span><span class="n">TILE_WIDTH</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">bx</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>  <span class="kt">int</span> <span class="n">by</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">tx</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span> <span class="kt">int</span> <span class="n">ty</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Identify the row and column of the P element to work on
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">int</span> <span class="n">Row</span> <span class="o">=</span> <span class="n">by</span> <span class="o">*</span> <span class="n">TILE_WIDTH</span> <span class="o">+</span> <span class="n">ty</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">Col</span> <span class="o">=</span> <span class="n">bx</span> <span class="o">*</span> <span class="n">TILE_WIDTH</span> <span class="o">+</span> <span class="n">tx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kt">float</span> <span class="n">Pvalue</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Loop over the M and N tiles required to compute the P element
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">ph</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ph</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="n">TILE_WIDTH</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">TILE_WIDTH</span><span class="p">;</span> <span class="n">ph</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Collaborative loading of M and N tiles into shared memory
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">Row</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="o">&amp;&amp;</span> <span class="n">ph</span> <span class="o">*</span> <span class="n">TILE_WIDTH</span> <span class="o">+</span> <span class="n">tx</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">Mds</span><span class="p">[</span><span class="n">ty</span><span class="p">][</span><span class="n">tx</span><span class="p">]</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="n">Row</span> <span class="o">*</span> <span class="n">k</span> <span class="o">+</span> <span class="n">ph</span> <span class="o">*</span> <span class="n">TILE_WIDTH</span> <span class="o">+</span> <span class="n">tx</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">Mds</span><span class="p">[</span><span class="n">ty</span><span class="p">][</span><span class="n">tx</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">ph</span> <span class="o">*</span> <span class="n">TILE_WIDTH</span> <span class="o">+</span> <span class="n">ty</span> <span class="o">&lt;</span> <span class="n">k</span> <span class="o">&amp;&amp;</span> <span class="n">Col</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">Nds</span><span class="p">[</span><span class="n">ty</span><span class="p">][</span><span class="n">tx</span><span class="p">]</span> <span class="o">=</span> <span class="n">N</span><span class="p">[(</span><span class="n">ph</span> <span class="o">*</span> <span class="n">TILE_WIDTH</span> <span class="o">+</span> <span class="n">ty</span><span class="p">)</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="n">Col</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">Nds</span><span class="p">[</span><span class="n">ty</span><span class="p">][</span><span class="n">tx</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="n">__syncthreads</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TILE_WIDTH</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">Pvalue</span> <span class="o">+=</span> <span class="n">Mds</span><span class="p">[</span><span class="n">ty</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">Nds</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">tx</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="n">__syncthreads</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">Row</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="o">&amp;&amp;</span> <span class="n">Col</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">P</span><span class="p">[</span><span class="n">Row</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="n">Col</span><span class="p">]</span> <span class="o">=</span> <span class="n">Pvalue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="56-impact-of-memory-usage-on-occupancy">5.6 Impact of Memory Usage on Occupancy</h2>
<p>CUDA 设备提供有限的资源限制了可以同时在给定程序的 SM 中分配的线程数量。上面代码不支持主机代码对共享内存使用情况的任何动态调整，因为共享内存使用的大小是一个常量。
解决的方法是共享内存声明前添加一个 <code>extern</code> 关键字，并在声明中省略数组的大小。当调用内核时，可以根据设备查询结果动态配置每个块要使用的共享内存量，并将其作为第三个执行配置参数提供给内核调用。然后将数组中每个部分的大小作为参数传递给内核函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">size</span> <span class="o">=</span> <span class="p">...;</span>
</span></span><span class="line"><span class="cl"><span class="n">matrixMulKernel</span><span class="o">&lt;&lt;&lt;</span><span class="n">dimGrid</span><span class="p">,</span><span class="n">dimBlock</span><span class="p">,</span><span class="n">size</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">Md</span><span class="err">，</span><span class="n">Nd</span><span class="err">，</span><span class="n">Pd</span><span class="p">,</span> <span class="n">Width</span><span class="err">，</span><span class="n">size</span><span class="o">/</span><span class="mi">2</span><span class="err">，</span><span class="n">size</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">__global__</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">matrixMulKernel</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span> <span class="n">M</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">N</span><span class="p">,</span><span class="kt">float</span><span class="o">*</span> <span class="n">P</span><span class="p">,</span><span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">Mdz_sz</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">Nds_sz</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">extern</span> <span class="n">__shared__</span> <span class="kt">char</span> <span class="kt">float</span> <span class="n">Mds_Nds</span><span class="p">[];</span>
</span></span><span class="line"><span class="cl">    <span class="kt">float</span> <span class="o">*</span><span class="n">Mds</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span> <span class="o">*</span><span class="p">)</span> <span class="n">Mds_Nds</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">float</span> <span class="o">*</span><span class="n">Nds</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span> <span class="n">Mds_Nds</span> <span class="o">+</span> <span class="n">Mds_sz</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div>]]></content:encoded>
    </item>
    <item>
      <title>PMPP Learning-Chapter 3 Multidimensional Grids and Data</title>
      <link>http://localhost:1313/blogs/courselearning/pmpp/pmpp-ch3/</link>
      <pubDate>Wed, 04 Sep 2024 21:57:11 +0800</pubDate>
      <guid>http://localhost:1313/blogs/courselearning/pmpp/pmpp-ch3/</guid>
      <description>Personal notebook 3 of Programming Massively Parallel</description>
      <content:encoded><![CDATA[<h1 id="3-multidimensional-grids-and-data">3 Multidimensional Grids and Data</h1>
<p>本章将更广泛地介绍线程是如何组织的和如何使用线程和块来处理多维数组。</p>
<h2 id="31-multidimensional-grid-organization">3.1 Multidimensional Grid Organization</h2>
<p>再次强调<strong>网格中的所有线程执行相同的内核函数</strong>，它们依赖于线程索引来区分彼此，并确定各自要处理的数据的部分。这些线程被组织成两级结构: 一个网格由一个或多个块组成，每个块由一个或多个线程组成。调用内核函数时需要指定执行配置参数 <code>gridDim</code> 和 <code>blockDim</code>，<code>gridDim</code> 是一个三维块数组，<code>blockDim</code> 是一个三维线程数组。他们的类型都是 <code>dim3</code>，是包含三个元素 x, y 和 z 的整数向量类型，分别指定了每个维度上的块个数和线程个数。使用少于 3 个维度时可以将未使用的维度大小设置为 1。网格中的所有块都具有相同的维度和大小。<strong>一旦网格启动，网格和块的尺寸将保持不变，直到整个网格完成执行。</strong></p>
<p><strong>当前 CUDA 系统中，每个块的总大小限制为 1024 个线程。只要线程总数不超过 1024，这些线程就可以以任何方式分布在三个维度上。</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">function_name</span><span class="o">&lt;&lt;&lt;</span><span class="n">gridDim</span><span class="p">,</span> <span class="n">blockDim</span><span class="o">&gt;&gt;&gt;</span><span class="p">(...);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>一个例子如下，dimBlock和dimGrid是由程序员定义的主机代码变量。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">dim3</span> <span class="nf">dimGrid</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">dim3</span> <span class="nf">dimBlock</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">vecAddKernel</span><span class="o">&lt;&lt;&lt;</span><span class="n">dimGrid</span><span class="p">,</span> <span class="n">dimBlock</span><span class="o">&gt;&gt;&gt;</span><span class="p">(...);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>下图展示了 <code>gridDim(2,2,1)</code> 和 <code>blockDim (4,2,2)</code> 情况下线程组织的情况。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEBcbb93fc419f4d6121d02e091d5666989?method=download&amp;shareKey=e6560d2a922f6a2c322706cb282ac70f" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEBcbb93fc419f4d6121d02e091d5666989?method=download&amp;shareKey=e6560d2a922f6a2c322706cb282ac70f" alt="A Multidimensional Example of CUDA Grid Organization">
    </a><figcaption>A Multidimensional Example of CUDA Grid Organization</figcaption></figure></p>
<h2 id="32-mapping-threads-to-multidimensional-data">3.2 Mapping threads to multidimensional data</h2>
<p>选择 1D、2D 或 3D 的线程组织通常基于数据的性质。例如图像是一个二维像素数组。使用由 2D 块组成的 2D 网格可以方便地处理图像中的像素。下图展示了处理大小为 <code>62*76</code> 1F1F 的图片 P 的一种组织方式。假设使用 <code>16*16</code> 大小的块，那么在 y 方向上需要 4 个块，在 x 方向上需要 5 个块。横纵坐标的计算方式为</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-plaintext" data-lang="plaintext"><span class="line"><span class="cl">row coordinate = blockIdx.y * blockDim.y + threadIdx.y
</span></span><span class="line"><span class="cl">col coordinate = blockIdx.x * blockDim.x + threadIdx.x
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们将按维度的降序 <code>(z, y, x)</code> 表示多维数据。这种顺序与 <code>gridDim</code> 和 <code> blockDim</code> 维度中数据维度的顺序相反！！！</p>
<p>实际上，由于现代计算机中使用二维存储空间，C 语言中的所有多维数组都是线性化的。虽然可以使用如 <code>Pin_d[j][i]</code> 这样的多维数组语法访问多维数组的元素，但编译器将这些访问转换为指向数组开始元素的基指针，以及从这些多维索引计算出的一维偏移量。
至少有两种方法可以对二维数组进行线性化。将同一行/列的所有元素放置到连续的位置。然后将行/列一个接一个地放入内存空间中。这种排列称为行/列主序布局 (<em>row/column-major layout</em>). <strong>CUDA C 使用行主序布局。</strong></p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEB7aab5f499364badca84a8cf76a1793fb?method=download&amp;shareKey=7df12b5fb5eae00c962e1a3ff98dabec" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEB7aab5f499364badca84a8cf76a1793fb?method=download&amp;shareKey=7df12b5fb5eae00c962e1a3ff98dabec" alt="Row-major Layout for a 2D C Array">
    </a><figcaption>Row-major Layout for a 2D C Array</figcaption></figure></p>
<p>下面内核代码将每个颜色像素转换为对应的灰度像素。我们计算坐标为 <code>(row, col)</code> 的像素对应的 1D 索引 <code>row * width + col</code>. 这个 1D 索引 <code>grayOffset</code> 就是 <code>Pout</code> 的像素索引，因为输出灰度图像中的每个像素都是 1字节 (unsigned char)。每个彩色像素用三个元素(r, g, b)存储，每个元素为1字节。因此 <code>rgbOffset</code> 给出了 <code>Pin</code> 数组中颜色像素的起始位置。从 <code>Pin</code> 数组的三个连续字节位置读取每个通道对应的值，执行灰度像素值的计算，并使用 <code> grayOffset</code> 将该值写入 <code>Pout</code> 数组。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// we have 3 channels corresponding to RGB
</span></span></span><span class="line"><span class="cl"><span class="c1">// The input image is encoded as unsigned characters [0, 255]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">__global__</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">colorToGreyscaleConversion</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">Pout</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">                                <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">Pin</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">Col</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">Row</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">Col</span> <span class="o">&lt;</span> <span class="n">width</span> <span class="o">&amp;&amp;</span> <span class="n">Row</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// get 1D coordinate for the grayscale image
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">greyOffset</span> <span class="o">=</span> <span class="n">Row</span><span class="o">*</span><span class="n">width</span> <span class="o">+</span> <span class="n">Col</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// one can think of the RGB image having
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// CHANNEL times columns than the grayscale image
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">rgbOffset</span> <span class="o">=</span> <span class="n">greyOffset</span><span class="o">*</span><span class="n">CHANNELS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">r</span> <span class="o">=</span> <span class="n">Pin</span><span class="p">[</span><span class="n">rgbOffset</span> <span class="o">+</span> <span class="mi">0</span><span class="p">];</span> <span class="c1">// red value for pixel
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">g</span> <span class="o">=</span> <span class="n">Pin</span><span class="p">[</span><span class="n">rgbOffset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span> <span class="c1">// green value for pixel
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">b</span> <span class="o">=</span> <span class="n">Pin</span><span class="p">[</span><span class="n">rgbOffset</span> <span class="o">+</span> <span class="mi">2</span><span class="p">];</span> <span class="c1">// blue value for pixel
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      
</span></span><span class="line"><span class="cl">        <span class="c1">// perform the rescaling and store it
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// We multiply by floating point constants
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Pout</span><span class="p">[</span><span class="n">grayOffset</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.21f</span><span class="o">*</span><span class="n">r</span> <span class="o">+</span> <span class="mf">0.71f</span><span class="o">*</span><span class="n">g</span> <span class="o">+</span> <span class="mf">0.07f</span><span class="o">*</span><span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="33-image-blur-a-more-complex-kernel">3.3 Image blur: a more complex kernel</h2>
<p>图像模糊函数将输出图像像素的值计算为相邻像素 (包括输入图像中像素) 的加权和。简便起见，我们使用相邻像素的平均值来计算结果，对应的代码如下。与 <code>colorToGrayscaleConversion</code> 中使用的策略类似，对每个输出像素使用 1 个线程来计算。<code>col</code>和 <code>row</code> 表示输入像素 patch 的中心像素位置。嵌套的 <code>for</code> 循环遍历 patch 中的所有像素。<code>if</code> 语句的 <code>curRow &lt; 0</code> 和 <code>curCol &lt; 0</code> 条件用于跳过执行超出图像范围的部分。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">__global__</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">blurKernel</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">Col</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">Row</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">Col</span> <span class="o">&lt;</span> <span class="n">width</span> <span class="o">&amp;&amp;</span> <span class="n">Row</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">pixVal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">pixels</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// Get the average of the surrounding BLUR_SIZE x BLUR_SIZE box
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">blurRow</span> <span class="o">=</span> <span class="o">-</span><span class="n">BLUR_SIZE</span><span class="p">;</span> <span class="n">blurRow</span> <span class="o">&lt;</span> <span class="n">BLUR_SIZE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">blurRow</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">blurCol</span> <span class="o">=</span> <span class="o">-</span><span class="n">BLUR_SIZE</span><span class="p">;</span> <span class="n">blurCol</span> <span class="o">&lt;</span> <span class="n">BLUR_SIZE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">blurCol</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="kt">int</span> <span class="n">curRow</span> <span class="o">=</span> <span class="n">Row</span> <span class="o">+</span> <span class="n">blurRow</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="kt">int</span> <span class="n">curCol</span> <span class="o">=</span> <span class="n">Col</span> <span class="o">+</span> <span class="n">blurCol</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">              
</span></span><span class="line"><span class="cl">                <span class="c1">// If the pixel is within the image, add its value to the sum
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">if</span><span class="p">(</span><span class="n">curRow</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">curRow</span> <span class="o">&lt;</span> <span class="n">height</span> <span class="o">&amp;&amp;</span> <span class="n">curCol</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">curCol</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">pixVal</span> <span class="o">+=</span> <span class="n">in</span><span class="p">[</span><span class="n">curRow</span><span class="o">*</span><span class="n">width</span> <span class="o">+</span> <span class="n">curCol</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                    <span class="n">pixels</span><span class="o">++</span><span class="p">;</span> <span class="c1">// Keep track of the number of pixels in the avg
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Write our new pixel value out
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">out</span><span class="p">[</span><span class="n">Row</span><span class="o">*</span><span class="n">width</span> <span class="o">+</span> <span class="n">Col</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)(</span><span class="n">pixVal</span> <span class="o">/</span> <span class="n">pixels</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="34-matrix-multiplication">3.4 Matrix multiplication</h2>
<p>矩阵乘法是 Basic Linear Algebra Subprograms (BLAS) 的重要组成部分。</p>
<ul>
<li>Level 1 形如 $y = \alpha x + y$  的向量运算。</li>
<li>Level 2 形如  $y = \alpha Ax + \beta y$  的矩阵-向量运算。</li>
<li>Level 3 形如  $y = \alpha AB + \beta C$ 的矩阵-矩阵运算。</li>
</ul>
<p>为了用 CUDA 实现矩阵乘法，我们可以采取与 colorToGrayscaleConversion 相同的方法将网格中的线程映射到输出矩阵 P 的元素，即每个线程负责计算 P 中的一个元素。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// Assuming square matrices of size Width x Width
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">__global__</span> 
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">MatrixMulKernel</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span> <span class="n">M</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">N</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">P</span><span class="p">,</span> <span class="kt">int</span> <span class="n">Width</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Calculate the row index of the P element and M
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">Row</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">y</span><span class="o">*</span><span class="n">blockDim</span><span class="p">.</span><span class="n">y</span><span class="o">+</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Calculate the column index of P and N
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">Col</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="o">*</span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="o">+</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">((</span><span class="n">Row</span> <span class="o">&gt;=</span> <span class="n">Width</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">Col</span> <span class="o">&gt;=</span> <span class="n">Width</span><span class="p">))</span> <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">float</span> <span class="n">Pvalue</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// each thread computes one element of the block sub-matrix
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">Width</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">Pvalue</span> <span class="o">+=</span> <span class="n">M</span><span class="p">[</span><span class="n">Row</span><span class="o">*</span><span class="n">Width</span><span class="o">+</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">N</span><span class="p">[</span><span class="n">k</span><span class="o">*</span><span class="n">Width</span><span class="o">+</span><span class="n">Col</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">P</span><span class="p">[</span><span class="n">Row</span><span class="o">*</span><span class="n">Width</span><span class="o">+</span><span class="n">Col</span><span class="p">]</span> <span class="o">=</span> <span class="n">Pvalue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEBb16353405dede29b1f85c4c05008cda6?method=download&amp;shareKey=6ffa3c49a5c8db350dd70df1f42dd2de" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEBb16353405dede29b1f85c4c05008cda6?method=download&amp;shareKey=6ffa3c49a5c8db350dd70df1f42dd2de" alt="Matrix Multiplication by Tiling P">
    </a><figcaption>Matrix Multiplication by Tiling P</figcaption></figure></p>
]]></content:encoded>
    </item>
    <item>
      <title>PMPP Learning-Chapter 2 Heterogeneous Data Parallel</title>
      <link>http://localhost:1313/blogs/courselearning/pmpp/pmpp-ch2/</link>
      <pubDate>Tue, 03 Sep 2024 22:48:12 +0800</pubDate>
      <guid>http://localhost:1313/blogs/courselearning/pmpp/pmpp-ch2/</guid>
      <description>Personal notebook 2 of Programming Massively Parallel</description>
      <content:encoded><![CDATA[<h1 id="2-heterogeneous-data-parallel-computing">2 Heterogeneous Data Parallel Computing</h1>
<p>数据并行 (<em>Data Parallel</em>) 是指在数据集的不同部分上执行的计算工作可以彼此独立地完成，从而可以并行执行的现象。</p>
<h2 id="21-data-parallel">2.1 Data Parallel</h2>
<p>在图像处理中，将彩色像素转换为灰度只需要该像素的数据。模糊图像将每个像素的颜色与附近像素的颜色平均，只需要像素的小邻域的数据。即使是一个看似全局的操作，比如找到图像中所有像素的平均亮度，也可以分解成许多可以独立执行的较小的计算。这种对不同数据块的独立计算是数据并行性的基础。
为了将彩色图像转换为灰度图像，我们通过以下加权和公式计算每个像素的亮度值L. 这些逐像素计算都不依赖于彼此，都可以独立执行。显然，彩色图到灰度图的转换具有大量的数据并行性。
$L=0.21r+0.72g+0.07b$</p>
<details class="custom-details">
    <summary class="custom-summary">Task Parallelism vs. Data Parallelism</summary>
    <div>数据并行并不是并行编程中使用的唯一类型的并行。任务并行 (<em>Task Parallelism</em>) 在并行编程中也得到了广泛的应用。任务并行性通常通过应用程序的任务分解来暴露。例如，一个简单的应用程序可能需要做一个向量加法和一个矩阵-向量乘法。每个都是一个任务。如果两个任务可以独立完成，则存在任务并行性。I/O和数据传输也是常见的任务。</div>
</details><br>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEB56d71b169d207ac51adc718f79fb006c?method=download&amp;shareKey=d97c1f60eb44182ac8bb99f8a81035fe" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEB56d71b169d207ac51adc718f79fb006c?method=download&amp;shareKey=d97c1f60eb44182ac8bb99f8a81035fe" alt="Data Parallelsim in Image2Grayscale Conversion">
    </a><figcaption>Data Parallelsim in Image2Grayscale Conversion</figcaption></figure></p>
<h2 id="22-cuda-c-program-structure">2.2 CUDA C Program Structure</h2>
<p>CUDA C 用最少的新语法和库函数扩展了流行的 ANSI C 语言。CUDA C 程序的结构反映了计算机中主机 (CPU) 和一个或多个设备 (GPU) 的共存。每个 CUDA C 源文件可以同时包含主机 (<em>host</em>) 代码和设备 (<em>device</em>) 代码。
CUDA程序的执行流程如下图所示。执行从主机代码 (CPU 串行代码) 开始，当调用内核函数 (<em>kernel function</em>) 时，会在设备上启动大量线程<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>来执行内核。由内核调用启动的所有线程统称为网格 (grid)。这些线程是 CUDA 并行执行的主要载体。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEBcfe42671ed5897d29371195eb557fa00?method=download&amp;shareKey=2d501a2775f21e11292189f68d89e39a" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEBcfe42671ed5897d29371195eb557fa00?method=download&amp;shareKey=2d501a2775f21e11292189f68d89e39a" alt="Execution of a CUDA Program">
    </a><figcaption>Execution of a CUDA Program</figcaption></figure></p>
<h2 id="23-a-vector-addition-kernel">2.3 A vector addition kernel</h2>
<p>使用向量加法来展示 CUDA C 程序结构。下面展示了一个简单的传统 C 程序，它由一个主函数和一个向量加法函数组成。</p>
<p>当需要区分主机和设备数据时，我们都会在主机使用的变量名后面加上 “<code>_h</code>”，而在设备使用的变量名后面加上 “<code>_d</code>”.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// Compute vector sum h_C = h_A+h_B
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">vecAdd</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span> <span class="n">h_A</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">h_B</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">h_C</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">h_C</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">h_A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">h_B</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Memory allocation for h_A, h_B, and h_C
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// I/O to read h_A and h_B, N elements each
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// …
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">vecAdd</span><span class="p">(</span><span class="n">h_A</span><span class="p">,</span> <span class="n">h_B</span><span class="p">,</span> <span class="n">h_C</span><span class="p">,</span> <span class="n">N</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>并行执行向量加法的一种直接方法是修改 <code>vecAdd</code> 函数并将其计算移到设备上。修改后的结构如下所示。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEB1aadc269025d2f33b2bd42b7838c7cc3?method=download&amp;shareKey=04dc8aeb81948f9dd66f6dccb54e8bd5" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEB1aadc269025d2f33b2bd42b7838c7cc3?method=download&amp;shareKey=04dc8aeb81948f9dd66f6dccb54e8bd5" alt="Structure of the Modified VecAdd">
    </a><figcaption>Structure of the Modified VecAdd</figcaption></figure></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cuda_runtime.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// …
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">vecAdd</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span> <span class="n">A</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">B</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">C</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">n</span><span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">float</span> <span class="o">*</span><span class="n">d_A</span> <span class="o">*</span><span class="n">d_B</span><span class="p">,</span> <span class="o">*</span><span class="n">d_C</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">    …
</span></span></span><span class="line"><span class="cl"><span class="cm">    1. // Allocate device memory for A, B, and C
</span></span></span><span class="line"><span class="cl"><span class="cm">       // copy A and B to device memory
</span></span></span><span class="line"><span class="cl"><span class="cm">    2. // Kernel launch code – to have the device
</span></span></span><span class="line"><span class="cl"><span class="cm">       // to perform the actual vector addition
</span></span></span><span class="line"><span class="cl"><span class="cm">    3. // copy C from the device memory
</span></span></span><span class="line"><span class="cl"><span class="cm">       // Free device vectors
</span></span></span><span class="line"><span class="cl"><span class="cm">    */</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="24-device-global-memory-and-data-transfer">2.4 Device Global Memory and Data Transfer</h2>
<p>在当前的CUDA系统中，设备通常是带有自己的 DRAM 的硬件卡，称为 (设备)全局内存 (<em>device global memory</em>). 对于向量加法内核，在调用内核之前，程序员需要在设备全局内存中分配空间，并将数据从主机内存传输到设备全局内存中分配的空间。这对应于 1. 部分。类似地，在设备执行之后，程序员需要将结果数据从设备全局内存传输回主机内存，并释放设备全局内存中不再需要的已分配空间。这对应于 3. 部分。
<code>cudaMalloc</code> 函数可以从主机代码中调用，为对象分配一块设备全局内存。第一个参数是指针变量的地址，该变量将被设置为指向分配的对象。指针变量的地址应强制转换为 <code>void**</code>，这样可以允许 <code>cudaMalloc</code> 函数将分配内存的地址写入所提供的指针变量中，而不考虑其类型<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">cudaError_t</span> <span class="nf">cudaMalloc</span><span class="p">(</span><span class="kt">void</span><span class="o">**</span> <span class="n">devPtr</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">size</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><code>devPtr</code>：指向指向设备内存的指针的指针。</li>
<li><code>size</code>：要分配的内存大小（以字节为单位）。</li>
</ul>
<hr>
<p>cudaFree 函数通过释放设备内存并将其返回到可用内存池来管理设备内存资源。它只需要 A_d 的值来识别要释放的内存区域，而不需要改变 A_d 指针本身的地址。</p>
<p>在主机代码中对设备全局内存指针进行解引用引用可能导致异常或其他类型的运行错误。</p>
<p>cudaMemcpy 函数是 CUDA 中用于在主机内存和设备内存之间传输数据的核心函数。它允许将数据从主机内存复制到设备内存，或从设备内存复制到主机内存。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">cudaError_t</span> <span class="nf">cudaMemcpy</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">src</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">cudaMemcpyKind</span> <span class="n">kind</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><code>dst</code>：目标内存地址，可以是主机内存地址或设备内存地址。</li>
<li><code>src</code>： 源内存地址，可以是主机内存地址或设备内存地址。</li>
<li><code>count</code>： 要复制的数据大小（以字节为单位）。</li>
<li><code>kind</code>： 复制方向，可以使用<a href="https://docs.nvidia.com/cuda/cuda-runtime-api/group__CUDART__TYPES.html#group__CUDART__TYPES_1g18fa99055ee694244a270e4d5101e95b">以下枚举值</a>：
<ul>
<li><code>cudaMemcpyHostToDevice</code>：主机内存-&gt;设备内存。</li>
<li><code>cudaMemcpyDeviceToHost</code>：设备内存-&gt;主机内存。</li>
<li><code>cudaMemcpyDeviceToDevice</code>：设备内存-&gt;设备内存。</li>
<li><code>cudaMemcpyHostToHost</code>：主机内存-&gt;主机内存</li>
</ul>
</li>
</ul>
<p>了解完这些后，可以更新代码的框架如下</p>
<details class="custom-details">
    <summary class="custom-summary">Checking and Handling in CUDA</summary>
    <div><p>CUDA API 函数返回一个 <code>cudaError_t</code> 类型的标志，指示当它们处理请求时是否发生错误。
在 CUDA 运行时库的头文件 cuda_runtime.h 中，cudaError_t 被定义为一个 int 类型的别名</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="kt">int</span> <span class="n">cudaError_t</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>一个例子如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">float</span> <span class="o">*</span><span class="n">d_a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">cudaError_t</span> <span class="n">err</span> <span class="o">=</span> <span class="n">cudaMalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d_a</span><span class="p">,</span> <span class="mi">1024</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="n">cudaSuccess</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;cudaMalloc failed: %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">cudaGetErrorString</span><span class="p">(</span><span class="n">err</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></div>
</details><br>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">vecAdd</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span> <span class="n">A</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">B</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">C</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">n</span><span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">float</span> <span class="o">*</span><span class="n">d_A</span> <span class="o">*</span><span class="n">d_B</span><span class="p">,</span> <span class="o">*</span><span class="n">d_C</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">    <span class="n">cudaMalloc</span><span class="p">((</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span> <span class="o">%</span><span class="n">d_A</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">cudaMemcpy</span><span class="p">(</span><span class="n">d_A</span><span class="p">,</span> <span class="n">h_A</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">cudaMemcpyHostToDevice</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">cudaMalloc</span><span class="p">((</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span> <span class="o">%</span><span class="n">d_B</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">cudaMemcpy</span><span class="p">(</span><span class="n">d_B</span><span class="p">,</span> <span class="n">h_B</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">cudaMemcpyHostToDevice</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">cudaMalloc</span><span class="p">((</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span> <span class="o">%</span><span class="n">d_C</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Kernel invocation code - to be shown later
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="n">cudaMemcpy</span><span class="p">(</span><span class="n">h_C</span><span class="p">,</span> <span class="n">d_C</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">cudaMemcpyDeviceToHost</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Free device memory for A, B, C
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cudaFree</span><span class="p">(</span><span class="n">d_A</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">cudaFree</span><span class="p">(</span><span class="n">d_B</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">cudaFree</span><span class="p">(</span><span class="n">d_C</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="25-kernel-functions-and-threading">2.5 Kernel functions and threading</h2>
<p>内核函数指所有线程在并行阶段执行的代码，<strong>网格中的所有线程执行相同的内核代码</strong>。。当程序的主机代码调用内核时，CUDA runtime 系统启动一个线程网格，这些线程被组织成一个两级层次结构。每个网格都被组织为线程块 (<em>thread block</em>, 简称为块) 数组。网格的所有块都是相同的大小。在调用内核时，每个线程块中的线程总数由主机代码指定。
同一个内核可以在主机代码的不同部分用不同数量的线程调用。对于给定的线程网格，一个块中的线程数可以在名为 <code>blockDim</code> 的内置变量中获得，它是一个具有三个无符号整数字段 <code>(x, y, z)</code> 的结构体。
下图给出了一个示例，其中每个块由256个线程组成。每个线程都用一个箭头表示，标有线程在块中的索引号的方框。由于数据是一维向量，因此每个线程块被组织为一维线程数组。<code>blockDim.x</code> 的值表示每个块中的线程总数。<code>threadaIdx</code> 变量表示每个线程在块中的坐标。全局索引 i 的计算公式为 <code>i = blockIdx.x * blockDim.x + threadIdx.x</code></p>
<p>许多编程语言都有内置变量。这些变量具有特殊的含义和目的。这些变量的值通常由运行时系统预先初始化，并且在程序中通常是只读的。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEB67f8186e554926a97be5d005a8c86056?method=download&amp;shareKey=55b9fec27854c9abf7e06eaff5c5a612" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEB67f8186e554926a97be5d005a8c86056?method=download&amp;shareKey=55b9fec27854c9abf7e06eaff5c5a612" alt="Hierarchical Organization in CUDA">
    </a><figcaption>Hierarchical Organization in CUDA</figcaption></figure></p>
<p>向量加法的核函数定义如下。网格中的每个线程对应于原始循环的一次迭代，这被称为循环并行 (<em>loop parallel</em>)，意为原始顺序代码的迭代由线程并行执行。<code>addVecKernel</code> 中有一个 <code>if (i &lt; n)</code> 语句，因为并非所有的向量长度都可以表示为块大小的倍数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">__global__</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">vecAddKernel</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span> <span class="n">A</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">B</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">C</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>CUDA C 使用了三个可以在函数声明中使用的限定字。下表展示了这些关键词的意义。</p>
<ul>
<li><code>__host__ </code> 就是在主机上执行的传统 C 函数，只能从另一个主机函数调用。</li>
<li><code>__global__</code> 表示被声明的函数是 CUDA C 内核函数。内核函数在设备上执行，并且可以从主机上调用。</li>
<li><code>__device__</code> 函数在 CUDA 设备上执行，只能从内核函数或其他设备函数调用。</li>
</ul>
<p>可以在函数声明中同时使用 <code>__host__</code>  和 <code>__device__</code>. 编译系统会为同一个函数生成两个版本的目标代码。</p>
<table>
  <thead>
      <tr>
          <th>Qualifier Keyword</th>
          <th>Callable From</th>
          <th>Executed on</th>
          <th>Executed by</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>__host__ </code>(default)</td>
          <td>Host</td>
          <td>Host</td>
          <td>Caller host thread</td>
      </tr>
      <tr>
          <td><code>__global__</code></td>
          <td>Host/Device</td>
          <td>Device</td>
          <td>New grid of device thread</td>
      </tr>
      <tr>
          <td><code>__device__</code></td>
          <td>Device</td>
          <td>Device</td>
          <td>Caller device thread</td>
      </tr>
  </tbody>
</table>
<h2 id="26-calling-kernel-functions">2.6 Calling kernel functions</h2>
<p>实现内核函数之后，剩下的步骤是从主机代码调用该函数来启动网格。当主机代码调用内核时，它通过执行配置参数 (<em>execution configuration parameters</em>) 设置网格和线程块大小配置参数在在传统的C函数参数之前由 <code>&lt;&lt;&lt;...&gt;&gt;&gt;</code> 之间给出。第一个配置参数给出网格中的块数量。第二个参数指定每个块中的线程数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">vectAdd</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span> <span class="n">A</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">B</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">C</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// d_A, d_B, d_C allocations and copies omitted
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Run ceil(n/256) (or by (n + 256 - 1) / 256) blocks of 256 threads each 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">vecAddKernel</span><span class="o">&lt;&lt;&lt;</span><span class="n">ceil</span><span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="mf">256.0</span><span class="p">),</span> <span class="mi">256</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">d_A</span><span class="p">,</span> <span class="n">d_B</span><span class="p">,</span> <span class="n">d_C</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>下面展示了 <code>vecAdd</code> 函数中的最终主机代码。所有的线程块操作向量的不同部分。它们可以按任意顺序执行。</p>
<blockquote>
<p>实际上，分配设备内存、从主机到设备的输入数据传输、从设备到主机的输出数据传输以及释放设备内存的开销可能会使生成的代码比原始顺序代码慢，这是因为内核完成的计算量相对于处理或传输的数据量来说很小。</p></blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">vecAdd</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span> <span class="n">A</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">B</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">C</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">float</span> <span class="o">*</span><span class="n">d_A</span> <span class="o">*</span><span class="n">d_B</span><span class="p">,</span> <span class="o">*</span><span class="n">d_C</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">cudaMalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d_A</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">cudaMemcpy</span><span class="p">(</span><span class="n">d_A</span><span class="p">,</span> <span class="n">h_A</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">cudaMemcpyHostToDevice</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">cudaMalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d_B</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">cudaMemcpy</span><span class="p">(</span><span class="n">d_B</span><span class="p">,</span> <span class="n">h_B</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">cudaMemcpyHostToDevice</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">cudaMalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d_C</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">vecAddKernel</span><span class="o">&lt;&lt;&lt;</span><span class="n">ceil</span><span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="mf">256.0</span><span class="p">),</span> <span class="mi">256</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">d_A</span><span class="p">,</span> <span class="n">d_B</span><span class="p">,</span> <span class="n">d_C</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">cudaMemcpy</span><span class="p">(</span><span class="n">h_C</span><span class="p">,</span> <span class="n">d_C</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">cudaMemcpyDeviceToHost</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Free device memory for A, B, C
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cudaFree</span><span class="p">(</span><span class="n">d_A</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">cudaFree</span><span class="p">(</span><span class="n">d_B</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">cudaFree</span><span class="p">(</span><span class="n">d_C</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="27-compilation">2.7 Compilation</h2>
<p>NVCC (NVIDIA C Compiler) 处理一个C处理一个CUDA C程序，使用 CUDA 关键字来分离主机代码和设备代码。</p>
<ul>
<li>主机代码是就是普通的ANSI C代码，使用 C/C++ 编译器进行编译，并作为传统的 CPU 进程运行。</li>
<li>设备代码及其相关辅助函数和数据结构的CUDA关键字，由NVCC编译成称为 PTX (Parallel Thread Execution) 文件的虚拟二进制文件, 由 NVCC runtime 组件进一步编译成目标文件，并在支持 cuda 的 GPU 设备上执行。</li>
</ul>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEB0a32f3aa7a8ffb0fbf51b81c298fcc26?method=download&amp;shareKey=9eb69ac9f65a39b57002dcb02da3a39c" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEB0a32f3aa7a8ffb0fbf51b81c298fcc26?method=download&amp;shareKey=9eb69ac9f65a39b57002dcb02da3a39c" alt="Overview of the Compilation Process of a CUDA C Program">
    </a><figcaption>Overview of the Compilation Process of a CUDA C Program</figcaption></figure></p>
<hr>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>线程由程序的代码、正在执行的代码中的位置以及它的变量和数据结构的值组成。&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p><code>cudaMalloc</code> 与 C 语言 <code>malloc</code> 函数的格式不同。前者接受两个参数，指针变量其地址作为第一个参数给出。后者只接受一个参数来指定分配对象的大小，返回一个指向分配对象的指针。&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>PMPP Learning-Chapter 1 Introduction</title>
      <link>http://localhost:1313/blogs/courselearning/pmpp/pmpp-ch1/</link>
      <pubDate>Tue, 03 Sep 2024 21:20:12 +0800</pubDate>
      <guid>http://localhost:1313/blogs/courselearning/pmpp/pmpp-ch1/</guid>
      <description>Personal notebook 1 of Programming Massively Parallel</description>
      <content:encoded><![CDATA[<h1 id="1-introduction">1 Introduction</h1>
<p>基于单个中央处理器 (Central Processor Unit, CPU) 的微处理器外部看起来是按顺序执行指令，例如英特尔和 AMD 的 x86 处理器，随着时钟频率和硬件资源的快速增长，在20世纪80年代和90年代推动了计算机应用程序的性能快速提高和成本降低。可以给桌面应用提供 GFLOPS 级别的浮点运算，给数据中心提供 TFLOPS 级别的浮点运算。然而，由于能源消耗和散热问题，这种趋势从2003年开始放缓。这些问题限制了时钟频率的增加和保持按顺序步骤执行指令的同时在单个 CPU 上每个时钟周期内可以执行的行动。
之后几乎所有的微处理器供应商都转向了在每个芯片上使用多个物理 CPU (称为处理器核心) 来提高处理能力。在这个模型中，传统的CPU可以看作是一个单核CPU。这样就要求必须有多个指令序列并且可以同时在这些处理器核心上执行 (无论是来自相同的应用程序还是来自不同的应用程序)。为了使一个特定的应用程序受益于多个处理器核心，它的工作必须分成多个指令序列，这些指令序列可以同时在这些处理器核心上执行。这种从单个CPU按顺序执行指令到多个内核并行执行多个指令序列的转变造就了并行计算的需求。</p>
<h2 id="11-heterogeneous-parallel-computing">1.1 Heterogeneous parallel computing</h2>
<p>半导体行业确定了设计微处理器的两条主要路线</p>
<ul>
<li><em>Multicore</em> Trajectory: 寻求在转变到多个核时保持顺序程序的执行速度。</li>
<li><em>Many-thread</em> Trajectory: 更多地关注并行应用程序的执行吞吐量。</li>
</ul>
<p>自2003年以来，多线程处理器尤其是 GPU，一直在浮点计算性能上表现优异。多核和多线程之间在峰值性能上的如此大的差距促使许多应用程序开发人员将其软件的计算密集型部分转移到gpu上执行。</p>
<table>
  <thead>
      <tr>
          <th></th>
          <th>64-bit double-precision</th>
          <th>32-bit single-precision</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Tesla A100 GPU</td>
          <td>9.7 TFLOPS</td>
          <td>156 TFLOPS</td>
      </tr>
      <tr>
          <td>Intel 24-core Processor</td>
          <td>0.33 TLOPS</td>
          <td>0.66 TLOPS</td>
      </tr>
  </tbody>
</table>
<p>CPU 的设计为面向延迟的 (<em>latency-oriented</em>) 设计。针对顺序代码性能进行了优化。计算单元和操作数传输逻辑的设计是为了最小化计算的有效延迟，代价是增加芯片面积和单位功率的使用。采用复杂的分支预测逻辑和执行控制逻辑来减少条件分支指令的延迟使得每个线程的执行延迟降低。然而，低延迟计算单元、复杂的操作数传递逻辑、大缓存存储器和控制逻辑消耗了芯片面积和功率，否则可以用来提供更多的算术执行单元和内存访问通道。
GPU 的设计是面向吞吐量 (<em>throught-put oriented</em>)的设计。寻求在有限的芯片面积和功耗预算下最大化浮点计算和内存访问吞吐量。许多图形应用程序的速度受到数据从内存系统传输到处理器的速率的限制，必须能够将大量数据加载和存储到 DRAM 中的图形帧缓冲区。
游戏应用程序普遍接受的宽松内存模型(各种系统软件，应用程序和I/O设备期望其内存访问工作的方式)也使 GPU 更容易支持访问内存的大规模并行性。通用处理器必须满足遗留操作系统、应用程序和I/O设备的要求，这些要求对支持并行内存访问提出了更多挑战，从而使提高内存访问的吞吐量 (通常称为内存带宽 <em>memory bandwidth</em>) 变得更加困难。
就功耗和芯片面积而言，减少延迟比增加吞吐量要昂贵得多<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>。因此，GPU 的主流解决方案是针对大量线程的执行吞吐量进行优化，<strong>而不是减少单个线程的延迟</strong>。这种设计方法允许分级存储层次和计算具有较长的延迟，从而节省了芯片面积和功耗。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEB0619836cbd0c830367d16469ab356a2e?method=download&amp;shareKey=f86f3077eb42bd1e9ca6ed4c31c18a65" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEB0619836cbd0c830367d16469ab356a2e?method=download&amp;shareKey=f86f3077eb42bd1e9ca6ed4c31c18a65" alt="CPU and GPU Design Philosophies">
    </a><figcaption>CPU and GPU Design Philosophies</figcaption></figure></p>
<h2 id="12-why-more-speed-or-parallelism">1.2 Why More Speed or Parallelism</h2>
<p>基于人工神经网络的深度学习是通过大幅提高计算吞吐量而实现的新应用。虽然自 20 世纪 70 年代以来，神经网络得到了积极的关注，但由于需要太多的标记数据和太多的计算来训练这些网络，它们在实际应用中一直效果不佳。互联网的兴起提供了大量有标签的图片，而 GPU 的兴起则带来了计算吞吐量的激增。因此，自2012年以来，基于神经网络的应用在计算机视觉和自然语言处理方面得到了快速的采用。这种采用彻底改变了计算机视觉和自然语言处理应用，并引发了自动驾驶汽车和家庭辅助设备的快速发展。</p>
<h2 id="13-speeding-up-real-applications">1.3 Speeding up real applications</h2>
<p>并行计算系统相对于串行计算系统所能实现的加速的一个重要因素是可以并行化的应用程序部分，另一个重要因素是从内存访问数据和向内存写入数据的速度有多快。下图展示了顺序和并行应用程序部分的覆盖率。顺序部分和传统的(单核)CPU覆盖部分相互重叠。以前的GPGPU技术对数据并行部分的覆盖非常有限，因为它仅限于可以表示为绘制像素的计算。障碍是指难以扩展单核cpu以覆盖更多数据并行部分的功率限制。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEBfc0b86a42c4ed9223a9b6539c92712fc?method=download&amp;shareKey=796ebc8414ada67e650c087e44aa66a9" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEBfc0b86a42c4ed9223a9b6539c92712fc?method=download&amp;shareKey=796ebc8414ada67e650c087e44aa66a9" alt="Coverage of Application Portions">
    </a><figcaption>Coverage of Application Portions</figcaption></figure></p>
<h2 id="14-challenges-in-parallel-programming">1.4 Challenges in parallel programming</h2>
<ol>
<li>设计具有与顺序算法相同的算法(计算)复杂度的并行算法可能具有挑战性。</li>
<li>许多应用程序的执行速度受到内存访问延迟和/或吞吐量的限制。</li>
<li>与顺序程序相比，并行程序的执行速度通常对输入数据特征更为敏感。</li>
<li>有些应用程序可以并行化，而不需要跨不同线程的协作 (<em>embarrassingly parallel</em>)。其他应用程序需要使用同步操作 (<em>synchronization operations</em>) 使得线程能相互协作。</li>
</ol>
<hr>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>例如，可以通过将计算单元的数量翻倍来使吞吐量翻倍，但代价是芯片面积和功耗翻倍。然而，将算术延迟减少一半可能需要电流翻倍，代价是使用的芯片面积增加一倍以上，功耗变为四倍。&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
]]></content:encoded>
    </item>
  </channel>
</rss>
