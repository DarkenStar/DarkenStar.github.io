<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Fast-dLLM | WITHER</title>
<meta name="keywords" content="DiffusionLLM">
<meta name="description" content="Paper Reading of Fast-dLLM">
<meta name="author" content="WITHER">
<link rel="canonical" href="http://localhost:1313/blogs/fast-dllm/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.dd3b5b907a50db3238b81d49d094cf1c04a091227797dc9cfde4e2fa3f35df49.css" integrity="sha256-3TtbkHpQ2zI4uB1J0JTPHASgkSJ3l9yc/eTi&#43;j8130k=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/blogs/fast-dllm/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<script>
  MathJax = {
    tex: {
      displayMath: [['\\[', '\\]'], ['$$', '$$']],  
      inlineMath: [['\\(', '\\)'], ['$', '$']]  
    }
  };
</script>




<script src="https://cdn.bootcdn.net/ajax/libs/mermaid/9.1.6/mermaid.min.js"></script>
<script>
    mermaid.initialize({
        startOnLoad: true,
        theme: localStorage.getItem("pref-theme") === "dark" ? "dark" : "forest" 
    });
</script>

<meta property="og:url" content="http://localhost:1313/blogs/fast-dllm/">
  <meta property="og:site_name" content="WITHER">
  <meta property="og:title" content="Fast-dLLM">
  <meta property="og:description" content="Paper Reading of Fast-dLLM">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="blogs">
    <meta property="article:published_time" content="2025-06-12T23:01:49+08:00">
    <meta property="article:modified_time" content="2025-06-22T17:53:30+08:00">
    <meta property="article:tag" content="DiffusionLLM">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Fast-dLLM">
<meta name="twitter:description" content="Paper Reading of Fast-dLLM">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Blogs",
      "item": "http://localhost:1313/blogs/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Fast-dLLM",
      "item": "http://localhost:1313/blogs/fast-dllm/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Fast-dLLM",
  "name": "Fast-dLLM",
  "description": "Paper Reading of Fast-dLLM",
  "keywords": [
    "DiffusionLLM"
  ],
  "articleBody": "Introduction Diffusion LLMs 被视为下一代文本生成技术的有力竞争者，其核心优势在于理论上可以并行生成多个 token，从而有望实现比自回归模型快几个数量级的推理速度。谷歌的 Gemini Diffusion 和 Inception Labs 的Mercury等模型已经展示了其惊人的潜力，宣称能达到每秒上千 token 的生成速度。\n当前开源的扩散LLM (LLaDA、Dream) 在实际应用中的速度远远达不到预期，甚至比优化良好的自回归模型还要慢。这篇论文的工作，就是要拆掉阻碍扩散 LLM 起飞的两座大山。\n无法使用 KV Cache 扩散LLM的注意力机制是双向的，即一个 token 的生成不仅依赖于它前面的内容，也依赖于它后面的内容 (尽管后面可能是未知的 MASK token ) 。这种特性使得过去的信息和未来的信息相互纠缠，无法像自回归模型那样简单地缓存和复用过去的信息。导致扩散LLM在每一步推理中都需要进行大量的重复计算，严重拖慢了速度。\nFast-dLLM 的第一个核心贡献，就是提出了一种分块近似 (block-wise approximate) KV Cache 机制。\nWhile the bidirectional nature of attention in Diffusion LLMs precludes a fully equivalent KV Cache, our approximation closely resembles an ideal cache in practice.\n它将待生成的文本序列分成若干个块. 在生成某一个块 (比如Block 1) 时，它会提前计算并缓存其他所有块 (比如 Prompt 和 Block 0) 的 KV. 在这个块的内部生成过程中，这些缓存被反复利用。当这个块生成完毕后，再整体更新一次所有块的KV缓存 。\n这个方法的近似在于，在一个块的生成过程中，缓存是固定的，而实际上随着块内 token 的不断去噪和清晰化，这些缓存理论上也应该随之微调。但论文通过可视化实验 (图3) 有力地证明，在相邻的推理步骤中，KV 激活值的 余弦相似度非常高，几乎接近于1. 这说明使用固定的近似缓存带来的误差微乎其微，完全可以用极小的精度损失换取巨大的速度提升。\n论文还进一步提出了双缓存 (DualCache) 版本，不仅缓存了前面的“前缀” (prefix) ，还缓存了后面的“后缀” (suffix，通常是 MASK token ) ，从而进一步压榨了计算优化的空间，实现了更快的速度。\n并行解码带来的质量下降 扩散LLM的另一大理论优势是 并行解码 (Parallel Decoding)，即一次性预测和生成多个 token 。然而，实践再次证明，当并行解码的 token 数量增多时，生成文本的质量会急剧下降 。\n论文深刻地剖析了其根源：条件独立性假设 (conditional independence assumption) 的破坏 。在并行解码时，模型是独立地为每个待生成的 MASK 位置预测一个概率分布，然后从中采样。但实际上，一句话中的 token 之间存在着强烈的依赖关系。论文举了一个例子:\nConsider an example from [30]: The list of poker hands that consist of two English words are: The subsequent two words could be, for instance, “high card,” “two pair,” “full house,” or “straight flush.” […] However, the multi-token prediction procedure in MDMs first generates a probability distribution for each token and then samples from these distributions independently. This independent sampling can lead to undesirable combinations, such as “high house.”\n模型可能会独立地预测出 “high” 和 “house\"这两个词，但把它们组合在一起就成了毫无意义的 high house. 这是因为模型在并行预测时忽略了 token 间的联合概率，而错误地直接使用了边缘概率的乘积。\n为了解决这个问题，Fast-dLLM提出了第二个核心贡献：置信度感知并行解码 (Confidence-Aware Parallel Decoding) 策略 。这个想法非常直观且有效：我们只对那些模型非常有把握的 token 进行并行解码。\n具体来说，在每一步解码时，模型会为每个待生成的 MASK 位置计算一个 置信度分数 (比如softmax概率的最大值). 然后，设定一个全局的置信度阈值 τ，只有那些置信度超过这个阈值的 token 才会被揭开，而置信度不足的 token 则继续保持 MASK 状态，留到下一步再做决策。为了避免无限循环，如果没有任何 token 的置信度达标，模型会强制解码置信度最高的那一个。\n这个策略的精妙之处在于，它在理论上是站得住脚的。论文通过定理一从数学上证明了：当模型对一组 token 的预测置信度足够高时 (即 p\u003e1−ϵ，且 ϵ 足够小)，基于独立边缘概率的“贪心并行解码”与基于真实联合概率的“贪心串行解码”会得到完全相同的结果。\nEffectiveness of Components of Fast-dLLM across Different Approaches\nFast-dLLM 的创新性体现在它是一种 training-free 的加速框架。它没有修改模型结构，也不需要重新训练，而是通过两项即插即用的推理策略——“分块近似KV缓存”和“置信度感知并行解码”，分别从减少重复计算和提升并行效率两个维度，精准地解决了当前开源扩散 LLM 面临的核心瓶颈。 实验结果在 LLaDA 和 Dream 等模型上，结合两种策略，实现了高达 27.6 倍的端到端吞吐量提升，同时在多个基准测试上几乎没有精度损失。\n2. Preliminary 2.1. Masked Diffusion Model 针对离散数据的扩散模型最早在 Argmax Flows and Multinomial Diffusion 和 Deep Unsupervised Learning using Nonequilibrium Thermodynamics 中被探提出。随后 D3PM 提出了一个更通用的框架，通过特定的转移矩阵 $Q_{t}$ 定义了前向加噪过程的离散状态马尔可夫链，并通过最大化 ELBO 来学习反向过程的参数化模型 $p_{\\theta}(x_{0}|x_{t})$. CTMC 进一步将 D3PM 扩展到连续时间，将其形式化为一个连续时间马尔可夫链 (CTMC) 框架。在另一种不同的方法中，SEDD 通过参数化似然比 $\\frac{p_{t}(y)}{p_{t}(x)}$ 来学习反向过程，并采用去噪分数熵来训练该比率。\n在各种离散扩散的噪声处理方式中，Masked Diffusion Models, MDMs，也被称为吸收状态离散扩散模型，获得了相当大的关注。MDMs 采用一种前向加噪过程，其中 token 被逐步替换为一个特殊的 MASK token 。这个过程由以下转移概率定义：\n$$\rq_{t|0}(x_{t}|x_{0})=\\prod_{i=1}^{n}q_{t|0}(x_{t}^{i}|x_{0}^{i})=\\prod_{i=1}^{n}Cat(x_{t}^{i};(1-t)\\delta_{x_{0}^{i}}+t\\delta_{[MASK]}) \\tag{1}\r$$ $q_{t|0}(x_t|x_0)$: 表示给定原始序列 $x_0$，得到噪声序列 $x_t$ 的概率 。 $\\prod_{i=1}^{n}$: 连乘符号，表示整个序列的噪声过程是序列中每个 token (token) 独立进行噪声过程的概率乘积 。 $Cat(\\cdot)$: 代表类别分布 (Categorical Distribution) 。 $t \\in [0,1]$: 表示扩散时间或掩码级别。当 $t=0$ 时，序列完全是原始的；当 $t=1$ 时，序列被完全替换为 [MASK] token 。 $(1-t)\\delta_{x_{0}^{i}}+t\\delta_{[MASK]}$: 在时间 t，第 i 个 token 有 $1-t$ 的概率保持其原始身份 $x_0^i$，有 $t$ 的概率变成 [MASK] token 。$\\delta$ 是克罗内克函数，用于指定概率。 最近，MDLM 和 RADD 的工作表明，对于 MDMs 不同的参数化是等价的。此外，他们证明了 MDMs 的训练目标可以被简化或直接从数据似然中推导出来 。这导出了以下目标函数，即 $log~p_{\\theta}(x)$ 的一个 ELBO:\nReparameterized Absorbing Discrete Diffusion, RADD 定理 1（Theorem 1） $$\r\\frac{p_t(\\hat{x}_t)}{p_t(x_t)} = \\underbrace{\\frac{e^{-\\bar{\\sigma}(t)}}{1-e^{-\\bar{\\sigma}(t)}}}_{\\text{时间相关的标量}} \\cdot \\underbrace{p_0(\\hat{x}_t^i | x_t^{UM})}_{\\text{干净数据的条件概率}}\r$$ $p_t(x_t)$ 是时间步 $t$ 的数据分布 $x_t$ 是带噪声（被掩码）的序列 $x_t^{UM}$ 是其中未被掩码的部分 $\\hat{x}_t$ 是在 $x_t$ 的一个掩码位置上填入一个新 token 后的序列 $p_0$ 是原始干净数据的分布，$\\bar{\\sigma}(t)$ 是一个与噪声水平相关的函数。 这个公式表明，模型需要学习的目标可以分解。其中一部分是一个可以精确计算的、只与时间 $t$ 有关的标量，而另一部分则是一个与时间无关的、在给定其他可见 token 的条件下，预测被掩码 token 的条件概率。正是LLM 所做的事情。这个看似简单的改动带来了巨大的实际优势：\n架构简化：移除了时间编码和相关的自适应归一化层，使得模型参数更少，结构更简洁 。 采样加速：由于模型输出不再依赖于时间 $t$，当输入序列 $x_t$ 在某个采样区间内没有发生变化时，可以直接缓存上一步的计算结果，而无需再次调用网络。这极大地减少了函数评估次数（Number of Function Evaluations, NFEs）。论文给出了在特定采样策略下，期望函数评估次数（E-NFEs）的解析公式 ： $$\rE\\text{-}NFEs(n) = n \\left( 1 - \\left( 1 - \\frac{1}{n} \\right)^l \\right)\r$$定理 2（Theorem 2）\n证明了吸收态扩散模型的训练目标（具体来说是 DSE 损失）在数学上等价于**任意阶自回归模型（Any-Order Autoregressive Models, AO-ARMs）**的训练目标 。\nAO-ARMs 是一类特殊的生成模型，它们不像标准自回归模型那样固定从左到右的生成顺序，而是学习在所有可能的 $d!$（$d$ 为序列长度）种生成顺序下对数据进行建模。论文通过一系列精巧的数学推导，建立了四种不同损失函数之间的等价关系链 ：\n$\\mathcal{L}_{DSE} \\iff \\mathcal{L}_{t-DCE} \\iff \\mathcal{L}_{\\lambda-DCE} \\iff \\mathcal{L}_{AO}$\n它表明吸收态扩散模型本质上是在学习一个集成了所有可能生成顺序的自回归模型的期望 。这可能解释了为什么它们在某些任务上表现得非常稳健。\n$$\r-log~p_{\\theta}(x)\\le\\int_{0}^{1}\\frac{1}{t}\\mathbb{E}_{q_{t,0}(x_{t}|x_{0})}[\\sum_{i:x_{t}^{i}=[MASK]}-log~p_{\\theta}(x_{0}^{i}|x_{t})]dt:=\\mathcal{L}_{MDM}. \\tag{2}\r$$ $-log~p_{\\theta}(x)$: 模型的目标是最大化生成真实数据 $x$ 的对数似然，这等价于最小化它的负对数似然。这个公式给出了负对数似然的一个* ELBO. $\\int_{0}^{1}...dt$: 对所有可能的噪声级别 t (从0到1) 进行积分，意味着模型需要学会在任何噪声水平下都能很好地复原数据 。 $\\mathbb{E}_{q_{t,0}(x_{t}|x_{0})}[...]$: 表示对所有可能的噪声样本求期望。在训练时，我们根据公式(1)随机生成一个带 [MASK] 的噪声序列 $x_t$. $\\sum_{i:x_{t}^{i}=[MASK]}-log~p_{\\theta}(x_{0}^{i}|x_{t})$: $\\sum_{i:x_{t}^{i}=[MASK]}$: 对所有被 [MASK] 的位置 i 进行求和 。 $-log~p_{\\theta}(x_{0}^{i}|x_{t})$: 这是交叉熵损失。它的意思是，给定带有 [MASK] 的序列 $x_t$，模型 $p_{\\theta}$ 需要预测在位置 i 上的原始 token $x_0^i$ 应该是什么。模型预测得越准，这个损失值就越小。 2.2. MDMs 的生成过程 对于公式1中定义的前向过程，其解析上的逆过程在生成时计算效率低下，因为它通常每步只修改一个 token 。一个常见的加速策略是采用 $\\tau$-leaping 近似法来处理反向过程。在 MDMs 的背景下，这允许一个迭代式的生成过程，其中多个被掩码的 token 可以从一个噪声水平 t 近似地单步恢复到一个更早的水平 s \u003c t.\n$$\rq_{s|t}(x_s|x_t)=\\prod_{i=0}^{n-1}q_{s|t}(x_{s}^{i}|x_{t})\r$$其中\n$$\rq_{s|t}(x_{s}^{i}|x_{t})=\\begin{cases}1, \u0026 \\text{if } x_{t}^{i}\\ne[MASK], x_{s}^{i}=x_{t}^{i} \\\\ \\frac{s}{t}, \u0026 \\text{if } x_{t}^{i}=[MASK], x_{s}^{i}=[MASK] \\\\ \\frac{t-s}{t}q_{0|t}(x_{s}^{i}|x_{t}), \u0026 \\text{if } x_{t}^{i}=[MASK], x_{s}^{i}\\ne[MASK]\\end{cases} \\tag{3}\r$$ $q_{s|t}(x_{s}^{i}|x_{t})$: 表示从 t 时刻的 token $x_t^i$ 变为 s 时刻的 token $x_s^i$ 的概率 。 Case 1: 如果一个 token 在 t 时刻就不是 [MASK]，那么它在更早的 s 时刻也保持不变 。 Case 2: 一个在 t 时刻是 [MASK] 的 token ，在更早的 s 时刻仍然是 [MASK]. Case 3: 这是关键的去噪步骤。如果一个 token 在 t 时刻是 [MASK]，模型会尝试在 s 时刻预测出一个具体的 token. $\\frac{t-s}{t}$: 代表一个在 t 时刻被掩码的 token，在 s 时刻被“揭示”出来的概率 。 $q_{0|t}(x_{s}^{i}|x_{t})$: 这是由神经网络模型给出的预测分布。模型会观察整个带有 [MASK] 的上下文 $x_t$，然后为当前位置预测一个最有可能的原始 token ，并给出一个在整个词汇表上的概率分布 。 在涉及条件数据的场景中，例如根据一个 propmt p 生成一个回应 $x_{0}$，MDM 的反向过程 (公式3所定义) 需要进行调整。具体来说，模型用于揭示一个 token $x_{s}^{i}$ 的预测分布 $q_{0|t}(x_{s}^{i}|x_{t})$ 现在也需要以 prompt p 为条件，即 $q_{0|t}(x_{s}^{i}|x_{t},p)$ 。\n并行解码的诅咒 直接逆转公式1的前向过程来进行生成是缓慢的，通常每步只改变一个 token. 一个常见的加速策略是采用 $\\tau$-leaping 近似法来处理反向过程。对于 MDMs，这意味着多个被掩码的 token 将在一个步骤中并行生成。然而，由于条件独立性假设，多 token 预测中出现了一个重大挑战。考虑一个例子：由两个英文单词组成的扑克手牌列表是：随后的两个词可能是，例如，high card，two pair，full house，或 straight flush. 值得注意的是，这两个词之间存在着关联。然而，MDMs 中的多 token 预测过程首先为每个 token 生成一个概率分布，然后独立地从这些分布中进行采样。这种独立采样可能导致不希望的组合，例如 high house.\n为了将其形式化，考虑揭示两个 token 位置 i 和 j. 由于条件独立性假设，MDMs 从 $p(x_{s}^{i}|x_{t})\\cdot p(x_{s}^{j}|x_{t})$ 中采样这些 token. 然而，真实的联合概率需要考虑它们之间的依赖关系：\n$$\rp(x_{s}^{i},x_{s}^{j}|x_{t})=p(x_{s}^{i}|x_{t})\\cdot p(x_{s}^{j}|x_{t},x_{s}^{i})\r$$或者对称地，通过将 i 依赖于条件 j. 这种假设的独立生成与真实的依赖性数据分布之间的差异，会降低生成序列的质量和连贯性。当在单一步骤中同时揭示大量 token 时，这个问题会变得更加严重。\n3. Methodology 3.1. Pipeline Overview Fast-dLLM，建立在 MDM 架构之上，以实现高效和高质量的序列生成。为了加速推理，整体流水线融合了两大关键策略：通过 KV Cache 实现的高效注意力计算，以及一个由预测置信度引导的 并行解码方案。具体来说，我们采用了分块解码设计的 KV Cache，它允许在不同步骤间复用注意力激活值，并显著减少了冗余计算。在每个块内部，进一步提出了置信度感知的并行解码，它能根据置信度分数选择性地更新 token ，从而在保持输出质量的同时提高效率。通过结合这些策略，Fast-dLLM 在对生成性能影响最小的情况下，显著加快了 MDM 的推理速度。整体流程在算法 1 中进行了总结。\n3.2. Key-Value Cache for Block-Wise Decoding Illustration of our Key-Value Cache for Block-Wise Decoding\n如上图所示，我们采用了一种分块解码的策略来支持 KV Cache 的使用。一开始计算并存储 prompt 的 KV 缓存，这个缓存将在整个块 0的解码过程中被复用。在每个块的内部，相同的缓存会被多个解码步骤复用。在完成一个块的解码之后，更新所有 token (不仅仅是新生成的 token) 的缓存。这个缓存更新可以与解码步骤联合执行，因此与不使用缓存相比，没有额外的计算开销。由于掩码扩散模型中使用的是完全注意力机制，这种方法导致了一个近似的解码过程。\n我们的近似 KV 缓存方法的有效性，源于我们观察到 KV 激活值在相邻的推理步骤中表现出高度的相似性，如下图所示。图 a 中红色方框区域突显了块内的相似性分数，这些分数始终接近于 1. 表明在分块解码期间，前缀 (prefix) 的键和值的差异可以忽略不计，使我们能够安全地复用缓存而不会有显著的准确率损失。 此外，我们实现了一个我们 KV 缓存机制的双向版本，名为 DualCache，它不仅缓存前缀 token ，还缓存后缀 (suffix) token ，在我们的分块解码方案中，后缀完全由掩码 token 组成。如表3所示，DualCache 带来了进一步的加速。图 b 中的红色方框区域进一步证明，在分块解码期间，后缀的键和值的差异也可以忽略不计。\nHeatmaps of Key-Value Activation Cosine Similarity Across Inference Steps in LLaDA\n3.3. Confidence-Aware Parallel Decoding 尽管存在一些方法，例如使用辅助模型来显式地捕捉不同位置 token 之间的依赖关系，但它们通常会增加整个流水线的复杂性。与这些方法相反，我们提出了一个简单而有效的置信度感知解码算法，旨在缓解这种条件独立性问题。\n在每次迭代中，我们不是冒然地使用它们独立的边缘概率来揭示所有被掩码的 token ，而是为每个 token 计算一个置信度分数 (例如最大的 softmax 概率). 只有那些置信度超过一个阈值的 token 才会在当前步骤被揭示；其余的则保持掩码状态，并在未来的步骤中重新考虑。如果没有 token 的置信度超过阈值，就揭示置信度最高的那一个，以确保过程能够进行并防止无限循环。这个策略在加速生成的同时，减少了由不确定或模糊预测引起的错误。\n一个关键问题是\nWhen is it theoretically justifiable to decode tokens in parallel using independent marginals, despite the true joint distribution potentially containing dependencies?\n以下结果来回答了在高置信度情况下，greedy parallel 解码等同于 greedy sequential 解码的条件，并量化了两种分布之间的差异。在给出定理之前，我们将定义其表述中使用的数学符号。\n设 $p_{\\theta}(\\cdot|E)$ 表示一个 MDM 在给定 E (包括 prompt $p_{0}$ 和先前生成的 token) 的条件下给出的 PMF. 假设模型要为不在 E 中的位置 $i_{1},...,i_{n}$ 预测 n 个 token.\n令 $X=(X_{i_{1}},...,X_{i_{n}})$ 是 n 个 token 的向量，其中每个 $X_{i_{j}}$ 在词汇表 V 中取值。设 $p(X|E)\\equiv p_{\\theta}(X_{i_{1}},...,X_{i_{n}}|E)$ 是模型给出的联合条件 PMF。设 $p_{j}(X_{i_{j}}|E)\\equiv p_{\\theta}(X_{i_{j}}|E)$ 是位置 $i_{j}$ 的边缘条件 PMF。并行解码使用边缘概率的乘积来生成 token ：$q(X|E)=\\tilde{\\prod}_{j=1}^{n}p_{j}(X_{i_{j}}|E)$。定理1的证明及相关讨论见附录A。\n定理 1 (高置信度下的并行解码). 假设存在一个特定的 token 序列 $x^{*}=(x_{i_{1}},...,x_{i_{n}})$，使得对于每个 $j\\in\\{1,...,n\\}$，模型对 $x_{i_{j}}$ 都有很高的置信度：$p_{j}(X_{i_{j}}=x_{i_{j}}|E)\u003e1-\\epsilon$，对于某个很小的 $\\epsilon\u003e0$. 那么，以下结论成立：\nEquivalence of Greedy Decoding：如果 $(n+1)\\epsilon\\le1$ (即 $\\epsilon\\le\\frac{1}{n+1}$) ，那么 $$\r\\text{argmax}_{z} p(z|E) = \\text{argmax}_{z} q(z|E) = x^{*}. \\tag{4}\r$$ 这意味着 greedy parallel 解码 (选择 argmax q) 与贪婪序贯解码 (选择 argmax p) 产生相同的结果。 这个界是紧的：如果 $\\epsilon \u003e \\frac{1}{n+1}$，则存在满足高置信度边缘假设的分布 $p(X|E)$，使得 argmax $p(z|E)$ ≠ argmax $q(z|E)$。\nDistance and Divergence Bounds：为简洁起见，将 $p(\\cdot|E)$ 和 $q(\\cdot|E)$ 表示为 p 和 q. $L_p$ Distance ($p \\ge 1$): 对于 $n\u003e1$，$D_{p}(p,q)\u003c((n-1)^{p}+2n)^{1/p}\\epsilon$。特别地，对于总变差距离 ($D_{TV}(p,q)=\\frac{1}{2}D_{1}(p,q)$)，$D_{TV}(p,q)\u003c\\frac{3n-1}{2}\\epsilon$.\n这个公式说明，真实分布 p 和近似分布 q 之间的总变差距离有一个上限。这个上限取决于两个因素：\n$n$: 生成序列的长度。序列越长，这个上限就越大。这是符合直觉的，因为每增加一个 token，近似所累积的潜在误差就可能增加一点。 $\\epsilon$: 模型在每个位置上的“不确定性”。$\\epsilon$ 越小 (即模型越自信)，这个上限就越低。 Forward KL Divergence: 对于 $n \u003e 1$，$D_{KL}(p||q)\u003c(n-1)(H_{b}(\\epsilon)+\\epsilon~ln(|\\mathcal{V}|-1))$，其中 $H_{b}(\\epsilon)=-\\epsilon~ln~\\epsilon-(1-\\epsilon)ln(1-\\epsilon)$ 是二元熵函数，而 $|\\mathcal{V}|$ 是词汇表的大小。\n$n-1$: 同样，损失会随着序列长度线性增长。 $H_{b}(\\epsilon)$: 它衡量了一个概率为 $\\epsilon$ 的事件带来的“意外程度”或不确定性。当 $\\epsilon$ 很小时，$H_b(\\epsilon)$ 也非常小。 $\\epsilon~ln(|\\mathcal{V}|-1)$: 这一项反映了那部分微小的 $\\epsilon$ 概率被分配到词汇表 $\\mathcal{V}$ 中其他所有 token 上所带来的不确定性。即使 $\\epsilon$ 很小，如果词汇表非常巨大 ($|\\mathcal{V}|$ 很大)，这一项也可能有影响。 $L_p$ 距离说明在高置信度下，两种方法找到的最佳答案是相同的。 KL 散度说明高置信度下，不仅最佳答案相同，两种方法描绘的概率分布都非常相似。近似方法 q 不仅猜对了可能性最大的 token， 对其他可能性的估计，也和精确方法 p 的判断高度一致。 4. Experiments 4.1 Experimental Setup 硬件与环境 🖥️: 所有实验均在单张 NVIDIA A100 80GB GPU 上进行，batch size=1. 评测模型 🧠: LLaDA 和 Dream. 评测基准 📊: 采用了四个广泛使用的基准数据集：GSM8K、MATH、HumanEval 和 MBPP. 核心指标 ⏱️: 准确率 (Accuracy): 衡量模型在具体任务上的表现。 吞吐量 (Throughput): 以 tokens/sec 为单位，反映端到端的真实解码速度。 超参数 ⚙️: 缓存块大小: 在 4 到 32 之间进行探索。 置信度阈值: 在 0.5 到 1.0 之间进行探索。 实验默认使用 PrefixCache，块大小为 32，置信度阈值为 0.9. 4.2 Main Results: Performance and Speed 实验结果表明，Fast-dLLM 在各种任务和设置上都取得了显著的速度提升，同时对模型准确率的影响微乎其微 。\n加速效果: 单独引入 KV Cache 机制，通常能带来 2x-3.6x 的速度提升。 当 KV Cache 和并行解码两种策略结合使用时，性能提升更为显著。在 LLaDA 模型上，最 高可达 11.0x 的吞吐量提升；在 Dream 模型上，最高可达 7.8x 的提升 。 极小的精度损失: 在所有基准测试中，加速后模型的准确率与原始基线模型的差距基本保持在 1-2个百分点 以内，有时甚至略有提高。 对长序列更友好: 实验还发现，在处理更长的文本序列时 (例如 few-shot 场景或长代码生成)，Fast-dLLM 的加速效果更为明显。 下表以 GSM8K (5-shot) 任务为例，直观展示了 Fast-dLLM (即 +Cache+Parallel) 相较于 baseline 模型的性能提升。\n模型 生成长度 配置 准确率 (%) 吞吐量 (tok/s) 相对加速 LLaDA 256 Baseline 79.3 6.7 1x Fast-dLLM 78.5 54.4 8.1x 512 Baseline 77.5 3.2 1x Fast-dLLM 77.2 35.3 11.0x Dream 256 Baseline 75.0 9.1 1x Fast-dLLM 74.8 48.2 5.3x 512 Baseline 76.0 7.7 1x Fast-dLLM 74.0 42.9 5.6x 4.3 Ablations and Analysis 为了深入理解各个组件的贡献，论文进行了一系列详细的消融实验。\n输入与生成长度的影响:\n实验证明，更长的上下文 (prefill，如从 5-shot 增加到 8-shot) 和更长的生成长度，都能显著放大加速效果。 在 8-shot 和 1024 生成长度的设置下，DualCache 实现了 27.6x 端到端加速。 PrefixCache vs. DualCache:\nDualCache 通常比只缓存前缀的 PrefixCache 实现更高的加速比，尤其是在长序列生成任务中 。 缓存块大小的影响:\nsmall block size：准确率最高，但因频繁更新缓存导致开销较大，速度提升有限 。 small block size：速度快，但可能因上下文不匹配导致准确率下降 。 实验发现，块大小为 32 时在速度和精度之间取得了最佳平衡。 Impact of Cache Block Size on Accuracy and Throughput\n动态阈值 vs. 固定步数策略: 论文提出的 置信度感知并行解码 策略，在性能上持续优于每步固定解码 K 个 token 的 baseline 方法。 在达到相似甚至更高准确率的同时，该动态策略能实现更高的平均每步解码 token 数，从而获得更高的吞吐量。 Threshold VS Fxied Step\n5. Related Work 本章节回顾了与 Fast-dLLM 相关的两个核心领域：扩散语言模型的发展，以及大语言模型的通用加速技术。\n5.1. Diffusion LLM 扩散模型作为一种强大的生成范式，最初在图像和音频等连续数据领域取得了巨大成功，随后其影响力扩展到了 NLP. 特别是离散扩散模型的最新进展为大语言模型提供了一种替代自回归 (AR) 范式的可行方案 。\n理论基础的发展:\n离散数据的扩散模型最早由 [29, 11] 探索 。 D3PM 提出了一个更通用的框架，将前向加噪过程建模为离散状态马尔可夫链，并通过最大 ELBO 来学习反向过程。 CTMC 将 D3PM 扩展到连续时间设定 。 SEDD 采用了不同的方法，通过参数化边际似然比来学习反向过程 。 MDMs 近期受到了广泛关注，其中 MDLM 和 RADD 的研究表明，MDMs 的不同参数化方法是等价的，并且其训练目标可以被简化 。 与预训练语言模型的结合: 一个关键的突破是将离散扩散与现有的大语言模型架构相结合 。\nDiffusion-NAT [40] 将离散扩散的去噪过程与 BART 的非自回归解码相结合，通过迭代式地优化被掩码的 token ，实现了比同类自回归 Transformer 快20倍的生成速度 。 LLaDA [21]、DiffuLLaMA [7] 和 Dream [36] 等框架将扩散模型扩展到了 7B 参数的规模，通过在扩散时间步上进行递归式的 token 预测，展现了与 LLaMA3 等主流自回归模型相匹敌的性能 。 5.2. LLM Acceleration KV Cache 由于 LLaDA 等扩散语言模型采用的是 full attention，将 KV 缓存直接应用于这类模型并非易事。 一篇相关的研究 Block diffusion 通过分块生成 (block-by-block) 的方式，克服了先前扩散语言模型的局限，使得缓存和复用先前已解码块的键和值成为可能 。\nNon-Autoregressive Generation 非自回归 (NAR) 生成标志着一种根本性的转变，它通过同时生成多个 token 来显著加速推理过程。NAR 方法最初被用于神经机器翻译，现已扩展到语法纠错、文本摘要和对话系统等多种任务 。 尽管 NAR 在速度上优势巨大，但它通常以牺牲一定的生成质量为代价。扩散语言模型是 NAR 领域一个新兴的范式；然而，先前的工作 (如 LLaDA) 在实践中难以实现预期的加速，因为并行生成会导致输出质量显著下降。\nWeakness 近似缓存的误差累积效应：论文证明了在相邻步骤中，KV激活值的差异很小 。但随着生成块的增多，这种“近似”带来的微小误差是否会累积，并在生成非常长的文本 (如数万 token 的小说) 时导致语义漂移或一致性下降？论文的最长测试序列为1024 ，对于更长的序列，其鲁棒性有待进一步验证。\n对模型能力的依赖：“置信度感知解码”策略的有效性，隐式地依赖于模型本身具有良好的“校准度” (calibration) ，即模型的置信度能够真实反映其预测的正确性。如果模型本身“过于自信”或“不够自信”，可能会导致该策略效果不佳。论文没有对所用模型的校准度进行分析。 定理一的理论与实践差距：论文坦诚地指出了定理一的局限性\nIn practice, while MDM may not strictly satisfy this property, its behavior typically offers a close approximation.\n理论证明假设了一个“理想的”联合概率分布，而真实模型是否以及在多大程度上符合这个理想假设，是一个需要进一步探究的问题。理论和实践之间的差距可能在某些刁钻的 (adversarial) 或分布外 (Out-of-Distribution) 的场景下被放大。 超参数的敏感性与调优成本：尽管论文分析了块大小和阈值的影响，但并未提供一套系统性的方法来为新模型或新任务选择最佳超参数。在实际应用中，这可能意味着需要为每个特定用例进行成本不菲的网格搜索 (grid search) ，增加了方法的应用门槛。 评估维度的局限性：论文主要使用了基于准确率的基准测试。但在开放式生成、对话等任务中，评估指标 (如流畅度、一致性、多样性) 更为复杂。Fast-dLLM是否会在这些“软”指标上引入不易察觉的负面影响，需要更全面的评估。\nSource Code 初始化:\n函数首先创建一个张量 x，其长度为“提示词长度 + 待生成长度”。 提示词 (prompt) 部分被填充到 x 的开头，而所有待生成的位置则被初始化为特殊的掩码标记 [MASK] (mask_id) 。 将总生成任务分解为多个块 (num_blocks) ，并为每个块分配固定的解码步数 (steps) 分块生成 (外层循环):\n代码以块为单位进行循环，依次生成每个文本块。 处理单个块 (内层循环与缓存机制):\n步骤 A: 全局缓存初始化 (第一次模型调用)\n在处理一个新块的开始，它首先将整个序列 x (包含提示词、已生成的块和所有未来待生成的[MASK]块) 完整地输入模型。 这次调用的主要目的是计算并存储整个序列的键值对缓存 (past_key_values). 这是一个全局缓存。 然后，模型根据输出的 logits，使用 get_transfer_index 函数决定在当前块中，哪些 [MASK] 标记应该被优先替换掉 (例如，基于最高置信度的预测) ，并用预测出的 token (token) 进行填充。这个过程只发生一次。 步骤 B: 块内迭代优化 (第二次及后续模型调用)\n接下来，进入一个 while 循环，对当前块进行迭代式地“精炼”，直到这个块中所有的 [MASK] 标记都被填满。 核心优化点：在这次及后续的模型调用中，不再需要输入整个序列。它只将当前块的张量 (x[:, current_block_start:current_block_end]) 作为输入，并重用步骤 A 中生成的全局缓存 past_key_values。 这就是 dual cache: 一个为上下文 (提示词+之前块) 准备的、基本不变的静态缓存，和一个为当前块服务的、动态更新的缓存。这避免了对上下文部分的重复计算，极大地提升了效率。 模型会为当前块中剩余的 [MASK] 位置生成新的预测，并根据策略继续填充。 这个迭代过程会持续进行，直到当前块不再有 [MASK] 标记为止。 完成与返回:\n当所有块都处理完毕后，函数返回最终生成的完整序列 x 和总的模型前向传播次数 nfe (一个衡量计算成本的指标) 。 import torch @torch.no_grad() def generate_with_dual_cache(model, prompt, steps=128, gen_length=128, block_length=128, temperature=0., remasking='low_confidence', mask_id=126336, threshold=None): ''' Generates text using a non-autoregressive, block-wise decoding strategy with a dual-cache mechanism. Args: model: The mask predictor model. prompt: A tensor of shape (1, L) representing the input prompt. steps: Total number of sampling/refinement steps for the entire generation. gen_length: The desired length of the generated text. block_length: The size of each block to be generated in parallel. gen_length must be divisible by this. temperature: Sampling temperature for token selection. 0 means greedy decoding. remasking: The strategy for choosing which masks to fill ('low_confidence' or 'random'). mask_id: The token ID for the [MASK] token. ''' # Create the full tensor 'x' with the prompt and space for generation, initialized with the mask token. x = torch.full((1, prompt.shape[1] + gen_length), mask_id, dtype=torch.long).to(model.device) # Copy the prompt into the beginning of the tensor 'x'. x[:, :prompt.shape[1]] = prompt.clone() # Ensure that the generation length can be evenly divided into blocks. assert gen_length % block_length == 0 num_blocks = gen_length // block_length # Distribute the total steps among the blocks. assert steps % num_blocks == 0 steps_per_block = steps // num_blocks # nfe: Number of Forward-pass Evaluations. A counter for computational cost. nfe = 0 # Outer loop: iterate through each block to be generated. for num_block in range(num_blocks): # Define the start and end positions of the current block within the full tensor 'x'. current_block_start = prompt.shape[1] + num_block * block_length current_block_end = current_block_start + block_length # Find the indices of mask tokens within the current block. block_mask_index = (x[:, current_block_start:current_block_end] == mask_id) # Determine the number of tokens to fill at each refinement step for this block. num_transfer_tokens = get_num_transfer_tokens(block_mask_index, steps_per_block) # --- First Model Call: Initialize Global Cache --- # A single forward pass on the ENTIRE sequence (prompt + all masked blocks) to pre-calculate # the Key-Value cache for all tokens. This is the \"global\" cache. output = model(x, use_cache=True) past_key_values = output.past_key_values # Identify all mask tokens up to the end of the current block. mask_index = (x == mask_id) # Ignore masks that are in future blocks for this step's prediction. mask_index[:, current_block_end:] = 0 # Select which tokens to predict and fill in this initial step for the current block. x0, transfer_index = get_transfer_index(output.logits, temperature, remasking, mask_index, x, num_transfer_tokens[:, 0] if threshold is None else None, threshold) # Update the tensor 'x' by filling the selected mask positions with the predicted tokens. x[transfer_index] = x0[transfer_index] nfe += 1 # Increment the forward-pass counter. i = 1 # Counter for refinement steps within the block. # A boolean mask indicating the position of the current block, used to update the cache efficiently. replace_position = torch.zeros_like(x, dtype=torch.bool) replace_position[:, current_block_start:current_block_end] = 1 # --- Inner Loop: Iterative Refinement of the Current Block --- # This loop continues until all masks in the current block are filled. while True: nfe += 1 # Increment the forward-pass counter for each refinement step. # Find the remaining masks ONLY within the current block. mask_index_block = (x[:, current_block_start:current_block_end] == mask_id) # --- Efficient Model Call using Dual Cache --- # Instead of passing the whole sequence, only pass the CURRENT BLOCK's tokens. # Reuse the 'past_key_values' (global cache) computed earlier. The model internally # uses 'replace_position' to update the cache only at the current block's location. # This is the \"dual cache\" trick, avoiding re-computation for the prompt and previous blocks. logits = model(x[:, current_block_start:current_block_end], past_key_values=past_key_values, use_cache=True, replace_position=replace_position).logits # Select which of the remaining masks to fill in this refinement step. x0, transfer_index = get_transfer_index(logits, temperature, remasking, mask_index_block, x[:, current_block_start:current_block_end], num_transfer_tokens[:, i] if threshold is None else None, threshold) # Update the current block with the newly predicted tokens. x[:, current_block_start:current_block_end][transfer_index] = x0[transfer_index] # If there are no more masks in the current block, exit the refinement loop. if (x[:, current_block_start:current_block_end] == mask_id).sum() == 0: break i += 1 # Move to the next refinement step. # Return the fully generated sequence and the total number of model evaluations. return x, nfe ",
  "wordCount" : "10115",
  "inLanguage": "en",
  "datePublished": "2025-06-12T23:01:49+08:00",
  "dateModified": "2025-06-22T17:53:30+08:00",
  "author":[{
    "@type": "Person",
    "name": "WITHER"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/blogs/fast-dllm/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "WITHER",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="WITHER (Alt + H)">WITHER</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="http://localhost:1313/zh/" title="简体中文"
                            aria-label="简体中文">简体中文</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/" title="🏠 Home">
                    <span>🏠 Home</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/about_me/" title="🙋🏻‍♂️ Me">
                    <span>🙋🏻‍♂️ Me</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/blogs/" title="📚 Blogs">
                    <span>📚 Blogs</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/categories/" title="🧩 Categories">
                    <span>🧩 Categories</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="🔖 Tags">
                    <span>🔖 Tags</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/archives/" title="⏱ Archive">
                    <span>⏱ Archive</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="🔍 Search (Alt &#43; /)" accesskey=/>
                    <span>🔍 Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/friends/" title="🤝 Friends">
                    <span>🤝 Friends</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/blogs/">Blogs</a></div>
    <h1 class="post-title entry-hint-parent">
      Fast-dLLM
    </h1>
    <div class="post-description">
      Paper Reading of Fast-dLLM
    </div>
    <div class="post-meta"><span title='2025-06-12 23:01:49 +0800 CST'>Jun-12-2025</span>&nbsp;·&nbsp;21 min&nbsp;·&nbsp;10115 words&nbsp;·&nbsp;WITHER

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">Table of Contents</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#introduction" aria-label="Introduction">Introduction</a></li>
                    <li>
                        <a href="#2-preliminary" aria-label="2. Preliminary">2. Preliminary</a><ul>
                            <ul>
                            
                    <li>
                        <a href="#21-masked-diffusion-model" aria-label="2.1. Masked Diffusion Model">2.1. Masked Diffusion Model</a></li>
                    <li>
                        <a href="#22-mdms-%e7%9a%84%e7%94%9f%e6%88%90%e8%bf%87%e7%a8%8b" aria-label="2.2. MDMs 的生成过程">2.2. MDMs 的生成过程</a></li></ul>
                        </ul>
                    </li>
                    <li>
                        <a href="#3-methodology" aria-label="3. Methodology">3. Methodology</a><ul>
                            
                    <li>
                        <a href="#31-pipeline-overview" aria-label="3.1. Pipeline Overview">3.1. Pipeline Overview</a></li>
                    <li>
                        <a href="#32-key-value-cache-for-block-wise-decoding" aria-label="3.2. Key-Value Cache for Block-Wise Decoding">3.2. Key-Value Cache for Block-Wise Decoding</a></li>
                    <li>
                        <a href="#33-confidence-aware-parallel-decoding" aria-label="3.3. Confidence-Aware Parallel Decoding">3.3. Confidence-Aware Parallel Decoding</a></li></ul>
                    </li>
                    <li>
                        <a href="#4-experiments" aria-label="4. Experiments">4. Experiments</a><ul>
                            
                    <li>
                        <a href="#41-experimental-setup" aria-label="4.1 Experimental Setup">4.1 Experimental Setup</a></li>
                    <li>
                        <a href="#42-main-results-performance-and-speed" aria-label="4.2 Main Results: Performance and Speed">4.2 Main Results: Performance and Speed</a></li>
                    <li>
                        <a href="#43-ablations-and-analysis" aria-label="4.3 Ablations and Analysis">4.3 Ablations and Analysis</a></li></ul>
                    </li>
                    <li>
                        <a href="#5-related-work" aria-label="5. Related Work">5. Related Work</a><ul>
                            
                    <li>
                        <a href="#51-diffusion-llm" aria-label="5.1. Diffusion LLM">5.1. Diffusion LLM</a></li>
                    <li>
                        <a href="#52-llm-acceleration" aria-label="5.2. LLM Acceleration">5.2. LLM Acceleration</a></li></ul>
                    </li>
                    <li>
                        <a href="#weakness" aria-label="Weakness">Weakness</a></li>
                    <li>
                        <a href="#source-code" aria-label="Source Code">Source Code</a>
                    </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    
    document.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();
    
        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
        if (elements.length > 0) {
            
            activeElement = elements[0];
            const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
            document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
        }
    
        
        const topLink = document.getElementById('top-link');
        if (topLink) {
            topLink.addEventListener('click', (event) => {
                
                event.preventDefault();
    
                
                window.scrollTo({ top: 0, behavior: 'smooth' });
            });
        }
    }, false);
    
    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);
    
    window.addEventListener('scroll', () => {
        
        const scrollPosition = window.pageYOffset || document.documentElement.scrollTop;
    
        
        if (scrollPosition === 0) {
            return;
        }
    
        
        if (elements && elements.length > 0) {
            
            activeElement = Array.from(elements).find((element) => {
                if ((getOffsetTop(element) - scrollPosition) > 0 && 
                    (getOffsetTop(element) - scrollPosition) < window.innerHeight / 2) {
                    return element;
                }
            }) || activeElement;
    
            elements.forEach(element => {
                const id = encodeURI(element.getAttribute('id')).toLowerCase();
                const tocLink = document.querySelector(`.inner ul li a[href="#${id}"]`);
                if (element === activeElement){
                    tocLink.classList.add('active');
    
                    
                    const tocContainer = document.querySelector('.toc .inner');
                    const linkOffsetTop = tocLink.offsetTop;
                    const containerHeight = tocContainer.clientHeight;
                    const linkHeight = tocLink.clientHeight;
    
                    
                    const scrollPosition = linkOffsetTop - (containerHeight / 2) + (linkHeight / 2);
                    tocContainer.scrollTo({ top: scrollPosition, behavior: 'smooth' });
                } else {
                    tocLink.classList.remove('active');
                }
            });
        }
    }, false);
    
    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);
    
    function checkTocPosition() {
        const width = document.body.scrollWidth;
    
        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }
    
    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
    
</script>

  <div class="post-content"><h1 id="introduction">Introduction<a hidden class="anchor" aria-hidden="true" href="#introduction">#</a></h1>
<p>Diffusion LLMs 被视为下一代文本生成技术的有力竞争者，其核心优势在于理论上可以并行生成多个 token，从而有望实现比自回归模型快几个数量级的推理速度。谷歌的 Gemini Diffusion 和 Inception Labs 的Mercury等模型已经展示了其惊人的潜力，宣称能达到每秒上千 token 的生成速度。</p>
<p>当前开源的扩散LLM (LLaDA、Dream) 在实际应用中的速度远远达不到预期，甚至比优化良好的自回归模型还要慢。这篇论文的工作，就是要拆掉阻碍扩散 LLM 起飞的两座大山。</p>
<ol>
<li>无法使用 KV Cache</li>
</ol>
<p>扩散LLM的注意力机制是双向的，即一个 token 的生成不仅依赖于它前面的内容，也依赖于它后面的内容 (尽管后面可能是未知的 MASK token ) 。这种特性使得过去的信息和未来的信息相互纠缠，无法像自回归模型那样简单地缓存和复用过去的信息。导致扩散LLM在每一步推理中都需要进行大量的重复计算，严重拖慢了速度。</p>
<p>Fast-dLLM 的第一个核心贡献，就是提出了一种分块近似 (block-wise approximate) KV Cache 机制。</p>
<blockquote class="quote"><p>While the bidirectional nature of attention in Diffusion LLMs precludes a fully equivalent KV Cache, our approximation closely resembles an ideal cache in practice.</p></blockquote>
<p>它将待生成的文本序列分成若干个块. 在生成某一个块 (比如Block 1) 时，它会提前计算并缓存其他所有块 (比如 Prompt 和 Block 0) 的 KV. 在这个块的内部生成过程中，这些缓存被反复利用。当这个块生成完毕后，再整体更新一次所有块的KV缓存 。</p>
<p>这个方法的近似在于，在一个块的生成过程中，缓存是固定的，而实际上随着块内 token 的不断去噪和清晰化，这些缓存理论上也应该随之微调。但论文通过可视化实验 (图3) 有力地证明，在相邻的推理步骤中，KV 激活值的 余弦相似度非常高，几乎接近于1. 这说明使用固定的近似缓存带来的误差微乎其微，完全可以用极小的精度损失换取巨大的速度提升。</p>
<p>论文还进一步提出了双缓存 (DualCache) 版本，不仅缓存了前面的“前缀” (prefix) ，还缓存了后面的“后缀” (suffix，通常是 MASK  token )  ，从而进一步压榨了计算优化的空间，实现了更快的速度。</p>
<ol start="2">
<li>并行解码带来的质量下降</li>
</ol>
<p>扩散LLM的另一大理论优势是 并行解码 (Parallel Decoding)，即一次性预测和生成多个 token  。然而，实践再次证明，当并行解码的 token 数量增多时，生成文本的质量会急剧下降 。</p>
<p>论文深刻地剖析了其根源：条件独立性假设 (conditional independence assumption) 的破坏 。在并行解码时，模型是独立地为每个待生成的 MASK 位置预测一个概率分布，然后从中采样。但实际上，一句话中的 token 之间存在着强烈的依赖关系。论文举了一个例子:</p>
<blockquote class="quote"><p>Consider an example from [30]: The list of poker hands that consist of two English words are: The subsequent two words could be, for instance, &ldquo;high card,&rdquo; &ldquo;two pair,&rdquo; &ldquo;full house,&rdquo; or &ldquo;straight flush.&rdquo; [&hellip;] However, the multi-token prediction procedure in MDMs first generates a probability distribution for each token and then samples from these distributions independently. This independent sampling can lead to undesirable combinations, such as &ldquo;high house.&rdquo;</p></blockquote>
<p>模型可能会独立地预测出 &ldquo;high&rdquo; 和 &ldquo;house&quot;这两个词，但把它们组合在一起就成了毫无意义的 high house. 这是因为模型在并行预测时忽略了 token 间的联合概率，而错误地直接使用了边缘概率的乘积。</p>
<p>为了解决这个问题，Fast-dLLM提出了第二个核心贡献：置信度感知并行解码 (Confidence-Aware Parallel Decoding) 策略 。这个想法非常直观且有效：我们只对那些模型非常有把握的 token 进行并行解码。</p>
<p>具体来说，在每一步解码时，模型会为每个待生成的 MASK 位置计算一个 置信度分数 (比如softmax概率的最大值). 然后，设定一个全局的置信度阈值 τ，只有那些置信度超过这个阈值的 token 才会被揭开，而置信度不足的 token 则继续保持 MASK 状态，留到下一步再做决策。为了避免无限循环，如果没有任何 token 的置信度达标，模型会强制解码置信度最高的那一个。</p>
<p>这个策略的精妙之处在于，它在理论上是站得住脚的。论文通过定理一从数学上证明了：当模型对一组 token 的预测置信度足够高时 (即 p&gt;1−ϵ，且 ϵ 足够小)，基于独立边缘概率的“贪心并行解码”与基于真实联合概率的“贪心串行解码”会得到完全相同的结果。</p>
<p>
<figure class="post-figure">
    <a href="https://share.note.youdao.com/yws/api/personal/file/WEBccefa918e999469a4faa3badff3c32b9?method=download&amp;shareKey=c9e48ddb1e1f0600394ce8baa1d84426" target="_blank" rel="noopener">
        <img loading="lazy" src="https://share.note.youdao.com/yws/api/personal/file/WEBccefa918e999469a4faa3badff3c32b9?method=download&amp;shareKey=c9e48ddb1e1f0600394ce8baa1d84426" alt="Effectiveness of Components of Fast-dLLM across Different Approaches">
    </a><figcaption>Effectiveness of Components of Fast-dLLM across Different Approaches</figcaption></figure></p>
<p>Fast-dLLM 的创新性体现在它是一种 training-free 的加速框架。它没有修改模型结构，也不需要重新训练，而是通过两项即插即用的推理策略——“分块近似KV缓存”和“置信度感知并行解码”，分别从减少重复计算和提升并行效率两个维度，精准地解决了当前开源扩散 LLM 面临的核心瓶颈。 实验结果在 LLaDA 和 Dream 等模型上，结合两种策略，实现了高达 27.6 倍的端到端吞吐量提升，同时在多个基准测试上几乎没有精度损失。</p>
<h1 id="2-preliminary">2. Preliminary<a hidden class="anchor" aria-hidden="true" href="#2-preliminary">#</a></h1>
<h3 id="21-masked-diffusion-model">2.1. Masked Diffusion Model<a hidden class="anchor" aria-hidden="true" href="#21-masked-diffusion-model">#</a></h3>
<p>针对离散数据的扩散模型最早在 Argmax Flows and Multinomial Diffusion 和 Deep Unsupervised Learning using
Nonequilibrium Thermodynamics 中被探提出。随后 D3PM 提出了一个更通用的框架，通过特定的转移矩阵 $Q_{t}$ 定义了前向加噪过程的离散状态马尔可夫链，并通过最大化 ELBO 来学习反向过程的参数化模型 $p_{\theta}(x_{0}|x_{t})$. CTMC 进一步将 D3PM 扩展到连续时间，将其形式化为一个连续时间马尔可夫链 (CTMC) 框架。在另一种不同的方法中，SEDD 通过参数化似然比 $\frac{p_{t}(y)}{p_{t}(x)}$ 来学习反向过程，并采用去噪分数熵来训练该比率。</p>
<p>在各种离散扩散的噪声处理方式中，<strong>Masked Diffusion Models, MDMs</strong>，也被称为吸收状态离散扩散模型，获得了相当大的关注。MDMs 采用一种前向加噪过程，其中 token 被逐步替换为一个特殊的 MASK  token  。这个过程由以下转移概率定义：</p>
$$
q_{t|0}(x_{t}|x_{0})=\prod_{i=1}^{n}q_{t|0}(x_{t}^{i}|x_{0}^{i})=\prod_{i=1}^{n}Cat(x_{t}^{i};(1-t)\delta_{x_{0}^{i}}+t\delta_{[MASK]}) \tag{1}
$$<ul>
<li>$q_{t|0}(x_t|x_0)$: 表示给定原始序列 $x_0$，得到噪声序列 $x_t$ 的概率 。</li>
<li>$\prod_{i=1}^{n}$: 连乘符号，表示整个序列的噪声过程是序列中每个 token  (token) 独立进行噪声过程的概率乘积 。</li>
<li>$Cat(\cdot)$: 代表<strong>类别分布 (Categorical Distribution)</strong> 。</li>
<li>$t \in [0,1]$: 表示<strong>扩散时间</strong>或<strong>掩码级别</strong>。当 $t=0$ 时，序列完全是原始的；当 $t=1$ 时，序列被完全替换为 <code>[MASK]</code>  token 。</li>
<li>$(1-t)\delta_{x_{0}^{i}}+t\delta_{[MASK]}$: 在时间 <code>t</code>，第 <code>i</code> 个 token 有 $1-t$ 的概率保持其原始身份 $x_0^i$，有 $t$ 的概率变成 <code>[MASK]</code>  token 。<code>$\delta$</code> 是克罗内克函数，用于指定概率。</li>
</ul>
<p>最近，MDLM 和 RADD 的工作表明，对于 MDMs 不同的参数化是等价的。此外，他们证明了 MDMs 的训练目标可以被简化或直接从数据似然中推导出来 。这导出了以下目标函数，即 $log~p_{\theta}(x)$ 的一个 ELBO:</p>
<details class="custom-details">
    <summary class="custom-summary">Reparameterized Absorbing Discrete Diffusion, RADD</summary>
    <div><p><strong>定理 1（Theorem 1）</strong>
</p>
$$
\frac{p_t(\hat{x}_t)}{p_t(x_t)} = \underbrace{\frac{e^{-\bar{\sigma}(t)}}{1-e^{-\bar{\sigma}(t)}}}_{\text{时间相关的标量}} \cdot \underbrace{p_0(\hat{x}_t^i | x_t^{UM})}_{\text{干净数据的条件概率}}
$$<ul>
<li>$p_t(x_t)$ 是时间步 $t$ 的数据分布</li>
<li>$x_t$ 是带噪声（被掩码）的序列</li>
<li>$x_t^{UM}$ 是其中未被掩码的部分</li>
<li>$\hat{x}_t$ 是在 $x_t$ 的一个掩码位置上填入一个新 token 后的序列</li>
<li>$p_0$ 是原始干净数据的分布，$\bar{\sigma}(t)$ 是一个与噪声水平相关的函数。</li>
</ul>
<p>这个公式表明，模型需要学习的目标可以分解。其中一部分是一个可以精确计算的、只与时间 $t$ 有关的标量，而另一部分则是一个<strong>与时间无关</strong>的、在给定其他可见 token 的条件下，预测被掩码 token 的条件概率。正是LLM 所做的事情。这个看似简单的改动带来了巨大的实际优势：</p>
<ol>
<li><strong>架构简化</strong>：移除了时间编码和相关的自适应归一化层，使得模型参数更少，结构更简洁 。</li>
<li><strong>采样加速</strong>：由于模型输出不再依赖于时间 $t$，当输入序列 $x_t$ 在某个采样区间内没有发生变化时，可以直接缓存上一步的计算结果，而无需再次调用网络。这极大地减少了<strong>函数评估次数（Number of Function Evaluations, NFEs）</strong>。论文给出了在特定采样策略下，期望函数评估次数（E-NFEs）的解析公式 ：</li>
</ol>
$$
E\text{-}NFEs(n) = n \left( 1 - \left( 1 - \frac{1}{n} \right)^l \right)
$$<p><strong>定理 2（Theorem 2）</strong></p>
<p>证明了吸收态扩散模型的训练目标（具体来说是 DSE 损失）在数学上等价于**任意阶自回归模型（Any-Order Autoregressive Models, AO-ARMs）**的训练目标 。</p>
<p>AO-ARMs 是一类特殊的生成模型，它们不像标准自回归模型那样固定从左到右的生成顺序，而是学习在所有可能的 $d!$（$d$ 为序列长度）种生成顺序下对数据进行建模。论文通过一系列精巧的数学推导，建立了四种不同损失函数之间的等价关系链 ：</p>
<p>$\mathcal{L}_{DSE} \iff \mathcal{L}_{t-DCE} \iff \mathcal{L}_{\lambda-DCE} \iff \mathcal{L}_{AO}$</p>
<p>它表明吸收态扩散模型本质上是在学习一个集成了所有可能生成顺序的自回归模型的期望 。这可能解释了为什么它们在某些任务上表现得非常稳健。</p>
</div>
</details><br>
$$
-log~p_{\theta}(x)\le\int_{0}^{1}\frac{1}{t}\mathbb{E}_{q_{t,0}(x_{t}|x_{0})}[\sum_{i:x_{t}^{i}=[MASK]}-log~p_{\theta}(x_{0}^{i}|x_{t})]dt:=\mathcal{L}_{MDM}. \tag{2}
$$<ul>
<li>$-log~p_{\theta}(x)$: 模型的目标是最大化生成真实数据 $x$ 的对数似然，这等价于最小化它的负对数似然。这个公式给出了负对数似然的一个* ELBO.</li>
<li>$\int_{0}^{1}...dt$: 对所有可能的噪声级别 <code>t</code> (从0到1) 进行积分，意味着模型需要学会在任何噪声水平下都能很好地复原数据 。</li>
<li>$\mathbb{E}_{q_{t,0}(x_{t}|x_{0})}[...]$: 表示对所有可能的噪声样本求期望。在训练时，我们根据公式(1)随机生成一个带 <code>[MASK]</code> 的噪声序列 $x_t$.</li>
<li>$\sum_{i:x_{t}^{i}=[MASK]}-log~p_{\theta}(x_{0}^{i}|x_{t})$:
<ul>
<li>$\sum_{i:x_{t}^{i}=[MASK]}$: 对所有被 <code>[MASK]</code> 的位置 <code>i</code> 进行求和 。</li>
<li>$-log~p_{\theta}(x_{0}^{i}|x_{t})$: 这是交叉熵损失。它的意思是，给定带有 <code>[MASK]</code> 的序列 $x_t$，模型 $p_{\theta}$ 需要预测在位置 i 上的原始 token  $x_0^i$ 应该是什么。模型预测得越准，这个损失值就越小。</li>
</ul>
</li>
</ul>
<h3 id="22-mdms-的生成过程">2.2. MDMs 的生成过程<a hidden class="anchor" aria-hidden="true" href="#22-mdms-的生成过程">#</a></h3>
<p>对于公式1中定义的前向过程，其解析上的逆过程在生成时计算效率低下，因为它通常每步只修改一个 token 。一个常见的加速策略是采用 $\tau$-leaping 近似法来处理反向过程。在 MDMs 的背景下，这允许一个迭代式的生成过程，其中多个被掩码的 token 可以从一个噪声水平 t 近似地单步恢复到一个更早的水平 s &lt; t.</p>
$$
q_{s|t}(x_s|x_t)=\prod_{i=0}^{n-1}q_{s|t}(x_{s}^{i}|x_{t})
$$<p>其中</p>
$$
q_{s|t}(x_{s}^{i}|x_{t})=\begin{cases}1, & \text{if } x_{t}^{i}\ne[MASK], x_{s}^{i}=x_{t}^{i} \\ \frac{s}{t}, & \text{if } x_{t}^{i}=[MASK], x_{s}^{i}=[MASK] \\ \frac{t-s}{t}q_{0|t}(x_{s}^{i}|x_{t}), & \text{if } x_{t}^{i}=[MASK], x_{s}^{i}\ne[MASK]\end{cases} \tag{3}
$$<ul>
<li>$q_{s|t}(x_{s}^{i}|x_{t})$: 表示从 <code>t</code> 时刻的 token  $x_t^i$ 变为 <code>s</code> 时刻的 token  $x_s^i$ 的概率 。</li>
<li><strong>Case 1</strong>: 如果一个 token 在 <code>t</code> 时刻就不是 <code>[MASK]</code>，那么它在更早的 <code>s</code> 时刻也保持不变 。</li>
<li><strong>Case 2</strong>: 一个在 t 时刻是 <code>[MASK]</code> 的 token ，在更早的 s 时刻仍然是 <code>[MASK]</code>.</li>
<li><strong>Case 3</strong>: 这是关键的去噪步骤。如果一个 token 在 <code>t</code> 时刻是 <code>[MASK]</code>，模型会尝试在 s 时刻预测出一个具体的 token.
<ul>
<li>$\frac{t-s}{t}$: 代表一个在 <code>t</code> 时刻被掩码的 token，在 <code>s</code> 时刻被“揭示”出来的概率 。</li>
<li>$q_{0|t}(x_{s}^{i}|x_{t})$: 这是由神经网络模型给出的预测分布。模型会观察整个带有 <code>[MASK]</code> 的上下文 $x_t$，然后为当前位置预测一个最有可能的原始 token ，并给出一个在整个词汇表上的概率分布 。</li>
</ul>
</li>
</ul>
<p>在涉及条件数据的场景中，例如根据一个 propmt p 生成一个回应 $x_{0}$，MDM 的反向过程 (公式3所定义) 需要进行调整。具体来说，模型用于揭示一个 token  $x_{s}^{i}$ 的预测分布 $q_{0|t}(x_{s}^{i}|x_{t})$ 现在也需要以 prompt p 为条件，即 $q_{0|t}(x_{s}^{i}|x_{t},p)$ 。</p>
<p><strong>并行解码的诅咒</strong>
直接逆转公式1的前向过程来进行生成是缓慢的，通常每步只改变一个 token. 一个常见的加速策略是采用 $\tau$-leaping 近似法来处理反向过程。对于 MDMs，这意味着多个被掩码的 token 将在一个步骤中并行生成。然而，由于条件独立性假设，多 token 预测中出现了一个重大挑战。考虑一个例子：由两个英文单词组成的扑克手牌列表是：随后的两个词可能是，例如，high card，two pair，full house，或 straight flush. 值得注意的是，这两个词之间存在着关联。然而，MDMs 中的多 token 预测过程首先为每个 token 生成一个概率分布，然后独立地从这些分布中进行采样。这种独立采样可能导致不希望的组合，例如 high house.</p>
<p>为了将其形式化，考虑揭示两个 token 位置 i 和 j. 由于条件独立性假设，MDMs 从 $p(x_{s}^{i}|x_{t})\cdot p(x_{s}^{j}|x_{t})$ 中采样这些 token. 然而，真实的联合概率需要考虑它们之间的依赖关系：</p>
$$
p(x_{s}^{i},x_{s}^{j}|x_{t})=p(x_{s}^{i}|x_{t})\cdot p(x_{s}^{j}|x_{t},x_{s}^{i})
$$<p>或者对称地，通过将 i 依赖于条件 j. 这种假设的独立生成与真实的依赖性数据分布之间的差异，会降低生成序列的质量和连贯性。当在单一步骤中同时揭示大量 token 时，这个问题会变得更加严重。</p>
<h1 id="3-methodology">3. Methodology<a hidden class="anchor" aria-hidden="true" href="#3-methodology">#</a></h1>
<h2 id="31-pipeline-overview">3.1. Pipeline Overview<a hidden class="anchor" aria-hidden="true" href="#31-pipeline-overview">#</a></h2>
<p><strong>Fast-dLLM</strong>，建立在 MDM 架构之上，以实现高效和高质量的序列生成。为了加速推理，整体流水线融合了两大关键策略：通过 KV Cache 实现的高效注意力计算，以及一个由预测置信度引导的 并行解码方案。具体来说，我们采用了分块解码设计的 KV Cache，它允许在不同步骤间复用注意力激活值，并显著减少了冗余计算。在每个块内部，进一步提出了置信度感知的并行解码，它能根据置信度分数选择性地更新 token ，从而在保持输出质量的同时提高效率。通过结合这些策略，Fast-dLLM 在对生成性能影响最小的情况下，显著加快了 MDM 的推理速度。整体流程在算法 1 中进行了总结。</p>
<h2 id="32-key-value-cache-for-block-wise-decoding">3.2. Key-Value Cache for Block-Wise Decoding<a hidden class="anchor" aria-hidden="true" href="#32-key-value-cache-for-block-wise-decoding">#</a></h2>
<p>
<figure class="post-figure">
    <a href="https://share.note.youdao.com/yws/api/personal/file/WEBe66f192a665248e7559ffa12a0bf10c1?method=download&amp;shareKey=8952caa17d664bd8bcc33b9ebcec321e" target="_blank" rel="noopener">
        <img loading="lazy" src="https://share.note.youdao.com/yws/api/personal/file/WEBe66f192a665248e7559ffa12a0bf10c1?method=download&amp;shareKey=8952caa17d664bd8bcc33b9ebcec321e" alt="Illustration of our Key-Value Cache for Block-Wise Decoding">
    </a><figcaption>Illustration of our Key-Value Cache for Block-Wise Decoding</figcaption></figure></p>
<p>如上图所示，我们采用了一种分块解码的策略来支持 KV Cache 的使用。一开始计算并存储 prompt 的 KV 缓存，这个缓存将在整个块 0的解码过程中被复用。在每个块的内部，相同的缓存会被多个解码步骤复用。<strong>在完成一个块的解码之后，更新所有 token (不仅仅是新生成的 token) 的缓存</strong>。这个缓存更新可以与解码步骤联合执行，因此与不使用缓存相比，没有额外的计算开销。由于掩码扩散模型中使用的是完全注意力机制，这种方法导致了一个近似的解码过程。</p>
<p>我们的近似 KV 缓存方法的有效性，源于我们观察到 KV 激活值在相邻的推理步骤中表现出高度的相似性，如下图所示。图 a 中红色方框区域突显了块内的相似性分数，这些分数始终接近于 1. 表明在分块解码期间，前缀 (prefix) 的键和值的差异可以忽略不计，使我们能够安全地复用缓存而不会有显著的准确率损失。 此外，我们实现了一个我们 KV 缓存机制的双向版本，名为 <strong>DualCache</strong>，它不仅缓存前缀 token ，还缓存后缀 (suffix)  token ，在我们的分块解码方案中，后缀完全由掩码 token 组成。如表3所示，DualCache 带来了进一步的加速。图 b 中的红色方框区域进一步证明，在分块解码期间，后缀的键和值的差异也可以忽略不计。</p>
<p>
<figure class="post-figure">
    <a href="https://share.note.youdao.com/yws/api/personal/file/WEB2030e80c11d3d306e335a2dc5931b101?method=download&amp;shareKey=6a5005c556aaa11edb4006a48b755b4a" target="_blank" rel="noopener">
        <img loading="lazy" src="https://share.note.youdao.com/yws/api/personal/file/WEB2030e80c11d3d306e335a2dc5931b101?method=download&amp;shareKey=6a5005c556aaa11edb4006a48b755b4a" alt="Heatmaps of Key-Value Activation Cosine Similarity Across Inference Steps in LLaDA">
    </a><figcaption>Heatmaps of Key-Value Activation Cosine Similarity Across Inference Steps in LLaDA</figcaption></figure></p>
<h2 id="33-confidence-aware-parallel-decoding">3.3. Confidence-Aware Parallel Decoding<a hidden class="anchor" aria-hidden="true" href="#33-confidence-aware-parallel-decoding">#</a></h2>
<p>尽管存在一些方法，例如使用辅助模型来显式地捕捉不同位置 token 之间的依赖关系，但它们通常会增加整个流水线的复杂性。与这些方法相反，我们提出了一个简单而有效的<strong>置信度感知解码算法</strong>，旨在缓解这种条件独立性问题。</p>
<p>在每次迭代中，我们不是冒然地使用它们独立的边缘概率来揭示所有被掩码的 token ，而是为每个 token 计算一个置信度分数 (例如最大的 softmax 概率). 只有那些置信度超过一个阈值的 token 才会在当前步骤被揭示；其余的则保持掩码状态，并在未来的步骤中重新考虑。如果没有 token 的置信度超过阈值，就揭示置信度最高的那一个，以确保过程能够进行并防止无限循环。这个策略在加速生成的同时，减少了由不确定或模糊预测引起的错误。</p>
<p>一个关键问题是</p>
<blockquote class="quote"><p><em>When is it theoretically justifiable to decode tokens in parallel using independent marginals, despite the true joint distribution potentially containing dependencies?</em></p></blockquote>
<p>以下结果来回答了在高置信度情况下，greedy parallel 解码等同于 greedy sequential 解码的条件，并量化了两种分布之间的差异。在给出定理之前，我们将定义其表述中使用的数学符号。</p>
<p>设 $p_{\theta}(\cdot|E)$ 表示一个 MDM 在给定 E (包括 prompt $p_{0}$ 和先前生成的 token) 的条件下给出的 PMF. 假设模型要为不在 E 中的位置 $i_{1},...,i_{n}$ 预测 n 个 token.</p>
<p>令 $X=(X_{i_{1}},...,X_{i_{n}})$ 是 n 个 token 的向量，其中每个 $X_{i_{j}}$ 在词汇表 V 中取值。设 $p(X|E)\equiv p_{\theta}(X_{i_{1}},...,X_{i_{n}}|E)$ 是模型给出的联合条件 PMF。设 $p_{j}(X_{i_{j}}|E)\equiv p_{\theta}(X_{i_{j}}|E)$ 是位置 $i_{j}$ 的边缘条件 PMF。并行解码使用边缘概率的乘积来生成 token ：$q(X|E)=\tilde{\prod}_{j=1}^{n}p_{j}(X_{i_{j}}|E)$。定理1的证明及相关讨论见附录A。</p>
<p><strong>定理 1 (高置信度下的并行解码).</strong> 假设存在一个特定的 token 序列 $x^{*}=(x_{i_{1}},...,x_{i_{n}})$，使得对于每个 $j\in\{1,...,n\}$，模型对 $x_{i_{j}}$ 都有很高的置信度：$p_{j}(X_{i_{j}}=x_{i_{j}}|E)>1-\epsilon$，对于某个很小的 $\epsilon>0$. 那么，以下结论成立：</p>
<ol>
<li><em>Equivalence of Greedy Decoding</em>：如果 $(n+1)\epsilon\le1$ (即 $\epsilon\le\frac{1}{n+1}$) ，那么
$$
\text{argmax}_{z} p(z|E) = \text{argmax}_{z} q(z|E) = x^{*}. \tag{4}
$$</li>
</ol>
<p>这意味着 greedy parallel 解码 (选择 argmax q) 与贪婪序贯解码 (选择 argmax p) 产生相同的结果。  这个界是紧的：如果 $\epsilon > \frac{1}{n+1}$，则存在满足高置信度边缘假设的分布 $p(X|E)$，使得 argmax $p(z|E)$ ≠ argmax $q(z|E)$。</p>
<ol start="2">
<li><em>Distance and Divergence Bounds</em>：为简洁起见，将 $p(\cdot|E)$ 和 $q(\cdot|E)$ 表示为 p 和 q.</li>
</ol>
<p><strong>$L_p$ Distance ($p \ge 1$)</strong>: 对于 $n>1$，$D_{p}(p,q)<((n-1)^{p}+2n)^{1/p}\epsilon$。特别地，对于总变差距离 ($D_{TV}(p,q)=\frac{1}{2}D_{1}(p,q)$)，$D_{TV}(p,q)<\frac{3n-1}{2}\epsilon$.</p>
<p>这个公式说明，<strong>真实分布 p 和近似分布 q 之间的总变差距离有一个上限</strong>。这个上限取决于两个因素：</p>
<ol>
<li>$n$: 生成序列的长度。序列越长，这个上限就越大。这是符合直觉的，因为每增加一个 token，近似所累积的潜在误差就可能增加一点。</li>
<li>$\epsilon$: 模型在每个位置上的“不确定性”。$\epsilon$ 越小 (即模型越自信)，这个上限就越低。</li>
</ol>
<p><strong>Forward KL Divergence</strong>: 对于 $n > 1$，$D_{KL}(p||q)<(n-1)(H_{b}(\epsilon)+\epsilon~ln(|\mathcal{V}|-1))$，其中 $H_{b}(\epsilon)=-\epsilon~ln~\epsilon-(1-\epsilon)ln(1-\epsilon)$ 是二元熵函数，而 $|\mathcal{V}|$ 是词汇表的大小。</p>
<ol>
<li>$n-1$: 同样，损失会随着序列长度线性增长。</li>
<li>$H_{b}(\epsilon)$: 它衡量了一个概率为 $\epsilon$ 的事件带来的“意外程度”或不确定性。当 $\epsilon$ 很小时，$H_b(\epsilon)$ 也非常小。</li>
<li>$\epsilon~ln(|\mathcal{V}|-1)$: 这一项反映了那部分微小的 $\epsilon$ 概率被分配到词汇表 $\mathcal{V}$ 中其他所有 token 上所带来的不确定性。即使 $\epsilon$ 很小，如果词汇表非常巨大 ($|\mathcal{V}|$ 很大)，这一项也可能有影响。</li>
</ol>
<hr>
<ul>
<li>$L_p$ 距离说明在高置信度下，两种方法找到的<strong>最佳答案</strong>是相同的。</li>
<li>KL 散度说明高置信度下，不仅最佳答案相同，两种方法描绘的概率分布都非常相似。近似方法 q 不仅猜对了可能性最大的 token， 对其他可能性的估计，也和精确方法 p 的判断高度一致。</li>
</ul>
<h1 id="4-experiments">4. Experiments<a hidden class="anchor" aria-hidden="true" href="#4-experiments">#</a></h1>
<h2 id="41-experimental-setup">4.1 Experimental Setup<a hidden class="anchor" aria-hidden="true" href="#41-experimental-setup">#</a></h2>
<ul>
<li><strong>硬件与环境</strong> 🖥️: 所有实验均在单张 <strong>NVIDIA A100 80GB GPU</strong> 上进行，batch size=1.</li>
<li><strong>评测模型</strong> 🧠: <strong>LLaDA</strong>  和 <strong>Dream</strong>.</li>
<li><strong>评测基准</strong> 📊: 采用了四个广泛使用的基准数据集：<strong>GSM8K</strong>、<strong>MATH</strong>、<strong>HumanEval</strong> 和 <strong>MBPP</strong>.</li>
<li><strong>核心指标</strong> ⏱️:
<ul>
<li><strong>准确率 (Accuracy)</strong>: 衡量模型在具体任务上的表现。</li>
<li><strong>吞吐量 (Throughput)</strong>: 以 tokens/sec 为单位，反映端到端的真实解码速度。</li>
</ul>
</li>
<li><strong>超参数</strong> ⚙️:
<ul>
<li><strong>缓存块大小</strong>: 在 4 到 32 之间进行探索。</li>
<li><strong>置信度阈值</strong>: 在 0.5 到 1.0 之间进行探索。</li>
<li>实验默认使用 <strong>PrefixCache</strong>，块大小为 <strong>32</strong>，置信度阈值为 <strong>0.9</strong>.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="42-main-results-performance-and-speed">4.2 Main Results: Performance and Speed<a hidden class="anchor" aria-hidden="true" href="#42-main-results-performance-and-speed">#</a></h2>
<p>实验结果表明，Fast-dLLM 在各种任务和设置上都取得了显著的速度提升，同时对模型准确率的影响微乎其微 。</p>
<ul>
<li>加速效果:
<ul>
<li>单独引入 KV Cache 机制，通常能带来 <strong>2x-3.6x</strong> 的速度提升。</li>
<li>当 KV Cache 和并行解码两种策略结合使用时，性能提升更为显著。在 LLaDA 模型上，最 高可达 <strong>11.0x</strong> 的吞吐量提升；在 Dream 模型上，最高可达 <strong>7.8x</strong> 的提升 。</li>
</ul>
</li>
<li>极小的精度损失: 在所有基准测试中，加速后模型的准确率与原始基线模型的差距基本保持在 <strong>1-2个百分点</strong> 以内，有时甚至略有提高。</li>
<li>对长序列更友好: 实验还发现，在处理更长的文本序列时 (例如 few-shot 场景或长代码生成)，Fast-dLLM 的加速效果更为明显。</li>
</ul>
<p>下表以 GSM8K (5-shot) 任务为例，直观展示了 Fast-dLLM (即 +Cache+Parallel) 相较于 baseline 模型的性能提升。</p>
<table>
  <thead>
      <tr>
          <th style="text-align: left">模型</th>
          <th style="text-align: left">生成长度</th>
          <th style="text-align: left">配置</th>
          <th style="text-align: left">准确率 (%)</th>
          <th style="text-align: left">吞吐量 (tok/s)</th>
          <th style="text-align: left">相对加速</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left"><strong>LLaDA</strong></td>
          <td style="text-align: left">256</td>
          <td style="text-align: left">Baseline</td>
          <td style="text-align: left">79.3</td>
          <td style="text-align: left">6.7</td>
          <td style="text-align: left">1x</td>
      </tr>
      <tr>
          <td style="text-align: left"></td>
          <td style="text-align: left"></td>
          <td style="text-align: left"><strong>Fast-dLLM</strong></td>
          <td style="text-align: left"><strong>78.5</strong></td>
          <td style="text-align: left"><strong>54.4</strong></td>
          <td style="text-align: left"><strong>8.1x</strong></td>
      </tr>
      <tr>
          <td style="text-align: left"></td>
          <td style="text-align: left">512</td>
          <td style="text-align: left">Baseline</td>
          <td style="text-align: left">77.5</td>
          <td style="text-align: left">3.2</td>
          <td style="text-align: left">1x</td>
      </tr>
      <tr>
          <td style="text-align: left"></td>
          <td style="text-align: left"></td>
          <td style="text-align: left"><strong>Fast-dLLM</strong></td>
          <td style="text-align: left"><strong>77.2</strong></td>
          <td style="text-align: left"><strong>35.3</strong></td>
          <td style="text-align: left"><strong>11.0x</strong></td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>Dream</strong></td>
          <td style="text-align: left">256</td>
          <td style="text-align: left">Baseline</td>
          <td style="text-align: left">75.0</td>
          <td style="text-align: left">9.1</td>
          <td style="text-align: left">1x</td>
      </tr>
      <tr>
          <td style="text-align: left"></td>
          <td style="text-align: left"></td>
          <td style="text-align: left"><strong>Fast-dLLM</strong></td>
          <td style="text-align: left"><strong>74.8</strong></td>
          <td style="text-align: left"><strong>48.2</strong></td>
          <td style="text-align: left"><strong>5.3x</strong></td>
      </tr>
      <tr>
          <td style="text-align: left"></td>
          <td style="text-align: left">512</td>
          <td style="text-align: left">Baseline</td>
          <td style="text-align: left">76.0</td>
          <td style="text-align: left">7.7</td>
          <td style="text-align: left">1x</td>
      </tr>
      <tr>
          <td style="text-align: left"></td>
          <td style="text-align: left"></td>
          <td style="text-align: left"><strong>Fast-dLLM</strong></td>
          <td style="text-align: left"><strong>74.0</strong></td>
          <td style="text-align: left"><strong>42.9</strong></td>
          <td style="text-align: left"><strong>5.6x</strong></td>
      </tr>
  </tbody>
</table>
<hr>
<h2 id="43-ablations-and-analysis">4.3 Ablations and Analysis<a hidden class="anchor" aria-hidden="true" href="#43-ablations-and-analysis">#</a></h2>
<p>为了深入理解各个组件的贡献，论文进行了一系列详细的消融实验。</p>
<ul>
<li>
<p><strong>输入与生成长度的影响</strong>:</p>
<ul>
<li>实验证明，更长的上下文 (prefill，如从 5-shot 增加到 8-shot) 和更长的生成长度，都能显著放大加速效果。</li>
<li>在 8-shot 和 1024 生成长度的设置下，<strong>DualCache</strong> 实现了 <strong>27.6x</strong> 端到端加速。</li>
</ul>
</li>
<li>
<p><strong>PrefixCache vs. DualCache</strong>:</p>
<ul>
<li><strong>DualCache</strong> 通常比只缓存前缀的 <strong>PrefixCache</strong> 实现更高的加速比，尤其是在长序列生成任务中 。</li>
</ul>
</li>
<li>
<p><strong>缓存块大小的影响</strong>:</p>
<ul>
<li><strong>small block size</strong>：准确率最高，但因频繁更新缓存导致开销较大，速度提升有限 。</li>
<li><strong>small block size</strong>：速度快，但可能因上下文不匹配导致准确率下降 。</li>
<li>实验发现，块大小为 <strong>32</strong> 时在速度和精度之间取得了最佳平衡。</li>
</ul>
</li>
</ul>
<p>
<figure class="post-figure">
    <a href="https://share.note.youdao.com/yws/api/personal/file/WEB9772b6d4b4341a7ccb12bee9eef34910?method=download&amp;shareKey=1e3a007e630de1a9cbf8b3d9f318f307" target="_blank" rel="noopener">
        <img loading="lazy" src="https://share.note.youdao.com/yws/api/personal/file/WEB9772b6d4b4341a7ccb12bee9eef34910?method=download&amp;shareKey=1e3a007e630de1a9cbf8b3d9f318f307" alt="Impact of Cache Block Size on Accuracy and Throughput">
    </a><figcaption>Impact of Cache Block Size on Accuracy and Throughput</figcaption></figure></p>
<ul>
<li><strong>动态阈值 vs. 固定步数策略</strong>:
<ul>
<li>论文提出的 <strong>置信度感知并行解码</strong> 策略，在性能上持续优于每步固定解码 K 个 token 的 baseline 方法。</li>
<li>在达到相似甚至更高准确率的同时，该动态策略能实现更高的平均每步解码 token 数，从而获得更高的吞吐量。</li>
</ul>
</li>
</ul>
<p>
<figure class="post-figure">
    <a href="https://share.note.youdao.com/yws/api/personal/file/WEBd7916aff1aba60846ae1e971b2800e0a?method=download&amp;shareKey=88d29eb3e40615a74c4846d278413e5b" target="_blank" rel="noopener">
        <img loading="lazy" src="https://share.note.youdao.com/yws/api/personal/file/WEBd7916aff1aba60846ae1e971b2800e0a?method=download&amp;shareKey=88d29eb3e40615a74c4846d278413e5b" alt="Threshold VS Fxied Step">
    </a><figcaption>Threshold VS Fxied Step</figcaption></figure></p>
<h1 id="5-related-work">5. Related Work<a hidden class="anchor" aria-hidden="true" href="#5-related-work">#</a></h1>
<p>本章节回顾了与 Fast-dLLM 相关的两个核心领域：扩散语言模型的发展，以及大语言模型的通用加速技术。</p>
<hr>
<h2 id="51-diffusion-llm">5.1. Diffusion LLM<a hidden class="anchor" aria-hidden="true" href="#51-diffusion-llm">#</a></h2>
<p>扩散模型作为一种强大的生成范式，最初在图像和音频等连续数据领域取得了巨大成功，随后其影响力扩展到了 NLP. 特别是离散扩散模型的最新进展为大语言模型提供了一种替代自回归 (AR) 范式的可行方案 。</p>
<ul>
<li>
<p><strong>理论基础的发展</strong>:</p>
<ul>
<li>离散数据的扩散模型最早由 [29, 11] 探索 。</li>
<li><strong>D3PM</strong> 提出了一个更通用的框架，将前向加噪过程建模为离散状态马尔可夫链，并通过最大 ELBO 来学习反向过程。</li>
<li><strong>CTMC</strong> 将 D3PM 扩展到连续时间设定 。</li>
<li><strong>SEDD</strong> 采用了不同的方法，通过参数化边际似然比来学习反向过程 。</li>
<li><strong>MDMs</strong> 近期受到了广泛关注，其中 <strong>MDLM</strong> 和 <strong>RADD</strong> 的研究表明，MDMs 的不同参数化方法是等价的，并且其训练目标可以被简化 。</li>
</ul>
</li>
<li>
<p><strong>与预训练语言模型的结合</strong>: 一个关键的突破是将离散扩散与现有的大语言模型架构相结合 。</p>
<ul>
<li><strong>Diffusion-NAT</strong> [40] 将离散扩散的去噪过程与 BART 的非自回归解码相结合，通过迭代式地优化被掩码的 token ，实现了比同类自回归 Transformer 快20倍的生成速度 。</li>
<li><strong>LLaDA</strong> [21]、<strong>DiffuLLaMA</strong> [7] 和 <strong>Dream</strong> [36] 等框架将扩散模型扩展到了 7B 参数的规模，通过在扩散时间步上进行递归式的 token 预测，展现了与 LLaMA3 等主流自回归模型相匹敌的性能 。</li>
</ul>
</li>
</ul>
<h2 id="52-llm-acceleration">5.2. LLM Acceleration<a hidden class="anchor" aria-hidden="true" href="#52-llm-acceleration">#</a></h2>
<ul>
<li>KV Cache</li>
</ul>
<p>由于 LLaDA 等扩散语言模型采用的是 <strong>full attention</strong>，将 KV 缓存直接应用于这类模型并非易事。 一篇相关的研究 <strong>Block diffusion</strong>  通过<strong>分块生成 (block-by-block)</strong> 的方式，克服了先前扩散语言模型的局限，使得缓存和复用先前已解码块的键和值成为可能 。</p>
<ul>
<li>Non-Autoregressive Generation</li>
</ul>
<p>非自回归 (NAR) 生成标志着一种根本性的转变，它通过同时生成多个 token 来显著加速推理过程。NAR 方法最初被用于神经机器翻译，现已扩展到语法纠错、文本摘要和对话系统等多种任务
。
尽管 NAR 在速度上优势巨大，但它通常以牺牲一定的生成质量为代价。扩散语言模型是 NAR 领域一个新兴的范式；然而，先前的工作 (如 LLaDA) 在实践中难以实现预期的加速，因为并行生成会导致输出质量显著下降。</p>
<h1 id="weakness">Weakness<a hidden class="anchor" aria-hidden="true" href="#weakness">#</a></h1>
<p>近似缓存的误差累积效应：论文证明了在相邻步骤中，KV激活值的差异很小 。但随着生成块的增多，这种“近似”带来的微小误差是否会累积，并在生成非常长的文本 (如数万 token 的小说) 时导致语义漂移或一致性下降？论文的最长测试序列为1024 ，对于更长的序列，其鲁棒性有待进一步验证。</p>
<p>对模型能力的依赖：“置信度感知解码”策略的有效性，隐式地依赖于模型本身具有良好的“校准度” (calibration) ，即模型的置信度能够真实反映其预测的正确性。如果模型本身“过于自信”或“不够自信”，可能会导致该策略效果不佳。论文没有对所用模型的校准度进行分析。
定理一的理论与实践差距：论文坦诚地指出了定理一的局限性</p>
<blockquote>
<p>In practice, while MDM may not strictly satisfy this property, its behavior typically offers a close approximation.</p></blockquote>
<p>理论证明假设了一个“理想的”联合概率分布，而真实模型是否以及在多大程度上符合这个理想假设，是一个需要进一步探究的问题。理论和实践之间的差距可能在某些刁钻的 (adversarial) 或分布外 (Out-of-Distribution) 的场景下被放大。
超参数的敏感性与调优成本：尽管论文分析了块大小和阈值的影响，但并未提供一套系统性的方法来为新模型或新任务选择最佳超参数。在实际应用中，这可能意味着需要为每个特定用例进行成本不菲的网格搜索 (grid search) ，增加了方法的应用门槛。
评估维度的局限性：论文主要使用了基于准确率的基准测试。但在开放式生成、对话等任务中，评估指标 (如流畅度、一致性、多样性) 更为复杂。Fast-dLLM是否会在这些“软”指标上引入不易察觉的负面影响，需要更全面的评估。</p>
<h1 id="source-code">Source Code<a hidden class="anchor" aria-hidden="true" href="#source-code">#</a></h1>
<ol>
<li>
<p><strong>初始化</strong>:</p>
<ul>
<li>函数首先创建一个张量 <code>x</code>，其长度为“提示词长度 + 待生成长度”。</li>
<li>提示词 (<code>prompt</code>) 部分被填充到 <code>x</code> 的开头，而所有待生成的位置则被初始化为特殊的掩码标记 <code>[MASK]</code> (<code>mask_id</code>) 。</li>
<li>将总生成任务分解为多个块 (<code>num_blocks</code>) ，并为每个块分配固定的解码步数 (<code>steps</code>)</li>
</ul>
</li>
<li>
<p><strong>分块生成 (外层循环)</strong>:</p>
<ul>
<li>代码以块为单位进行循环，依次生成每个文本块。</li>
</ul>
</li>
<li>
<p><strong>处理单个块 (内层循环与缓存机制)</strong>:</p>
<ul>
<li>
<p><strong>步骤 A: 全局缓存初始化 (第一次模型调用)</strong></p>
<ul>
<li>在处理一个新块的开始，它首先将<strong>整个序列 <code>x</code></strong> (包含提示词、已生成的块和所有未来待生成的<code>[MASK]</code>块) 完整地输入模型。</li>
<li>这次调用的主要目的是计算并存储整个序列的键值对缓存 (<code>past_key_values</code>). 这是一个全局缓存。</li>
<li>然后，模型根据输出的 <code>logits</code>，使用 <code>get_transfer_index</code> 函数决定在<strong>当前块</strong>中，哪些 <code>[MASK]</code> 标记应该被优先替换掉 (例如，基于最高置信度的预测) ，并用预测出的 token  (token) 进行填充。这个过程只发生一次。</li>
</ul>
</li>
<li>
<p><strong>步骤 B: 块内迭代优化 (第二次及后续模型调用)</strong></p>
<ul>
<li>接下来，进入一个 <code>while</code> 循环，对当前块进行迭代式地“精炼”，直到这个块中所有的 <code>[MASK]</code> 标记都被填满。</li>
<li><strong>核心优化点</strong>：在这次及后续的模型调用中，<strong>不再需要输入整个序列</strong>。它只将<strong>当前块的张量</strong> (<code>x[:, current_block_start:current_block_end]</code>) 作为输入，并<strong>重用步骤 A 中生成的全局缓存 <code>past_key_values</code></strong>。</li>
<li>这就是 dual cache: 一个为上下文 (提示词+之前块) 准备的、基本不变的静态缓存，和一个为当前块服务的、动态更新的缓存。这避免了对上下文部分的重复计算，极大地提升了效率。</li>
<li>模型会为当前块中剩余的 <code>[MASK]</code> 位置生成新的预测，并根据策略继续填充。</li>
<li>这个迭代过程会持续进行，直到当前块不再有 <code>[MASK]</code> 标记为止。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>完成与返回</strong>:</p>
<ul>
<li>当所有块都处理完毕后，函数返回最终生成的完整序列 <code>x</code> 和总的模型前向传播次数 <code>nfe</code> (一个衡量计算成本的指标) 。</li>
</ul>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">torch</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@torch.no_grad</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">generate_with_dual_cache</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">prompt</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span> <span class="n">gen_length</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span> <span class="n">block_length</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span> <span class="n">temperature</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">remasking</span><span class="o">=</span><span class="s1">&#39;low_confidence&#39;</span><span class="p">,</span> <span class="n">mask_id</span><span class="o">=</span><span class="mi">126336</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s1">&#39;&#39;&#39;
</span></span></span><span class="line"><span class="cl"><span class="s1">    Generates text using a non-autoregressive, block-wise decoding strategy with a dual-cache mechanism.
</span></span></span><span class="line"><span class="cl"><span class="s1">
</span></span></span><span class="line"><span class="cl"><span class="s1">    Args:
</span></span></span><span class="line"><span class="cl"><span class="s1">        model: The mask predictor model.
</span></span></span><span class="line"><span class="cl"><span class="s1">        prompt: A tensor of shape (1, L) representing the input prompt.
</span></span></span><span class="line"><span class="cl"><span class="s1">        steps: Total number of sampling/refinement steps for the entire generation.
</span></span></span><span class="line"><span class="cl"><span class="s1">        gen_length: The desired length of the generated text.
</span></span></span><span class="line"><span class="cl"><span class="s1">        block_length: The size of each block to be generated in parallel. gen_length must be divisible by this.
</span></span></span><span class="line"><span class="cl"><span class="s1">        temperature: Sampling temperature for token selection. 0 means greedy decoding.
</span></span></span><span class="line"><span class="cl"><span class="s1">        remasking: The strategy for choosing which masks to fill (&#39;low_confidence&#39; or &#39;random&#39;).
</span></span></span><span class="line"><span class="cl"><span class="s1">        mask_id: The token ID for the [MASK] token.
</span></span></span><span class="line"><span class="cl"><span class="s1">    &#39;&#39;&#39;</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Create the full tensor &#39;x&#39; with the prompt and space for generation, initialized with the mask token.</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">prompt</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">gen_length</span><span class="p">),</span> <span class="n">mask_id</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">long</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Copy the prompt into the beginning of the tensor &#39;x&#39;.</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span><span class="p">[:,</span> <span class="p">:</span><span class="n">prompt</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">prompt</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Ensure that the generation length can be evenly divided into blocks.</span>
</span></span><span class="line"><span class="cl">    <span class="k">assert</span> <span class="n">gen_length</span> <span class="o">%</span> <span class="n">block_length</span> <span class="o">==</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="n">num_blocks</span> <span class="o">=</span> <span class="n">gen_length</span> <span class="o">//</span> <span class="n">block_length</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># Distribute the total steps among the blocks.</span>
</span></span><span class="line"><span class="cl">    <span class="k">assert</span> <span class="n">steps</span> <span class="o">%</span> <span class="n">num_blocks</span> <span class="o">==</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="n">steps_per_block</span> <span class="o">=</span> <span class="n">steps</span> <span class="o">//</span> <span class="n">num_blocks</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># nfe: Number of Forward-pass Evaluations. A counter for computational cost.</span>
</span></span><span class="line"><span class="cl">    <span class="n">nfe</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># Outer loop: iterate through each block to be generated.</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">num_block</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_blocks</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># Define the start and end positions of the current block within the full tensor &#39;x&#39;.</span>
</span></span><span class="line"><span class="cl">        <span class="n">current_block_start</span> <span class="o">=</span> <span class="n">prompt</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">num_block</span> <span class="o">*</span> <span class="n">block_length</span>
</span></span><span class="line"><span class="cl">        <span class="n">current_block_end</span> <span class="o">=</span> <span class="n">current_block_start</span> <span class="o">+</span> <span class="n">block_length</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># Find the indices of mask tokens within the current block.</span>
</span></span><span class="line"><span class="cl">        <span class="n">block_mask_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="n">current_block_start</span><span class="p">:</span><span class="n">current_block_end</span><span class="p">]</span> <span class="o">==</span> <span class="n">mask_id</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1"># Determine the number of tokens to fill at each refinement step for this block.</span>
</span></span><span class="line"><span class="cl">        <span class="n">num_transfer_tokens</span> <span class="o">=</span> <span class="n">get_num_transfer_tokens</span><span class="p">(</span><span class="n">block_mask_index</span><span class="p">,</span> <span class="n">steps_per_block</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># --- First Model Call: Initialize Global Cache ---</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># A single forward pass on the ENTIRE sequence (prompt + all masked blocks) to pre-calculate</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># the Key-Value cache for all tokens. This is the &#34;global&#34; cache.</span>
</span></span><span class="line"><span class="cl">        <span class="n">output</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">use_cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">past_key_values</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">past_key_values</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1"># Identify all mask tokens up to the end of the current block.</span>
</span></span><span class="line"><span class="cl">        <span class="n">mask_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">mask_id</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># Ignore masks that are in future blocks for this step&#39;s prediction.</span>
</span></span><span class="line"><span class="cl">        <span class="n">mask_index</span><span class="p">[:,</span> <span class="n">current_block_end</span><span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1"># Select which tokens to predict and fill in this initial step for the current block.</span>
</span></span><span class="line"><span class="cl">        <span class="n">x0</span><span class="p">,</span> <span class="n">transfer_index</span> <span class="o">=</span> <span class="n">get_transfer_index</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">logits</span><span class="p">,</span> <span class="n">temperature</span><span class="p">,</span> <span class="n">remasking</span><span class="p">,</span> <span class="n">mask_index</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">num_transfer_tokens</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">threshold</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1"># Update the tensor &#39;x&#39; by filling the selected mask positions with the predicted tokens.</span>
</span></span><span class="line"><span class="cl">        <span class="n">x</span><span class="p">[</span><span class="n">transfer_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">x0</span><span class="p">[</span><span class="n">transfer_index</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="n">nfe</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># Increment the forward-pass counter.</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># Counter for refinement steps within the block.</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1"># A boolean mask indicating the position of the current block, used to update the cache efficiently.</span>
</span></span><span class="line"><span class="cl">        <span class="n">replace_position</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">replace_position</span><span class="p">[:,</span> <span class="n">current_block_start</span><span class="p">:</span><span class="n">current_block_end</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># --- Inner Loop: Iterative Refinement of the Current Block ---</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># This loop continues until all masks in the current block are filled.</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">nfe</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># Increment the forward-pass counter for each refinement step.</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1"># Find the remaining masks ONLY within the current block.</span>
</span></span><span class="line"><span class="cl">            <span class="n">mask_index_block</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="n">current_block_start</span><span class="p">:</span><span class="n">current_block_end</span><span class="p">]</span> <span class="o">==</span> <span class="n">mask_id</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="c1"># --- Efficient Model Call using Dual Cache ---</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># Instead of passing the whole sequence, only pass the CURRENT BLOCK&#39;s tokens.</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># Reuse the &#39;past_key_values&#39; (global cache) computed earlier. The model internally</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># uses &#39;replace_position&#39; to update the cache only at the current block&#39;s location.</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># This is the &#34;dual cache&#34; trick, avoiding re-computation for the prompt and previous blocks.</span>
</span></span><span class="line"><span class="cl">            <span class="n">logits</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="n">current_block_start</span><span class="p">:</span><span class="n">current_block_end</span><span class="p">],</span> <span class="n">past_key_values</span><span class="o">=</span><span class="n">past_key_values</span><span class="p">,</span> <span class="n">use_cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">replace_position</span><span class="o">=</span><span class="n">replace_position</span><span class="p">)</span><span class="o">.</span><span class="n">logits</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="c1"># Select which of the remaining masks to fill in this refinement step.</span>
</span></span><span class="line"><span class="cl">            <span class="n">x0</span><span class="p">,</span> <span class="n">transfer_index</span> <span class="o">=</span> <span class="n">get_transfer_index</span><span class="p">(</span><span class="n">logits</span><span class="p">,</span> <span class="n">temperature</span><span class="p">,</span> <span class="n">remasking</span><span class="p">,</span> <span class="n">mask_index_block</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">                                            <span class="n">x</span><span class="p">[:,</span> <span class="n">current_block_start</span><span class="p">:</span><span class="n">current_block_end</span><span class="p">],</span> <span class="n">num_transfer_tokens</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">threshold</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1"># Update the current block with the newly predicted tokens.</span>
</span></span><span class="line"><span class="cl">            <span class="n">x</span><span class="p">[:,</span> <span class="n">current_block_start</span><span class="p">:</span><span class="n">current_block_end</span><span class="p">][</span><span class="n">transfer_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">x0</span><span class="p">[</span><span class="n">transfer_index</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1"># If there are no more masks in the current block, exit the refinement loop.</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="n">current_block_start</span><span class="p">:</span><span class="n">current_block_end</span><span class="p">]</span> <span class="o">==</span> <span class="n">mask_id</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="k">break</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># Move to the next refinement step.</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Return the fully generated sequence and the total number of model evaluations.</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">nfe</span>
</span></span></code></pre></div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/diffusionllm/">DiffusionLLM</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/blogs/pipefusion/">
    <span class="title">« Prev</span>
    <br>
    <span>PipeFusion</span>
  </a>
  <a class="next" href="http://localhost:1313/blogs/llada/">
    <span class="title">Next »</span>
    <br>
    <span>LLaDA</span>
  </a>
</nav>

  </footer><script src="https://giscus.app/client.js"
        data-repo="jamesnulliu/jamesnulliu.github.io"
        data-repo-id="R_kgDOMPCQIw"
        data-category="Announcements"
        data-category-id="DIC_kwDOMPCQI84Cgb2t"
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="bottom"
        data-theme="preferred_color_scheme"
        data-lang="en"
        crossorigin="anonymous"
        async>
</script>
</article>
    </main>
    
<footer class="footer">
        <span>© 2024-2025 WITHER</span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
