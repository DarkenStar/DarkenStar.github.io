<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>TX8 Backend | WITHER</title>
<meta name="keywords" content="tx8">
<meta name="description" content="TX8 backend description.">
<meta name="author" content="WITHER">
<link rel="canonical" href="http://localhost:1313/blogs/tx8_backend/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.dd3b5b907a50db3238b81d49d094cf1c04a091227797dc9cfde4e2fa3f35df49.css" integrity="sha256-3TtbkHpQ2zI4uB1J0JTPHASgkSJ3l9yc/eTi&#43;j8130k=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/blogs/tx8_backend/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<script>
  MathJax = {
    tex: {
      displayMath: [['\\[', '\\]'], ['$$', '$$']],  
      inlineMath: [['\\(', '\\)'], ['$', '$']]  
    }
  };
</script>




<script src="https://cdn.bootcdn.net/ajax/libs/mermaid/9.1.6/mermaid.min.js"></script>
<script>
    mermaid.initialize({
        startOnLoad: true,
        theme: localStorage.getItem("pref-theme") === "dark" ? "dark" : "forest" 
    });
</script>

<meta property="og:url" content="http://localhost:1313/blogs/tx8_backend/">
  <meta property="og:site_name" content="WITHER">
  <meta property="og:title" content="TX8 Backend">
  <meta property="og:description" content="TX8 backend description.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="blogs">
    <meta property="article:published_time" content="2025-07-23T11:49:02+08:00">
    <meta property="article:modified_time" content="2025-09-19T09:20:48+08:00">
    <meta property="article:tag" content="Tx8">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="TX8 Backend">
<meta name="twitter:description" content="TX8 backend description.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Blogs",
      "item": "http://localhost:1313/blogs/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "TX8 Backend",
      "item": "http://localhost:1313/blogs/tx8_backend/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "TX8 Backend",
  "name": "TX8 Backend",
  "description": "TX8 backend description.",
  "keywords": [
    "tx8"
  ],
  "articleBody": "TX8 Hardware Overview TX8 é‡‡ç”¨çš„æ˜¯ç©ºé—´è®¡ç®—å‹ç»“æ„ (Special Computing Architecture)ï¼Œå¸‚é¢ä¸Šæ™®éé‡‡ç”¨çš„å…±äº«å†…å­˜ç»“æ„ (Shared Memory Architecture)ï¼Œå®ƒçš„æ•°æ®é€šä¿¡äº¤äº’ä¸»è¦æ˜¯ä¾èµ–äº DDRï¼Œä¸€ä¸ª thread æŠŠ DDR çš„æ•°æ®æ”¹å˜ä¹‹åï¼Œå¦å¤–ä¸€ä¸ª thread å†ä» DDR ä¸­æ‰èƒ½å¾—çŸ¥åˆ°è¿™ä¸ªæ•°æ®å·²ç»è¢«æ”¹å˜ã€‚è¿™ä¹ˆåšæœ‰ä¸€ä¸ªå¾ˆæ˜æ˜¾çš„ç¼ºé™·ï¼Œå°±æ˜¯å®ƒç“¶é¢ˆåœ¨äºå†…å­˜å®¹é‡ä»¥åŠè®¿é—®å†…å­˜çš„å¸¦å®½å»¶è¿Ÿã€‚ç©ºé—´è®¡ç®—å‹çš„ç»“æ„å®ƒæ˜¯ç”±ä¸­é—´çš„NOC (Network On Chip) æ¥æ„æˆæ¨¡å—ä¹‹é—´çš„äº’è”ã€‚è¿™æ ·å¾ˆå¥½çš„é¿å…äº†è¿™ä¸ª DDR çš„ç“¶é¢ˆï¼ŒåŒæ—¶ä¹Ÿæœ‰äº†æ›´å¥½çš„ scale out èƒ½åŠ›ã€‚\n(a) Shared Memory Architecture (b) Spatial Computing Architecture\nä¸‹å›¾ä¸º TX8 ä¸¤ä¸ªèŠ¯ç‰‡äº’è¿çš„é€»è¾‘ç»“æ„ã€‚æ¯ä¸ªèŠ¯ç‰‡ç”± 4x4 æ€»è®¡ 16 Tile ä»¥ mesh æ‹“æ‰‘ç»“æ„è¿›è¡Œäº’è¿ã€‚æ¯ä¸€ä¸ª Tile æ˜¯ä¸€ä¸ªè®¡ç®—æ ¸å¿ƒï¼Œæ˜¯ä¸€ä¸ªå›¾çµå®Œå¤‡ (Turing Complete) çš„ç³»ç»Ÿï¼Œæ—¢å…·æœ‰è°ƒåº¦æ§åˆ¶ä»¥åŠè®¡ç®—é€šä¿¡ä»¥åŠå­˜å‚¨çš„èƒ½åŠ›ã€‚ç‰‡ä¸Š NoC é‡‡ç”¨çš„æ˜¯ stream (ä¸€ç§è½»é‡çº§ DMA æŠ€æœ¯). ç‰‡ä¸Š DDR å¤§å°ä¸º 64GBï¼ŒèŠ¯ç‰‡ä¹‹é—´æ˜¯é€šè¿‡ high speed IO è¿›è¡Œäº’è¿çš„ã€‚\nTile\nå•èŠ¯ç‰‡ä¸å•å¡ A100 æ€§èƒ½å¯¹æ¯”å¦‚ä¸‹è¡¨æ‰€ç¤º\nTX8 å•å¡æ€§èƒ½ æœ€å¤§ç»„ç½‘æ€§èƒ½ A100 å•å¡æ€§èƒ½ INT8 256T 1E 624T BF16 128T 0.5E 312T TFP32 128T 0.5E 156T FP32 21T 40P 19.5T å†…å­˜å¸¦å®½ 200GB/s - æ˜¾å­˜å¸¦å®½ 1935GB/s PCIe 64GB/s - 64GB/s å†…å­˜å®¹é‡ 64GB 128TB æ˜¾å­˜å®¹é‡ 80GB TsingMicro-Link 1600Gbps - NV-Link 600GB/s Single Tile ä¸‹å›¾æ˜¯å• Tile çš„ç¡¬ä»¶ç»“æ„ï¼Œå®é™…ä¸Šæ¯ä¸ª Tile ä¸Šä¼šæœ‰ä¸¤ä¸ª kernel core å’Œ special coreï¼Œå›¾ä¸­åªç”»äº†ä¸€ä¸ªã€‚è¿˜æœ‰ä¸ª neural coreï¼Œä¸»è¦æ˜¯è´Ÿè´£è®¡ç®—ä»¥åŠæ•°æ®æ¬è¿ç­‰ç­‰ã€‚\nTile Microarchitecture\nkernel core ä¸»è¦ç”¨äºä¸‹å‘æŒ‡ä»¤ã€‚å®ƒä¼šä» DDR ä¸­å–å€ï¼Œç„¶åé€åˆ°è¿™ä¸ª neural core çš„ NCC controller é‡Œé¢ã€‚NCC controller åˆä¼šæŠŠæ ¹æ®è¿™ä¸ªæŒ‡ä»¤çš„ç±»å‹ä¸‹å‘åˆ° CT/NE/LSU. ä»–ä»¬ä¸‰ä¸ªæ˜¯æ‰§è¡Œä¸åŒç§ç±»æŒ‡ä»¤çš„ä¸‰ä¸ªå°æ¨¡å—ï¼Œåé¢ä¼šè®²åˆ°ã€‚è¿™ä¸‰ä¸ªå°æ¨¡å—ä¼šä» SPM (Scratched Pad Memory) ä¸Šè¯»å–æ•°æ®ï¼Œç„¶åå†è®¡ç®—ï¼Œæˆ–è€…å†å­˜å› SPMä¸Šã€‚å€¼å¾—æ³¨æ„çš„æ˜¯ï¼ŒLSU æ˜¯ç”¨æ¥è´Ÿè´£è¿™ä¸ªæ•°æ®æ¬è¿çš„ï¼Œæ‰€ä»¥å®ƒå¯ä»¥æŠŠè¿™ä¸ª SPM ä¸Šçš„æ•°æ®ç›´æ¥æ¬åˆ°DDRï¼Œæˆ–è€…æ˜¯ä» DDR æ¬åˆ° SPM ä¸Šã€‚CT å’Œ NE éƒ½æ˜¯è´Ÿè´£è®¡ç®—çš„æ¨¡å—ï¼Œå…¶ä¸­ scalar unit ä½äº NCC controllerï¼Œæ˜¯ä¸€ä¸ªè´Ÿè´£æ ‡é‡è®¡ç®—çš„æ¨¡å—ã€‚\nspecial core ç”¨æ¥å’Œ NOC è¿›è¡Œè¿æ¥ï¼Œå®ƒå¯ä»¥ä» DDR ä¸­è¯»å–æ•°æ®ï¼Œç„¶åé€šè¿‡é…ç½® DTE æ¨¡å—å’Œè¿™ä¸ªè¿œç¨‹çš„ Tile è¿›è¡Œé€šä¿¡ã€‚DTE æ¨¡å—ä¹Ÿå¯ä»¥é€šè¿‡ special core å°†æœ¬ Tile ä¸Šçš„ SPM ä¸è¿œç¨‹ Tile ä¸Šçš„ SPM è¿›è¡Œé€šä¿¡ã€‚\nCGRA Tensor CGRA Tensor æ¨¡å—æ”¯æŒç®—æœ¯è¿ç®—ï¼Œé€»è¾‘è¿ç®—ï¼Œä½æ“ä½œï¼Œæ¿€æ´»å‡½æ•°ï¼Œè¶…è¶Šå‡½æ•°ï¼Œè§„çº¦ï¼Œæ± åŒ–ï¼Œæ•°æ®æ¬ç§»ï¼Œæ ¼å¼è½¬æ¢ï¼Œè¾…åŠ©è®¡ç®—ã€‚\nCGRA\nNeural Core Controller ä¸‹å‘æŒ‡ä»¤åˆ° CTRL_UNITï¼Œç„¶å CTRL_UNIT ä¸‹å‘æŒ‡ä»¤åˆ° RAM_ACC_UNIT. RAM_ACC_UNIT è¯»å…¥ SPM çš„æ•°æ®ï¼Œç„¶åé€å…¥ Pipe Unit è¿›è¡Œè¿ç®—ä¹‹åæŠŠç»“æœå­˜å› SPM.\nCGRA æŒ‡ä»¤æ ¼å¼å¦‚ä¸‹ã€‚ä¾‹å¦‚ CGRATensor_ArithOp_V_V_absï¼ŒæŒ‡ä»¤æ“ä½œæŒ‡çš„æ˜¯å¯¹å‘é‡å…ƒç´ æ±‚ç»å¯¹å€¼ã€‚\næŒ‡ä»¤æ ¼å¼ CGRATensor_function_format_name.type Function æè¿°è¯¥å•å…ƒçš„ä¸»è¦åŠŸèƒ½ï¼Œå¦‚ç®—æ•°è¿ç®—ã€å…³ç³»è¿ç®—ã€é€»è¾‘è¿ç®—ç­‰ï¼› Format æè¿°æ•°æ®çš„å­˜å‚¨æ–¹å¼ï¼Œå¦‚VVã€VSã€Tensorã€VuV åˆ†åˆ«è¡¨ç¤ºå‘é‡ä¸å‘é‡è®¡ç®—ã€å‘é‡ä¸æ ‡é‡è®¡ç®—ã€Tensorè®¡ç®—ã€å‘é‡ä¸å•å…ƒå‘é‡è®¡ç®—ï¼› Name æè¿°å…·ä½“çš„æ“ä½œï¼Œå¦‚åŠ ã€å‡ã€ä¹˜ã€é™¤ç­‰ï¼› Type è¡¨ç¤ºæ•°æ®ç±»å‹ï¼Œå¦‚ bf16/fp32 ç­‰ï¼› ä¸‹é¢å…·ä½“è®²ä¸€ä¸‹åœ¨ BN ç®—å­å¼€å‘ä¸­ç”¨åˆ°çš„ CGRATensor_ArithOp_V_VuV_mul_loop (bf16 *src, bf16 *dst, bf16 *unit, int rnd, int src_elem_num, int unit_elem_num, int full_src_elem_num, int full_unit_elem_num).\nsrc/dst/unit åˆ†åˆ«è¡¨ç¤º ä¹Ÿæ˜¯åŸæ•°æ®/å­˜æ•°/å•å…ƒå‘é‡çš„åœ°å€ã€‚ src_elem_num æ˜¯åšä¸€æ¬¡è¿™ä¸ª VuV ä¸­åŸæ•°æ®çš„ä¸ªæ•°ã€‚ unit_elem_num æ˜¯åšä¸€æ¬¡è¿™ä¸ª VuV ä¸­å•å…ƒå‘é‡æ•°æ®çš„ä¸ªæ•°ã€‚ åœ¨è®² VuV_mul_loop ä¹‹å‰ï¼Œå…ˆæ¥çœ‹ä¸€ä¸‹è¿™ä¸ª VuV_mul ä¹Ÿå°±æ˜¯æ²¡æœ‰å¾ªç¯çš„å•æ¬¡ç‰ˆæœ¬ã€‚åˆ†ä¸ºä¸¤æ¬¡è¿›è¡Œï¼Œç¬¬ä¸€æ¬¡æ˜¯å‰å››ä¸ªè“è‰²çš„æ–¹å—ä¸æ©™è‰²æ–¹å—ç›¸ä¹˜ï¼Œç¬¬äºŒæ¬¡ä¸ºåå››ä¸ªè“è‰²æ–¹å—ä¸æ©™è‰²æ–¹å—ç›¸ä¹˜ã€‚VuV_mul_loop å³æŠŠè¿™ä¸ªè¿‡ç¨‹é‡å¤å¾ˆå¤šæ¬¡ï¼Œæ‰€ä»¥è¦æ±‚ full_src_elem_num/full_unit_elem_num == src_elem_num/unit_elem_numï¼Œå¹¶ä¸”unit_elem_num=64.\nVuV_mul_loop\nTensor Layout layout å¯ä»¥åˆ†ä¸ºä»¥ä¸‹å‡ ç§\nlayout_str: ä¸­ç«¯ä½¿ç”¨ CNN Op: 1. Feature (NCHW/NHWC) etc. 2. Weight (OIHW/HWOI) etc. Non-CNN Op: å¤§æ¨¡å‹ä¸­å¸¸è§ï¼ŒTensor/NTensorï¼Œå®ƒä»¬çš„åŒºåˆ«æ˜¯ç¬¬ 0 ç»´æ˜¯å¦ä¸º 1. mem_layout: åç«¯ä½¿ç”¨ï¼Œä»£è¡¨äº†åœ¨èŠ¯ç‰‡ä¸Šçš„å®é™…æ’å¸ƒ Tensor/NTensor: æ•°æ®çš„ç´§å¯†æ’å¸ƒ Cx/NCx: å¯¹ Tensor/NTensor æ ¼å¼åŒ–åçš„ç»“æœï¼Œæ–¹ä¾¿æ˜“ç¡¬ä»¶è¯»å–ã€‚ dtype channel description bf16/fp16 /fp32/tf32 c \u003c= 32 NHWC, Cå‘4/8/16/32å¯¹é½ï¼ŒN çš„èµ·å§‹åœ°å€å‘ 2048bit å¯¹é½ c \u003e 32 N[CxHW64, HWC0], C0 å‘ 4/8/16/32 å¯¹é½ï¼ŒN çš„èµ·å§‹åœ°å€å‘2048bit å¯¹é½\nåœ¨ä¸€ä¸ª batch å†…å°† tensor æŒ‰ C åˆ†æˆ Cx*64 å’Œ C0ä¸¤éƒ¨åˆ† int8 c \u003c= 64 NHWC, C å‘ 4/8/16/32/64å¯¹é½ï¼ŒNçš„èµ·å§‹åœ°å€å‘2048bitå¯¹é½ c \u003e 64 N[CxHW128, HWC0], C0 å‘ 4/8/16/32/64 å¯¹é½ï¼ŒNçš„èµ·å§‹åœ°å€å‘ 2048bit å¯¹é½ åœ¨ä¸€ä¸ª batch å†…å°† tensor æŒ‰ C åˆ†æˆ Cx*128 å’ŒC0 ä¸¤éƒ¨åˆ† å¯¹äº fp16 çš„ 2x1x2x131 çš„æ•°æ®ï¼ŒNTensor æ ¼å¼å­˜å‚¨èµ·å§‹åœ°å€ä¸º 0x0000 æŒ‰å„å­˜å‚¨æ ¼å¼æ’åˆ—å¦‚ä¸‹\nNTensor Layout\nNCx: 131 = 64 x 2 + 3, å°† C åˆ†æˆ 2(Cx) ä¸ª 64 å’Œ 4(C0). batch0 çš„ç»“æŸåœ°å€æ˜¯ 0x1080 (4224), batch1 èµ·å§‹åœ°å€éœ€å¯¹é½åˆ° 2048bitï¼Œå³ 4224â€“\u003e2048*3=6144 (0x1800).\nNCx Layout\nNeural Engine Neural engine ç±»ä¼¼äº GPU Tensor Coreï¼Œä¸»è¦æ˜¯å®Œæˆå„ç§çŸ©é˜µ (op_Gemm) å’Œå·ç§¯ (op_Conv) ç±»å‹çš„é«˜æ•ˆå¹¶è¡Œ Tensor è®¡ç®—ã€‚PE Array å®ƒçš„è¿›è¡ŒçŸ©é˜µè¿ç®—çš„éƒ¨åˆ†ï¼Œä¸€æ¬¡å®Œæˆ 8x16x8 å¤§å°çš„çŸ©é˜µä¹˜æ³•ã€‚ç„¶åå®ƒçš„è¾“å…¥æœ‰æ¿€æ´» inputï¼Œè¿˜æœ‰ psumï¼Œè¿˜æœ‰ weightï¼Œä¹Ÿå°±æ˜¯æƒé‡ã€‚\nè®¡ç®—ä¹‹åï¼Œè¿˜é¥¿å¯ä»¥è¿›è¡Œåå¤„ç†ï¼Œå¯¹è¿™ä¸ªç»“æœè¿›è¡Œ BN/é‡åŒ–/æ¿€æ´»ç­‰ç­‰ï¼Œç„¶åå†åˆ°è¾“å‡ºï¼Œç„¶åæˆ‘ä»¬è¦ç”¨åˆ°neural engine çš„ç®—å­å…¶å®å¹¶ä¸å¤šï¼Œåªæœ‰ op_Gemm å’Œ op_Conv.\nNeural Engine\nLSU LSU æ˜¯è´Ÿè´£æ•°æ®æ¬è¿çš„ DMA æ§åˆ¶å™¨ã€‚å…·ä½“å®ƒæœ‰ä¸‰éƒ¨åˆ†:\nRDMA: Read DDR â€“\u003e SPMï¼Œå¯¹åº”æŒ‡ä»¤æœ‰ op_loadVarï¼Œop_loadConstï¼Œop_rdmaGather. WDMA: Write SPM â€“\u003e DDRï¼Œå¯¹åº”æŒ‡ä»¤æœ‰ op_dma_storeï¼Œop_wdmaScatter. TDMA: å¯¹æ‰€å± Tile SPM ä¸Šçš„æ•°æ®è¿›è¡Œæ“ä½œï¼Œå¯¹åº”æŒ‡ä»¤æœ‰ op_reshapeï¼Œop_gatherScatter. LSU\nä¸€ç§ç»å¸¸ä½¿ç”¨ TDMA çš„æƒ…å†µæ˜¯è¿›è¡Œä½ç²¾åº¦åˆ°é«˜ç²¾åº¦çš„è½¬æ¢ã€‚ä»¥ fp16 -\u003e fp32 ä¸ºä¾‹ï¼Œé¦–å…ˆä¼šè°ƒç”¨ op_gatherScatter æŒ‡ä»¤æŠŠç´§å¯†æ’å¸ƒçš„ä½ç²¾åº¦æ•°æ®è¯»è¿›æ¥ç„¶å scatter åˆ° SPM ä¸Šçš„å¯¹åº”ä½ç½®ä»¥ä¿ç•™ç©ºé—´å­˜å‚¨è½¬æ¢åçš„æ•°æ®ï¼›ç„¶åå†è°ƒç”¨ CGAR convert_fp16_fp32 æŒ‡ä»¤è¿›è¡Œç²¾åº¦è½¬æ¢ã€‚\nfp16 to fp32 Conversion\nTX8 Compiler å’Œä¸€èˆ¬ç¼–è¯‘å™¨å·®ä¸å¤šï¼Œå…ˆè·å–å‰ç«¯çš„ Tensorflow/Pytorch ç­‰ç­‰ç”Ÿæˆçš„ mhlo è®¡ç®—å›¾ï¼Œç»è¿‡ä¸­ç«¯çš„å¤„ç†ï¼Œç„¶åè½¬åˆ°åç«¯ã€‚å˜æˆåç«¯ IR. åŒæ—¶åˆä¼šè°ƒç”¨ OPLIB ç®—å­åº“ä¸­çš„ç®—å­æ¥ç”Ÿæˆ main.cï¼Œå°±æ˜¯å¯ä»¥ç›´æ¥æ”¾åœ¨ä¸åŒå¹³å°ä¸Šè¿è¡Œçš„ä¸»ç¨‹åºã€‚å¹³å°å¯ä»¥é€‰æ‹© RISCV å³çœŸå®çš„ç¡¬ä»¶ï¼Œæˆ–è€…æ˜¯ Cmodel è¿›è¡Œæ¨¡æ‹Ÿã€‚\nBEIR ä¸»è¦æ˜¯æ¥è¿‡ä¸­ç«¯ä¼ è¿›æ¥çš„ IRï¼Œç„¶åè¿›è¡Œå„ç±»çš„å›¾ä¼˜åŒ–çš„ Passï¼ŒåŒ…æ‹¬ä¸€äº›ç®—å­åˆ‡åˆ†ï¼Œè¿˜æœ‰å†…å­˜è°ƒåº¦ç­‰ç­‰ã€‚æœ€ç»ˆ codegen è¿™ä¸ªå¯ç¼–è¯‘æ‰§è¡Œçš„ main.c çš„æ–‡ä»¶ã€‚ç„¶åå†æ”¾åœ¨å¹³å°ä¸Šå»ç¼–è¯‘å®Œå†è¿è¡Œã€‚\nTX8 Compiler Workflow\nTX8 BE åç«¯ IR ä½¿ç”¨çš„æ˜¯ MLIRï¼Œç»§æ‰¿ Dialectï¼Œå®šä¹‰äº†è®¸å¤š Operations, Attributes, Types.\ndef Tx8be_Dialect : Dialect { let name = \"tx8be\"; let summary = \"A low-level dialect for tx8 backend specification\"; let cppNamespace = \"::tx8be_mir::tx8be\"; let useDefaultAttributePrinterParser = 1; } Attribute ä¸‹é¢ä»‹ç»ä¸€äº›å¸¸ç”¨çš„ Attribute.\nparallel_attr ä¸»è¦æ˜¯è¡¨ç¤º tensor æ¯ä¸ªç»´åº¦ä¸Šæ•°æ®å¹¶è¡Œå’Œå¼ é‡å¹¶è¡Œçš„åˆ‡åˆ†ç­–ç•¥ã€‚\ndef Tx8be_ParallelAttr : Tx8be_Attr\u003c\"Parallel\", \"parallel_attr\"\u003e { let summary = \"Structure of parallel information.\"; let parameters = (ins \"ParallelModeAttr\" : $parallel, \"bool\" : $is_dp_inner, // dp dimension is in the inner, otherwise tp \"i32\" : $dp_dim_x, // data parallel dimension at x axis \"i32\" : $dp_dim_y, // data parallel dimension at y axis \"i32\" : $dp_dim_z, // data parallel dimension at z axis \"i32\" : $tp_dim_x, // tensor parallel dimension at x axis \"i32\" : $tp_dim_y, // tensor parallel dimension at y axis \"i32\" : $tp_dim_z, // tensor parallel dimension at z axis \"bool\" : $sharding_is_given, // true: is given, false: is not \"::mlir::DenseI32ArrayAttr\" : $shape_spatial_sharding // Shape split info ); let cppNamespace = \"::tx8be_mir::tx8be\"; let assemblyFormat = \"`\u003c` struct($params) 1\"; } dev_attr å±æ€§åŒ…å«\nimm_sizeï¼Œä¹Ÿå°±æ˜¯ç”¨åˆ°çš„è¿™ä¸ªè¾…åŠ©ç©ºé—´çš„å¤§å°ã€‚ mem_layout ä¹Ÿå°±æ˜¯æ•°æ®çš„å­˜å‚¨æ•°æ®çš„æ’å¸ƒã€‚ multi_buf_en æŒ‡æ˜¯å¦ä½¿ç”¨ double buffer. out_shape_buf_idx æŒ‡çš„æ˜¯è¾“å‡ºä½¿ç”¨ç¬¬å‡ ä¸ªç¼“å†²åŒºã€‚ temporal_mem_slice æ˜¯å•ä¸ª Tile æ¯æ¬¡å¤„ç†çš„æ•°æ®å¤§å°ã€‚ def Tx8be_DevAttr : Tx8be_Attr\u003c\"Dev\", \"dev_attr\"\u003e { let summary = \"Structure of op parameters on device.\"; let parameters = (ins \"uint64_t\" : $imm_size, // Output memory addr offset \"LayoutModeAttr\" : $mem_layout, // Layout \"bool\" : $multi_buf_en, // for double buffering \"int32_t\" : $multi_buf_num, // for double buffering \"mlir::DenseI64ArrayAttr\" : $out_shape_buf_idx, // index for dynamic shape buffer on runtime \"mlir::DenseI64ArrayAttr\" : $temporal_mem_slice, // for compute local buffer size \"int32_t\" : $source_type, // Software pipeline stage \"int64_t\" : $imm_addr, \"mlir::DenseI64ArrayAttr\" : $mem_addr // use array for multibuffer ); let cppNamespace = \"::tx8be_mir::tx8be\"; let assemblyFormat = \"`\u003c` struct($params) `\u003e`\"; } MemScopeMode ç”¨äºæè¿°æ•°æ®å­˜å‚¨åœ¨å“ªé‡Œã€‚\ndef Tx8be_MemScopeMode : I32EnumAttr\u003c\"MemScopeMode\", \"Specify the memory scope\", [ I32EnumAttrCase\u003c\"DDR\", 0\u003e, I32EnumAttrCase\u003c\"SPM\", 1\u003e, I32EnumAttrCase\u003c\"3DDRAM\", 2\u003e ]\u003e { let genSpecializedAttr = 0; let cppNamespace = \"::tx8be_mir::tx8be\"; } Types å®šä¹‰äº†å¾ˆå¤šç±»å‹ï¼Œå®é™…ä¸Šå¸¸ç”¨çš„å°±æ˜¯ AnyTensorOrNone.\ndef AnyTensorOrNone: AnyTypeOf\u003c[AnyRankedTensor, NoneType]\u003e; def Tx8be_Tuple : NestedTupleOf\u003c[AnyRankedTensor]\u003e; def AnyTensorOrTuple : AnyTypeOf\u003c[AnyRankedTensor, Tx8be_Tuple]\u003e; def Tx8be_Pred : TypeAlias\u003cI1, \"pred (AKA boolean or 1-bit integer)\"\u003e; def Tx8be_PredTensor : TensorOf\u003c[Tx8be_Pred]\u003e; def Tx8be_Token : Type\u003cCPred \"{$_self-\u003eisa()}\", \"token\"\u003e; def Tx8be_TensorOrTokenOrTuple : AnyTypeOf\u003c[AnyTensor, Tx8be_Token, Tx8be_Tuple]\u003e; def Tx8be_SInt : SignlessIntOfWidths\u003c[4, 8, 16, 32, 64]\u003e; def Tx8be_UInt : UnsignedIntOfWidths\u003c[4, 8, 16, 32, 64]\u003e; def Tx8be_Int : AnyTypeOf\u003c[Tx8be_SInt, Tx8be_UInt]\u003e; Operations ä»¥å¼€å‘çš„ BatchNorm_InferenceOp ä¸ºä¾‹è®²è§£ä¸€ä¸‹ Tx8be ä¸­å…³äºç®—å­çš„å®šä¹‰ã€‚é¦–å…ˆ batchnorm æ˜¯å°†é€šé“ç»´åº¦è§†ä½œæ ·æœ¬ï¼Œè®¡ç®—å…¶ä»–ç»´åº¦çš„å¹³å‡å€¼å’Œæ–¹å·®åè¿›è¡Œå½’ä¸€åŒ–çš„æ“ä½œã€‚\n$$ \\begin{aligned} BatchNorm\\colon y\u0026=\\gamma\\:\\frac{x-Mean(x)}{\\sqrt{Var(x)+\\varepsilon}}+\\beta\\\\ Mean(x)\u0026=\\frac{1}{N}\\sum_{i=1}^{N}x_{i}\\\\ Var(x)\u0026=\\frac{1}{N}\\sum_{i=1}^{N}(x_{i}-Mean(x))^{2}\\end{aligned}$$ä¸­æ‹¬å·å†…æ˜¯ä¸€äº›éœ€è¦ç»§æ‰¿çš„ Interface. å…¶å…è®¸ attributes, operations å’Œ types å…¬å¼€æ–¹æ³•è°ƒç”¨æ¥å£ï¼Œè€Œä¸éœ€è¦è°ƒç”¨è€…çŸ¥é“ç‰¹å®šçš„æ´¾ç”Ÿç±»å‹ã€‚\narguments æŒ‡å®šäº†ç®—å­éœ€è¦çš„è¾“å…¥ï¼ŒåŒ…æ‹¬å‚æ•°ä»¥åŠä¹‹å‰ä»‹ç»åˆ°çš„ä¸€äº›å±æ€§ã€‚\ndef Tx8be_BatchNorm_InferenceOp : Tx8be_Op\u003c\"BatchNorm_Inference\", [DeclareOpInterfaceMethods\u003coplibinterface\u003e, DeclareOpInterfaceMethods\u003cShardingInterface\u003e, DeclareOpInterfaceMethods\u003cComputeInterface\u003e] { let summary = \"BatchNorm inference\"; let description = [{ Normalizes the operand tensor across all dimensions except for the c dimension and produce a result tensor. }]; let arguments = (ins AnyTensor:$input, AnyTensor:$scale, AnyTensor:$offset, AnyTensor:$mean, AnyTensor:$variance, DefaultValueOptionalStrAttr\u003cStrAttr, \"Unknown\"\u003e:$layout_str, // The following are backend parameters OptionalAttr\u003cTx8be_ParallelAttr\u003e:$chip_parallel, OptionalAttr\u003cTx8be_ParallelAttr\u003e:$tile_parallel, OptionalAttr\u003cTx8be_DevAttr\u003e:$dev_info ); let results = (outs AnyTensor:$output); } Interface Interface å®šä¹‰ä¸€äº›é€šç”¨çš„æ–¹æ³•æˆ–è¡Œä¸ºï¼Œè¿™äº›æ–¹æ³•æ²¡æœ‰å…·ä½“å®ç°ã€‚è¦é€šè¿‡ç»§æ‰¿æŸä¸ª Interface æ¥å…·ä½“å®ç°è¯¥æ¥å£çš„æ–¹æ³•å’Œè¡Œä¸ºã€‚tx8ä¸­å®šä¹‰äº† 5 ä¸ª Interface: OpLibInterface, ComputeInterface, ShapeInferenceOpInterface, ShardingInterface, StreamConfigInterface.\nBatchNorm ç®—å­å¼€å‘ä¸­åªç”¨åˆ°äº†å‰å››ä¸ªï¼Œä¸‹é¢ä¾æ¬¡ä»‹ç»ä¸€ä¸‹ã€‚\nShapeInferenceOpInterface å®šä¹‰äº†ä¸¤ä¸ªæ–¹æ³• inferShapes å’Œ inferLayout. ç»§æ‰¿è¿™ä¸ªæ¥å£çš„è¯å°±éœ€è¦å®ç°è¿™ä¸¤ç§æ–¹æ³•ã€‚æ ¹ä¸»è¦æ˜¯æ ¹æ®è¾“å…¥æ¥æ¨æ–­è¾“å‡ºçš„å½¢çŠ¶å’Œå¸ƒå±€ã€‚\ndef ShapeInferenceOpInterface : OpInterface\u003c\"ShapeInferenceOpInterface\"\u003e { let description = [{ }]; let cppNamespace = \"::tx8be_mlir\"; let methods = [ InterfaceMethod\u003c [{ }], /*retType=*/\"mlir::LogicalResult\", /*methodName=*/\"inferShapes\", // method name /*args=*/(ins \"DynamicShapeParam\" : $shapeParam) \u003e, InterfaceMethod\u003c [{ }], /*retType=*/\"mlir::LogicalResult\", /*methodName=*/\"inferLayout\", // method name /*args=*/(ins) \u003e ]; } ç”±äº batchnorm ä¸å¯¹è¿™ä¸¤è€…è¿›è¡Œæ”¹å˜ï¼Œå› æ­¤è¾“å‡ºå’Œè¾“å…¥ç›¸åŒã€‚å¦‚æœæ˜¯éœ€è¦æ”¹å˜çš„ç®—å­æ¯”å¦‚ transpose å°±éœ€è¦è¿›è¡Œæ”¹å˜ã€‚\ninput_data ",
  "wordCount" : "21991",
  "inLanguage": "en",
  "datePublished": "2025-07-23T11:49:02+08:00",
  "dateModified": "2025-09-19T09:20:48+08:00",
  "author":[{
    "@type": "Person",
    "name": "WITHER"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/blogs/tx8_backend/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "WITHER",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="WITHER (Alt + H)">WITHER</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="http://localhost:1313/zh/" title="ç®€ä½“ä¸­æ–‡"
                            aria-label="ç®€ä½“ä¸­æ–‡">ç®€ä½“ä¸­æ–‡</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/" title="ğŸ  Home">
                    <span>ğŸ  Home</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/about_me/" title="ğŸ™‹ğŸ»â€â™‚ï¸ Me">
                    <span>ğŸ™‹ğŸ»â€â™‚ï¸ Me</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/blogs/" title="ğŸ“š Blogs">
                    <span>ğŸ“š Blogs</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/categories/" title="ğŸ§© Categories">
                    <span>ğŸ§© Categories</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="ğŸ”– Tags">
                    <span>ğŸ”– Tags</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/archives/" title="â± Archive">
                    <span>â± Archive</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="ğŸ” Search (Alt &#43; /)" accesskey=/>
                    <span>ğŸ” Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/friends/" title="ğŸ¤ Friends">
                    <span>ğŸ¤ Friends</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;Â»&nbsp;<a href="http://localhost:1313/blogs/">Blogs</a></div>
    <h1 class="post-title entry-hint-parent">
      TX8 Backend
    </h1>
    <div class="post-description">
      TX8 backend description.
    </div>
    <div class="post-meta"><span title='2025-07-23 11:49:02 +0800 CST'>Jul-23-2025</span>&nbsp;Â·&nbsp;44 min&nbsp;Â·&nbsp;21991 words&nbsp;Â·&nbsp;WITHER

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">Table of Contents</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#tx8-hardware-overview" aria-label="TX8 Hardware Overview">TX8 Hardware Overview</a></li>
                    <li>
                        <a href="#single-tile" aria-label="Single Tile">Single Tile</a></li>
                    <li>
                        <a href="#cgra-tensor" aria-label="CGRA Tensor">CGRA Tensor</a></li>
                    <li>
                        <a href="#tensor-layout" aria-label="Tensor Layout">Tensor Layout</a></li>
                    <li>
                        <a href="#neural-engine" aria-label="Neural Engine">Neural Engine</a></li>
                    <li>
                        <a href="#lsu" aria-label="LSU">LSU</a></li>
                    <li>
                        <a href="#tx8-compiler" aria-label="TX8 Compiler">TX8 Compiler</a></li>
                    <li>
                        <a href="#tx8-be" aria-label="TX8 BE">TX8 BE</a><ul>
                            
                    <li>
                        <a href="#attribute" aria-label="Attribute">Attribute</a></li>
                    <li>
                        <a href="#types" aria-label="Types">Types</a></li>
                    <li>
                        <a href="#operations" aria-label="Operations">Operations</a></li>
                    <li>
                        <a href="#interface" aria-label="Interface">Interface</a></li>
                    <li>
                        <a href="#shardinginterface" aria-label="ShardingInterface">ShardingInterface</a></li>
                    <li>
                        <a href="#oplibinterface" aria-label="OpLibInterface">OpLibInterface</a></li>
                    <li>
                        <a href="#computeinteface" aria-label="ComputeInteface">ComputeInteface</a></li></ul>
                    </li>
                    <li>
                        <a href="#test-case" aria-label="Test Case">Test Case</a></li>
                    <li>
                        <a href="#overview-of-workflow" aria-label="Overview of Workflow">Overview of Workflow</a></li>
                    <li>
                        <a href="#layout-initialization-and-pass" aria-label="Layout Initialization and Pass.">Layout Initialization and Pass.</a><ul>
                            
                    <li>
                        <a href="#layoutinitpass" aria-label="layoutInitPass">layoutInitPass</a></li>
                    <li>
                        <a href="#layouttransmitpass" aria-label="layoutTransmitPass">layoutTransmitPass</a></li>
                    <li>
                        <a href="#layoutaligntonpupass" aria-label="layoutAlignToNpuPass">layoutAlignToNpuPass</a></li></ul>
                    </li>
                    <li>
                        <a href="#const-management" aria-label="Const Management">Const Management</a><ul>
                            
                    <li>
                        <a href="#moveconstantpass" aria-label="MoveConstantPass">MoveConstantPass</a></li>
                    <li>
                        <a href="#constnormpass" aria-label="constNormPass">constNormPass</a></li></ul>
                    </li>
                    <li>
                        <a href="#sharding-search-and-spm-management" aria-label="Sharding Search and SPM Management">Sharding Search and SPM Management</a><ul>
                            
                    <li>
                        <a href="#grouppatternpass" aria-label="GroupPatternPass">GroupPatternPass</a></li>
                    <li>
                        <a href="#groupoptimizationpass" aria-label="GroupOptimizationPass">GroupOptimizationPass</a></li>
                    <li>
                        <a href="#groupldstpass" aria-label="GroupLdStPass">GroupLdStPass</a></li>
                    <li>
                        <a href="#groupmappingpass" aria-label="GroupMappingPass">GroupMappingPass</a></li>
                    <li>
                        <a href="#groupcostpass" aria-label="GroupCostPass">GroupCostPass</a><ul>
                            
                    <li>
                        <a href="#datasplitnewpass" aria-label="DataSplitNewPass">DataSplitNewPass</a></li>
                    <li>
                        <a href="#ts_swpipelinepass" aria-label="TS_SwPipelinePass">TS_SwPipelinePass</a></li>
                    <li>
                        <a href="#spmallocpass" aria-label="SPMAllocPass">SPMAllocPass</a></li></ul>
                    </li></ul>
                    </li>
                    <li>
                        <a href="#compile-option-1-opt_barrier" aria-label="Compile Option 1: opt_barrier">Compile Option 1: opt_barrier</a></li>
                    <li>
                        <a href="#compile-option-1-opt_ddr" aria-label="Compile Option 1: opt_ddr">Compile Option 1: opt_ddr</a>
                    </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    
    document.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();
    
        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
        if (elements.length > 0) {
            
            activeElement = elements[0];
            const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
            document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
        }
    
        
        const topLink = document.getElementById('top-link');
        if (topLink) {
            topLink.addEventListener('click', (event) => {
                
                event.preventDefault();
    
                
                window.scrollTo({ top: 0, behavior: 'smooth' });
            });
        }
    }, false);
    
    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);
    
    window.addEventListener('scroll', () => {
        
        const scrollPosition = window.pageYOffset || document.documentElement.scrollTop;
    
        
        if (scrollPosition === 0) {
            return;
        }
    
        
        if (elements && elements.length > 0) {
            
            activeElement = Array.from(elements).find((element) => {
                if ((getOffsetTop(element) - scrollPosition) > 0 && 
                    (getOffsetTop(element) - scrollPosition) < window.innerHeight / 2) {
                    return element;
                }
            }) || activeElement;
    
            elements.forEach(element => {
                const id = encodeURI(element.getAttribute('id')).toLowerCase();
                const tocLink = document.querySelector(`.inner ul li a[href="#${id}"]`);
                if (element === activeElement){
                    tocLink.classList.add('active');
    
                    
                    const tocContainer = document.querySelector('.toc .inner');
                    const linkOffsetTop = tocLink.offsetTop;
                    const containerHeight = tocContainer.clientHeight;
                    const linkHeight = tocLink.clientHeight;
    
                    
                    const scrollPosition = linkOffsetTop - (containerHeight / 2) + (linkHeight / 2);
                    tocContainer.scrollTo({ top: scrollPosition, behavior: 'smooth' });
                } else {
                    tocLink.classList.remove('active');
                }
            });
        }
    }, false);
    
    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);
    
    function checkTocPosition() {
        const width = document.body.scrollWidth;
    
        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }
    
    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
    
</script>

  <div class="post-content"><h1 id="tx8-hardware-overview">TX8 Hardware Overview<a hidden class="anchor" aria-hidden="true" href="#tx8-hardware-overview">#</a></h1>
<p>TX8 é‡‡ç”¨çš„æ˜¯ç©ºé—´è®¡ç®—å‹ç»“æ„ (Special Computing Architecture)ï¼Œå¸‚é¢ä¸Šæ™®éé‡‡ç”¨çš„å…±äº«å†…å­˜ç»“æ„ (Shared Memory Architecture)ï¼Œå®ƒçš„æ•°æ®é€šä¿¡äº¤äº’ä¸»è¦æ˜¯ä¾èµ–äº DDRï¼Œä¸€ä¸ª thread æŠŠ DDR çš„æ•°æ®æ”¹å˜ä¹‹åï¼Œå¦å¤–ä¸€ä¸ª thread å†ä» DDR ä¸­æ‰èƒ½å¾—çŸ¥åˆ°è¿™ä¸ªæ•°æ®å·²ç»è¢«æ”¹å˜ã€‚è¿™ä¹ˆåšæœ‰ä¸€ä¸ªå¾ˆæ˜æ˜¾çš„ç¼ºé™·ï¼Œå°±æ˜¯å®ƒç“¶é¢ˆåœ¨äºå†…å­˜å®¹é‡ä»¥åŠè®¿é—®å†…å­˜çš„å¸¦å®½å»¶è¿Ÿã€‚ç©ºé—´è®¡ç®—å‹çš„ç»“æ„å®ƒæ˜¯ç”±ä¸­é—´çš„NOC (Network On Chip) æ¥æ„æˆæ¨¡å—ä¹‹é—´çš„äº’è”ã€‚è¿™æ ·å¾ˆå¥½çš„é¿å…äº†è¿™ä¸ª DDR çš„ç“¶é¢ˆï¼ŒåŒæ—¶ä¹Ÿæœ‰äº†æ›´å¥½çš„ scale out èƒ½åŠ›ã€‚</p>
<p>
<figure class="post-figure">
    <a href="https://share.note.youdao.com/yws/api/personal/file/WEB04f094c9d80d3990221020a51ce93433?method=download&amp;shareKey=f6149480beae12e20d31f124e425ef84" target="_blank" rel="noopener">
        <img loading="lazy" src="https://share.note.youdao.com/yws/api/personal/file/WEB04f094c9d80d3990221020a51ce93433?method=download&amp;shareKey=f6149480beae12e20d31f124e425ef84" alt="(a) Shared Memory Architecture (b) Spatial Computing Architecture">
    </a><figcaption>(a) Shared Memory Architecture (b) Spatial Computing Architecture</figcaption></figure></p>
<p>ä¸‹å›¾ä¸º TX8 ä¸¤ä¸ªèŠ¯ç‰‡äº’è¿çš„é€»è¾‘ç»“æ„ã€‚æ¯ä¸ªèŠ¯ç‰‡ç”± 4x4 æ€»è®¡ 16 Tile ä»¥ mesh æ‹“æ‰‘ç»“æ„è¿›è¡Œäº’è¿ã€‚æ¯ä¸€ä¸ª Tile æ˜¯ä¸€ä¸ªè®¡ç®—æ ¸å¿ƒï¼Œæ˜¯ä¸€ä¸ªå›¾çµå®Œå¤‡ (Turing Complete) çš„ç³»ç»Ÿï¼Œæ—¢å…·æœ‰è°ƒåº¦æ§åˆ¶ä»¥åŠè®¡ç®—é€šä¿¡ä»¥åŠå­˜å‚¨çš„èƒ½åŠ›ã€‚ç‰‡ä¸Š NoC é‡‡ç”¨çš„æ˜¯ stream (ä¸€ç§è½»é‡çº§ DMA æŠ€æœ¯). ç‰‡ä¸Š DDR å¤§å°ä¸º 64GBï¼ŒèŠ¯ç‰‡ä¹‹é—´æ˜¯é€šè¿‡ high speed IO è¿›è¡Œäº’è¿çš„ã€‚</p>
<p>
<figure class="post-figure">
    <a href="https://share.note.youdao.com/yws/api/personal/file/WEB98d1d8b5916da28e40cf3c77b63dcbe6?method=download&amp;shareKey=1ca36bb999bfe3f524fc2525e1cb0ab7" target="_blank" rel="noopener">
        <img loading="lazy" src="https://share.note.youdao.com/yws/api/personal/file/WEB98d1d8b5916da28e40cf3c77b63dcbe6?method=download&amp;shareKey=1ca36bb999bfe3f524fc2525e1cb0ab7" alt="Tile">
    </a><figcaption>Tile</figcaption></figure></p>
<p>å•èŠ¯ç‰‡ä¸å•å¡ A100 æ€§èƒ½å¯¹æ¯”å¦‚ä¸‹è¡¨æ‰€ç¤º</p>
<table>
  <thead>
      <tr>
          <th>TX8</th>
          <th>å•å¡æ€§èƒ½</th>
          <th>æœ€å¤§ç»„ç½‘æ€§èƒ½</th>
          <th>A100</th>
          <th>å•å¡æ€§èƒ½</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>INT8</strong></td>
          <td>256T</td>
          <td>1E</td>
          <td></td>
          <td>624T</td>
      </tr>
      <tr>
          <td><strong>BF16</strong></td>
          <td>128T</td>
          <td>0.5E</td>
          <td></td>
          <td>312T</td>
      </tr>
      <tr>
          <td><strong>TFP32</strong></td>
          <td>128T</td>
          <td>0.5E</td>
          <td></td>
          <td>156T</td>
      </tr>
      <tr>
          <td><strong>FP32</strong></td>
          <td>21T</td>
          <td>40P</td>
          <td></td>
          <td>19.5T</td>
      </tr>
      <tr>
          <td><strong>å†…å­˜å¸¦å®½</strong></td>
          <td>200GB/s</td>
          <td>-</td>
          <td><strong>æ˜¾å­˜å¸¦å®½</strong></td>
          <td>1935GB/s</td>
      </tr>
      <tr>
          <td><strong>PCIe</strong></td>
          <td>64GB/s</td>
          <td>-</td>
          <td></td>
          <td>64GB/s</td>
      </tr>
      <tr>
          <td><strong>å†…å­˜å®¹é‡</strong></td>
          <td>64GB</td>
          <td>128TB</td>
          <td><strong>æ˜¾å­˜å®¹é‡</strong></td>
          <td>80GB</td>
      </tr>
      <tr>
          <td><strong>TsingMicro-Link</strong></td>
          <td>1600Gbps</td>
          <td>-</td>
          <td><strong>NV-Link</strong></td>
          <td>600GB/s</td>
      </tr>
  </tbody>
</table>
<h1 id="single-tile">Single Tile<a hidden class="anchor" aria-hidden="true" href="#single-tile">#</a></h1>
<p>ä¸‹å›¾æ˜¯å• Tile çš„ç¡¬ä»¶ç»“æ„ï¼Œå®é™…ä¸Šæ¯ä¸ª Tile ä¸Šä¼šæœ‰ä¸¤ä¸ª kernel core å’Œ special coreï¼Œå›¾ä¸­åªç”»äº†ä¸€ä¸ªã€‚è¿˜æœ‰ä¸ª neural coreï¼Œä¸»è¦æ˜¯è´Ÿè´£è®¡ç®—ä»¥åŠæ•°æ®æ¬è¿ç­‰ç­‰ã€‚</p>
<p>
<figure class="post-figure">
    <a href="https://share.note.youdao.com/yws/api/personal/file/WEB8e08cce47b2de4d373c8dd667a988463?method=download&amp;shareKey=ba34989999d6febf20e7abeda09a81b2" target="_blank" rel="noopener">
        <img loading="lazy" src="https://share.note.youdao.com/yws/api/personal/file/WEB8e08cce47b2de4d373c8dd667a988463?method=download&amp;shareKey=ba34989999d6febf20e7abeda09a81b2" alt="Tile Microarchitecture">
    </a><figcaption>Tile Microarchitecture</figcaption></figure></p>
<ul>
<li>
<p>kernel core ä¸»è¦ç”¨äºä¸‹å‘æŒ‡ä»¤ã€‚å®ƒä¼šä» DDR ä¸­å–å€ï¼Œç„¶åé€åˆ°è¿™ä¸ª neural core çš„ NCC controller é‡Œé¢ã€‚NCC controller åˆä¼šæŠŠæ ¹æ®è¿™ä¸ªæŒ‡ä»¤çš„ç±»å‹ä¸‹å‘åˆ° CT/NE/LSU. ä»–ä»¬ä¸‰ä¸ªæ˜¯æ‰§è¡Œä¸åŒç§ç±»æŒ‡ä»¤çš„ä¸‰ä¸ªå°æ¨¡å—ï¼Œåé¢ä¼šè®²åˆ°ã€‚è¿™ä¸‰ä¸ªå°æ¨¡å—ä¼šä» SPM (Scratched Pad Memory) ä¸Šè¯»å–æ•°æ®ï¼Œç„¶åå†è®¡ç®—ï¼Œæˆ–è€…å†å­˜å› SPMä¸Šã€‚å€¼å¾—æ³¨æ„çš„æ˜¯ï¼ŒLSU æ˜¯ç”¨æ¥è´Ÿè´£è¿™ä¸ªæ•°æ®æ¬è¿çš„ï¼Œæ‰€ä»¥å®ƒå¯ä»¥æŠŠè¿™ä¸ª SPM ä¸Šçš„æ•°æ®ç›´æ¥æ¬åˆ°DDRï¼Œæˆ–è€…æ˜¯ä» DDR æ¬åˆ° SPM ä¸Šã€‚CT å’Œ NE éƒ½æ˜¯è´Ÿè´£è®¡ç®—çš„æ¨¡å—ï¼Œå…¶ä¸­ scalar unit ä½äº NCC controllerï¼Œæ˜¯ä¸€ä¸ªè´Ÿè´£æ ‡é‡è®¡ç®—çš„æ¨¡å—ã€‚</p>
</li>
<li>
<p>special core ç”¨æ¥å’Œ NOC è¿›è¡Œè¿æ¥ï¼Œå®ƒå¯ä»¥ä» DDR ä¸­è¯»å–æ•°æ®ï¼Œç„¶åé€šè¿‡é…ç½® DTE æ¨¡å—å’Œè¿™ä¸ªè¿œç¨‹çš„ Tile è¿›è¡Œé€šä¿¡ã€‚DTE æ¨¡å—ä¹Ÿå¯ä»¥é€šè¿‡ special core å°†æœ¬ Tile ä¸Šçš„ SPM ä¸è¿œç¨‹ Tile ä¸Šçš„ SPM è¿›è¡Œé€šä¿¡ã€‚</p>
</li>
</ul>
<h1 id="cgra-tensor">CGRA Tensor<a hidden class="anchor" aria-hidden="true" href="#cgra-tensor">#</a></h1>
<p>CGRA Tensor æ¨¡å—æ”¯æŒç®—æœ¯è¿ç®—ï¼Œé€»è¾‘è¿ç®—ï¼Œä½æ“ä½œï¼Œæ¿€æ´»å‡½æ•°ï¼Œè¶…è¶Šå‡½æ•°ï¼Œè§„çº¦ï¼Œæ± åŒ–ï¼Œæ•°æ®æ¬ç§»ï¼Œæ ¼å¼è½¬æ¢ï¼Œè¾…åŠ©è®¡ç®—ã€‚</p>
<p>
<figure class="post-figure">
    <a href="https://share.note.youdao.com/yws/api/personal/file/WEB9086e7454a92ac6077331ed5c7f4fc56?method=download&amp;shareKey=834faad50224b52bd4c82ccf738f5293" target="_blank" rel="noopener">
        <img loading="lazy" src="https://share.note.youdao.com/yws/api/personal/file/WEB9086e7454a92ac6077331ed5c7f4fc56?method=download&amp;shareKey=834faad50224b52bd4c82ccf738f5293" alt="CGRA">
    </a><figcaption>CGRA</figcaption></figure></p>
<p>Neural Core Controller ä¸‹å‘æŒ‡ä»¤åˆ° CTRL_UNITï¼Œç„¶å CTRL_UNIT ä¸‹å‘æŒ‡ä»¤åˆ° RAM_ACC_UNIT. RAM_ACC_UNIT è¯»å…¥ SPM çš„æ•°æ®ï¼Œç„¶åé€å…¥ Pipe Unit è¿›è¡Œè¿ç®—ä¹‹åæŠŠç»“æœå­˜å› SPM.</p>
<p>CGRA æŒ‡ä»¤æ ¼å¼å¦‚ä¸‹ã€‚ä¾‹å¦‚ CGRATensor_ArithOp_V_V_absï¼ŒæŒ‡ä»¤æ“ä½œæŒ‡çš„æ˜¯å¯¹å‘é‡å…ƒç´ æ±‚ç»å¯¹å€¼ã€‚</p>
<table>
  <thead>
      <tr>
          <th>æŒ‡ä»¤æ ¼å¼</th>
          <th>CGRATensor_function_format_name.type</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Function</strong></td>
          <td>æè¿°è¯¥å•å…ƒçš„ä¸»è¦åŠŸèƒ½ï¼Œå¦‚ç®—æ•°è¿ç®—ã€å…³ç³»è¿ç®—ã€é€»è¾‘è¿ç®—ç­‰ï¼›</td>
      </tr>
      <tr>
          <td><strong>Format</strong></td>
          <td>æè¿°æ•°æ®çš„å­˜å‚¨æ–¹å¼ï¼Œå¦‚VVã€VSã€Tensorã€VuV åˆ†åˆ«è¡¨ç¤º</br>å‘é‡ä¸å‘é‡è®¡ç®—ã€å‘é‡ä¸æ ‡é‡è®¡ç®—ã€Tensorè®¡ç®—ã€å‘é‡ä¸å•å…ƒå‘é‡è®¡ç®—ï¼›</td>
      </tr>
      <tr>
          <td><strong>Name</strong></td>
          <td>æè¿°å…·ä½“çš„æ“ä½œï¼Œå¦‚åŠ ã€å‡ã€ä¹˜ã€é™¤ç­‰ï¼›</td>
      </tr>
      <tr>
          <td><strong>Type</strong></td>
          <td>è¡¨ç¤ºæ•°æ®ç±»å‹ï¼Œå¦‚ bf16/fp32 ç­‰ï¼›</td>
      </tr>
  </tbody>
</table>
<p>ä¸‹é¢å…·ä½“è®²ä¸€ä¸‹åœ¨ BN ç®—å­å¼€å‘ä¸­ç”¨åˆ°çš„ <code>CGRATensor_ArithOp_V_VuV_mul_loop (bf16 *src, bf16 *dst, bf16 *unit, int rnd, int src_elem_num, int unit_elem_num, int full_src_elem_num, int  full_unit_elem_num)</code>.</p>
<ul>
<li>src/dst/unit åˆ†åˆ«è¡¨ç¤º ä¹Ÿæ˜¯åŸæ•°æ®/å­˜æ•°/å•å…ƒå‘é‡çš„åœ°å€ã€‚</li>
<li>src_elem_num æ˜¯åšä¸€æ¬¡è¿™ä¸ª VuV ä¸­åŸæ•°æ®çš„ä¸ªæ•°ã€‚</li>
<li>unit_elem_num æ˜¯åšä¸€æ¬¡è¿™ä¸ª VuV ä¸­å•å…ƒå‘é‡æ•°æ®çš„ä¸ªæ•°ã€‚</li>
</ul>
<p>åœ¨è®² VuV_mul_loop ä¹‹å‰ï¼Œå…ˆæ¥çœ‹ä¸€ä¸‹è¿™ä¸ª VuV_mul ä¹Ÿå°±æ˜¯æ²¡æœ‰å¾ªç¯çš„å•æ¬¡ç‰ˆæœ¬ã€‚åˆ†ä¸ºä¸¤æ¬¡è¿›è¡Œï¼Œç¬¬ä¸€æ¬¡æ˜¯å‰å››ä¸ªè“è‰²çš„æ–¹å—ä¸æ©™è‰²æ–¹å—ç›¸ä¹˜ï¼Œç¬¬äºŒæ¬¡ä¸ºåå››ä¸ªè“è‰²æ–¹å—ä¸æ©™è‰²æ–¹å—ç›¸ä¹˜ã€‚VuV_mul_loop å³æŠŠè¿™ä¸ªè¿‡ç¨‹é‡å¤å¾ˆå¤šæ¬¡ï¼Œæ‰€ä»¥è¦æ±‚ <code>full_src_elem_num/full_unit_elem_num == src_elem_num/unit_elem_num</code>ï¼Œå¹¶ä¸”<code>unit_elem_num=64</code>.</p>
<p>
<figure class="post-figure">
    <a href="https://share.note.youdao.com/yws/api/personal/file/WEB367ed5ab2178c80abdeb160cb55b409d?method=download&amp;shareKey=05e534d23de8ab1be6cef33b8c8e0e4e" target="_blank" rel="noopener">
        <img loading="lazy" src="https://share.note.youdao.com/yws/api/personal/file/WEB367ed5ab2178c80abdeb160cb55b409d?method=download&amp;shareKey=05e534d23de8ab1be6cef33b8c8e0e4e" alt="VuV_mul_loop">
    </a><figcaption>VuV_mul_loop</figcaption></figure></p>
<h1 id="tensor-layout">Tensor Layout<a hidden class="anchor" aria-hidden="true" href="#tensor-layout">#</a></h1>
<p>layout å¯ä»¥åˆ†ä¸ºä»¥ä¸‹å‡ ç§</p>
<ul>
<li>layout_str: ä¸­ç«¯ä½¿ç”¨
<ul>
<li>CNN Op: 1. Feature (NCHW/NHWC) etc. 2. Weight (OIHW/HWOI) etc.</li>
<li>Non-CNN Op: å¤§æ¨¡å‹ä¸­å¸¸è§ï¼ŒTensor/NTensorï¼Œå®ƒä»¬çš„åŒºåˆ«æ˜¯ç¬¬ 0 ç»´æ˜¯å¦ä¸º 1.</li>
</ul>
</li>
<li>mem_layout: åç«¯ä½¿ç”¨ï¼Œä»£è¡¨äº†åœ¨èŠ¯ç‰‡ä¸Šçš„å®é™…æ’å¸ƒ
<ul>
<li>Tensor/NTensor: æ•°æ®çš„ç´§å¯†æ’å¸ƒ</li>
<li>Cx/NCx: å¯¹ Tensor/NTensor æ ¼å¼åŒ–åçš„ç»“æœï¼Œæ–¹ä¾¿æ˜“ç¡¬ä»¶è¯»å–ã€‚</li>
</ul>
</li>
</ul>
<table>
  <thead>
      <tr>
          <th>dtype</th>
          <th>channel</th>
          <th>description</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>bf16/fp16 <br>/fp32/tf32</td>
          <td>c &lt;= 32</td>
          <td>NHWC, Cå‘4/8/16/32å¯¹é½ï¼ŒN çš„èµ·å§‹åœ°å€å‘ 2048bit å¯¹é½</td>
      </tr>
      <tr>
          <td></td>
          <td>c &gt; 32</td>
          <td>N[CxHW64, HWC0], C0 å‘ 4/8/16/32 å¯¹é½ï¼ŒN çš„èµ·å§‹åœ°å€å‘2048bit å¯¹é½<br>åœ¨ä¸€ä¸ª batch å†…å°† tensor æŒ‰ C åˆ†æˆ Cx*64 å’Œ C0ä¸¤éƒ¨åˆ†</td>
      </tr>
      <tr>
          <td>int8</td>
          <td>c &lt;= 64</td>
          <td>NHWC, C å‘ 4/8/16/32/64å¯¹é½ï¼ŒNçš„èµ·å§‹åœ°å€å‘2048bitå¯¹é½</td>
      </tr>
      <tr>
          <td></td>
          <td>c &gt; 64</td>
          <td>N[CxHW128, HWC0], C0 å‘ 4/8/16/32/64 å¯¹é½ï¼ŒNçš„èµ·å§‹åœ°å€å‘ 2048bit å¯¹é½ <br> åœ¨ä¸€ä¸ª batch å†…å°† tensor æŒ‰ C åˆ†æˆ Cx*128 å’ŒC0 ä¸¤éƒ¨åˆ†</td>
      </tr>
  </tbody>
</table>
<p>å¯¹äº fp16 çš„ 2x1x2x131 çš„æ•°æ®ï¼ŒNTensor æ ¼å¼å­˜å‚¨èµ·å§‹åœ°å€ä¸º 0x0000 æŒ‰å„å­˜å‚¨æ ¼å¼æ’åˆ—å¦‚ä¸‹</p>
<p>
<figure class="post-figure">
    <a href="https://share.note.youdao.com/yws/api/personal/file/WEB47732820f52aa7a0bfd0d22bb2e61e00?method=download&amp;shareKey=03c9e8f103abf576755a3e33e5d5cbc5" target="_blank" rel="noopener">
        <img loading="lazy" src="https://share.note.youdao.com/yws/api/personal/file/WEB47732820f52aa7a0bfd0d22bb2e61e00?method=download&amp;shareKey=03c9e8f103abf576755a3e33e5d5cbc5" alt="NTensor Layout">
    </a><figcaption>NTensor Layout</figcaption></figure></p>
<p>NCx: 131 = 64 x 2 + 3, å°† C åˆ†æˆ 2(Cx) ä¸ª 64 å’Œ 4(C0). batch0 çš„ç»“æŸåœ°å€æ˜¯ 0x1080 (4224), batch1 èµ·å§‹åœ°å€éœ€å¯¹é½åˆ° 2048bitï¼Œå³ 4224&ndash;&gt;2048*3=6144 (0x1800).</p>
<p>
<figure class="post-figure">
    <a href="https://share.note.youdao.com/yws/api/personal/file/WEB53406947a6dafa2bbe98df922f46a954?method=download&amp;shareKey=3e75616e0238e7360bd6930b98941909" target="_blank" rel="noopener">
        <img loading="lazy" src="https://share.note.youdao.com/yws/api/personal/file/WEB53406947a6dafa2bbe98df922f46a954?method=download&amp;shareKey=3e75616e0238e7360bd6930b98941909" alt="NCx Layout">
    </a><figcaption>NCx Layout</figcaption></figure></p>
<h1 id="neural-engine">Neural Engine<a hidden class="anchor" aria-hidden="true" href="#neural-engine">#</a></h1>
<p>Neural engine ç±»ä¼¼äº GPU Tensor Coreï¼Œä¸»è¦æ˜¯å®Œæˆå„ç§çŸ©é˜µ (op_Gemm) å’Œå·ç§¯ (op_Conv) ç±»å‹çš„é«˜æ•ˆå¹¶è¡Œ Tensor è®¡ç®—ã€‚PE Array å®ƒçš„è¿›è¡ŒçŸ©é˜µè¿ç®—çš„éƒ¨åˆ†ï¼Œä¸€æ¬¡å®Œæˆ 8x16x8 å¤§å°çš„çŸ©é˜µä¹˜æ³•ã€‚ç„¶åå®ƒçš„è¾“å…¥æœ‰æ¿€æ´» inputï¼Œè¿˜æœ‰ psumï¼Œè¿˜æœ‰ weightï¼Œä¹Ÿå°±æ˜¯æƒé‡ã€‚</p>
<p>è®¡ç®—ä¹‹åï¼Œè¿˜é¥¿å¯ä»¥è¿›è¡Œåå¤„ç†ï¼Œå¯¹è¿™ä¸ªç»“æœè¿›è¡Œ BN/é‡åŒ–/æ¿€æ´»ç­‰ç­‰ï¼Œç„¶åå†åˆ°è¾“å‡ºï¼Œç„¶åæˆ‘ä»¬è¦ç”¨åˆ°neural engine çš„ç®—å­å…¶å®å¹¶ä¸å¤šï¼Œåªæœ‰ op_Gemm å’Œ op_Conv.</p>
<p>
<figure class="post-figure">
    <a href="https://share.note.youdao.com/yws/api/personal/file/WEBf07a7034750a8723bf35f5cb311251e2?method=download&amp;shareKey=d0c242fdf504441bb4284c72b48908c4" target="_blank" rel="noopener">
        <img loading="lazy" src="https://share.note.youdao.com/yws/api/personal/file/WEBf07a7034750a8723bf35f5cb311251e2?method=download&amp;shareKey=d0c242fdf504441bb4284c72b48908c4" alt="Neural Engine">
    </a><figcaption>Neural Engine</figcaption></figure></p>
<h1 id="lsu">LSU<a hidden class="anchor" aria-hidden="true" href="#lsu">#</a></h1>
<p>LSU æ˜¯è´Ÿè´£æ•°æ®æ¬è¿çš„ DMA æ§åˆ¶å™¨ã€‚å…·ä½“å®ƒæœ‰ä¸‰éƒ¨åˆ†:</p>
<ul>
<li>RDMA: Read DDR &ndash;&gt; SPMï¼Œå¯¹åº”æŒ‡ä»¤æœ‰ op_loadVarï¼Œop_loadConstï¼Œop_rdmaGather.</li>
<li>WDMA: Write SPM &ndash;&gt; DDRï¼Œå¯¹åº”æŒ‡ä»¤æœ‰ op_dma_storeï¼Œop_wdmaScatter.</li>
<li>TDMA: å¯¹æ‰€å± Tile SPM ä¸Šçš„æ•°æ®è¿›è¡Œæ“ä½œï¼Œå¯¹åº”æŒ‡ä»¤æœ‰ op_reshapeï¼Œop_gatherScatter.</li>
</ul>
<p>
<figure class="post-figure">
    <a href="https://share.note.youdao.com/yws/api/personal/file/WEBd7f94b1349b939c2c20a37abf5e57bbc?method=download&amp;shareKey=fb7dd9facaf7ca29424c72eaa4991000" target="_blank" rel="noopener">
        <img loading="lazy" src="https://share.note.youdao.com/yws/api/personal/file/WEBd7f94b1349b939c2c20a37abf5e57bbc?method=download&amp;shareKey=fb7dd9facaf7ca29424c72eaa4991000" alt="LSU">
    </a><figcaption>LSU</figcaption></figure></p>
<p>ä¸€ç§ç»å¸¸ä½¿ç”¨ TDMA çš„æƒ…å†µæ˜¯è¿›è¡Œä½ç²¾åº¦åˆ°é«˜ç²¾åº¦çš„è½¬æ¢ã€‚ä»¥ fp16 -&gt; fp32 ä¸ºä¾‹ï¼Œé¦–å…ˆä¼šè°ƒç”¨ op_gatherScatter æŒ‡ä»¤æŠŠç´§å¯†æ’å¸ƒçš„ä½ç²¾åº¦æ•°æ®è¯»è¿›æ¥ç„¶å scatter åˆ° SPM ä¸Šçš„å¯¹åº”ä½ç½®ä»¥ä¿ç•™ç©ºé—´å­˜å‚¨è½¬æ¢åçš„æ•°æ®ï¼›ç„¶åå†è°ƒç”¨ CGAR convert_fp16_fp32 æŒ‡ä»¤è¿›è¡Œç²¾åº¦è½¬æ¢ã€‚</p>
<p>
<figure class="post-figure">
    <a href="https://share.note.youdao.com/yws/api/personal/file/WEB1079912e78f03abc7a30d0db12ffb046?method=download&amp;shareKey=20f9d8abd3fb47b3194540d639a2f9ee" target="_blank" rel="noopener">
        <img loading="lazy" src="https://share.note.youdao.com/yws/api/personal/file/WEB1079912e78f03abc7a30d0db12ffb046?method=download&amp;shareKey=20f9d8abd3fb47b3194540d639a2f9ee" alt="fp16 to fp32 Conversion">
    </a><figcaption>fp16 to fp32 Conversion</figcaption></figure></p>
<h1 id="tx8-compiler">TX8 Compiler<a hidden class="anchor" aria-hidden="true" href="#tx8-compiler">#</a></h1>
<p>å’Œä¸€èˆ¬ç¼–è¯‘å™¨å·®ä¸å¤šï¼Œå…ˆè·å–å‰ç«¯çš„ Tensorflow/Pytorch ç­‰ç­‰ç”Ÿæˆçš„ mhlo è®¡ç®—å›¾ï¼Œç»è¿‡ä¸­ç«¯çš„å¤„ç†ï¼Œç„¶åè½¬åˆ°åç«¯ã€‚å˜æˆåç«¯ IR. åŒæ—¶åˆä¼šè°ƒç”¨ OPLIB ç®—å­åº“ä¸­çš„ç®—å­æ¥ç”Ÿæˆ main.cï¼Œå°±æ˜¯å¯ä»¥ç›´æ¥æ”¾åœ¨ä¸åŒå¹³å°ä¸Šè¿è¡Œçš„ä¸»ç¨‹åºã€‚å¹³å°å¯ä»¥é€‰æ‹© RISCV å³çœŸå®çš„ç¡¬ä»¶ï¼Œæˆ–è€…æ˜¯ Cmodel è¿›è¡Œæ¨¡æ‹Ÿã€‚</p>
<p>BEIR ä¸»è¦æ˜¯æ¥è¿‡ä¸­ç«¯ä¼ è¿›æ¥çš„ IRï¼Œç„¶åè¿›è¡Œå„ç±»çš„å›¾ä¼˜åŒ–çš„ Passï¼ŒåŒ…æ‹¬ä¸€äº›ç®—å­åˆ‡åˆ†ï¼Œè¿˜æœ‰å†…å­˜è°ƒåº¦ç­‰ç­‰ã€‚æœ€ç»ˆ codegen è¿™ä¸ªå¯ç¼–è¯‘æ‰§è¡Œçš„ main.c çš„æ–‡ä»¶ã€‚ç„¶åå†æ”¾åœ¨å¹³å°ä¸Šå»ç¼–è¯‘å®Œå†è¿è¡Œã€‚</p>
<p>
<figure class="post-figure">
    <a href="https://share.note.youdao.com/yws/api/personal/file/WEB95d5755abd98d22b6bcdaca440c0e8c4?method=download&amp;shareKey=e72432cabeea4cbab293db667ecb0648" target="_blank" rel="noopener">
        <img loading="lazy" src="https://share.note.youdao.com/yws/api/personal/file/WEB95d5755abd98d22b6bcdaca440c0e8c4?method=download&amp;shareKey=e72432cabeea4cbab293db667ecb0648" alt="TX8 Compiler Workflow">
    </a><figcaption>TX8 Compiler Workflow</figcaption></figure></p>
<h1 id="tx8-be">TX8 BE<a hidden class="anchor" aria-hidden="true" href="#tx8-be">#</a></h1>
<p>åç«¯ IR ä½¿ç”¨çš„æ˜¯ MLIRï¼Œç»§æ‰¿ Dialectï¼Œå®šä¹‰äº†è®¸å¤š Operations, Attributes, Types.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-mlir" data-lang="mlir"><span class="line"><span class="cl">def Tx8be_Dialect <span class="p">:</span> Dialect <span class="p">{</span>
</span></span><span class="line"><span class="cl">    let <span class="nl">name =</span> <span class="s">&#34;tx8be&#34;</span><span class="err">;</span>
</span></span><span class="line"><span class="cl">    let <span class="nl">summary =</span> <span class="s">&#34;A low-level dialect for tx8 backend specification&#34;</span><span class="err">;</span>
</span></span><span class="line"><span class="cl">    let <span class="nl">cppNamespace =</span> <span class="s">&#34;::tx8be_mir::tx8be&#34;</span><span class="err">;</span>
</span></span><span class="line"><span class="cl">    let <span class="nl">useDefaultAttributePrinterParser =</span> <span class="m">1</span><span class="err">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="attribute">Attribute<a hidden class="anchor" aria-hidden="true" href="#attribute">#</a></h2>
<p>ä¸‹é¢ä»‹ç»ä¸€äº›å¸¸ç”¨çš„ Attribute.</p>
<p><code>parallel_attr</code> ä¸»è¦æ˜¯è¡¨ç¤º tensor æ¯ä¸ªç»´åº¦ä¸Šæ•°æ®å¹¶è¡Œå’Œå¼ é‡å¹¶è¡Œçš„åˆ‡åˆ†ç­–ç•¥ã€‚</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-mlir" data-lang="mlir"><span class="line"><span class="cl">def Tx8be_ParallelAttr <span class="p">:</span> Tx8be_Attr<span class="p">&lt;</span><span class="s">&#34;Parallel&#34;</span><span class="p">,</span> <span class="s">&#34;parallel_attr&#34;</span><span class="p">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    let <span class="nl">summary =</span> <span class="s">&#34;Structure of parallel information.&#34;</span><span class="err">;</span>
</span></span><span class="line"><span class="cl">    let <span class="nl">parameters =</span> <span class="p">(</span>ins
</span></span><span class="line"><span class="cl">        <span class="s">&#34;ParallelModeAttr&#34;</span> <span class="p">:</span> <span class="err">$</span>parallel<span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="s">&#34;bool&#34;</span> <span class="p">:</span> <span class="err">$</span>is_dp_inner<span class="p">,</span>    <span class="c">// dp dimension is in the inner, otherwise tp
</span></span></span><span class="line"><span class="cl"><span class="c"></span>        <span class="s">&#34;i32&#34;</span> <span class="p">:</span> <span class="err">$</span>dp_dim_x<span class="p">,</span>    <span class="c">// data parallel dimension at x axis
</span></span></span><span class="line"><span class="cl"><span class="c"></span>        <span class="s">&#34;i32&#34;</span> <span class="p">:</span> <span class="err">$</span>dp_dim_y<span class="p">,</span>    <span class="c">// data parallel dimension at y axis
</span></span></span><span class="line"><span class="cl"><span class="c"></span>        <span class="s">&#34;i32&#34;</span> <span class="p">:</span> <span class="err">$</span>dp_dim_z<span class="p">,</span>    <span class="c">// data parallel dimension at z axis
</span></span></span><span class="line"><span class="cl"><span class="c"></span>        <span class="s">&#34;i32&#34;</span> <span class="p">:</span> <span class="err">$</span>tp_dim_x<span class="p">,</span>    <span class="c">// tensor parallel dimension at x axis
</span></span></span><span class="line"><span class="cl"><span class="c"></span>        <span class="s">&#34;i32&#34;</span> <span class="p">:</span> <span class="err">$</span>tp_dim_y<span class="p">,</span>    <span class="c">// tensor parallel dimension at y axis
</span></span></span><span class="line"><span class="cl"><span class="c"></span>        <span class="s">&#34;i32&#34;</span> <span class="p">:</span> <span class="err">$</span>tp_dim_z<span class="p">,</span>    <span class="c">// tensor parallel dimension at z axis
</span></span></span><span class="line"><span class="cl"><span class="c"></span>        <span class="s">&#34;bool&#34;</span> <span class="p">:</span> <span class="err">$</span>sharding_is_given<span class="p">,</span>    <span class="c">// true: is given, false: is not
</span></span></span><span class="line"><span class="cl"><span class="c"></span>        <span class="s">&#34;::mlir::DenseI32ArrayAttr&#34;</span> <span class="p">:</span> <span class="err">$</span>shape_spatial_sharding    <span class="c">// Shape split info
</span></span></span><span class="line"><span class="cl"><span class="c"></span>    <span class="p">)</span><span class="err">;</span>
</span></span><span class="line"><span class="cl">    let <span class="nl">cppNamespace =</span> <span class="s">&#34;::tx8be_mir::tx8be&#34;</span><span class="err">;</span>
</span></span><span class="line"><span class="cl">    let <span class="nl">assemblyFormat =</span> <span class="s">&#34;`&lt;` struct($params) 1&#34;</span><span class="err">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>dev_attr</code> å±æ€§åŒ…å«</p>
<ul>
<li>imm_sizeï¼Œä¹Ÿå°±æ˜¯ç”¨åˆ°çš„è¿™ä¸ªè¾…åŠ©ç©ºé—´çš„å¤§å°ã€‚</li>
<li>mem_layout ä¹Ÿå°±æ˜¯æ•°æ®çš„å­˜å‚¨æ•°æ®çš„æ’å¸ƒã€‚</li>
<li>multi_buf_en æŒ‡æ˜¯å¦ä½¿ç”¨ double buffer.</li>
<li>out_shape_buf_idx æŒ‡çš„æ˜¯è¾“å‡ºä½¿ç”¨ç¬¬å‡ ä¸ªç¼“å†²åŒºã€‚</li>
<li>temporal_mem_slice æ˜¯å•ä¸ª Tile æ¯æ¬¡å¤„ç†çš„æ•°æ®å¤§å°ã€‚</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-mlir" data-lang="mlir"><span class="line"><span class="cl">def Tx8be_DevAttr <span class="p">:</span> Tx8be_Attr<span class="p">&lt;</span><span class="s">&#34;Dev&#34;</span><span class="p">,</span> <span class="s">&#34;dev_attr&#34;</span><span class="p">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    let <span class="nl">summary =</span> <span class="s">&#34;Structure of op parameters on device.&#34;</span><span class="err">;</span>
</span></span><span class="line"><span class="cl">    let <span class="nl">parameters =</span> <span class="p">(</span>ins
</span></span><span class="line"><span class="cl">        <span class="s">&#34;uint64_t&#34;</span> <span class="p">:</span> <span class="err">$</span>imm_size<span class="p">,</span>    <span class="c">// Output memory addr offset
</span></span></span><span class="line"><span class="cl"><span class="c"></span>        <span class="s">&#34;LayoutModeAttr&#34;</span> <span class="p">:</span> <span class="err">$</span>mem_layout<span class="p">,</span>    <span class="c">// Layout
</span></span></span><span class="line"><span class="cl"><span class="c"></span>        <span class="s">&#34;bool&#34;</span> <span class="p">:</span> <span class="err">$</span>multi_buf_en<span class="p">,</span>    <span class="c">// for double buffering
</span></span></span><span class="line"><span class="cl"><span class="c"></span>        <span class="s">&#34;int32_t&#34;</span> <span class="p">:</span> <span class="err">$</span>multi_buf_num<span class="p">,</span>    <span class="c">// for double buffering
</span></span></span><span class="line"><span class="cl"><span class="c"></span>        <span class="s">&#34;mlir::DenseI64ArrayAttr&#34;</span> <span class="p">:</span> <span class="err">$</span>out_shape_buf_idx<span class="p">,</span>    <span class="c">// index for dynamic shape buffer on runtime
</span></span></span><span class="line"><span class="cl"><span class="c"></span>        <span class="s">&#34;mlir::DenseI64ArrayAttr&#34;</span> <span class="p">:</span> <span class="err">$</span>temporal_mem_slice<span class="p">,</span>    <span class="c">// for compute local buffer size
</span></span></span><span class="line"><span class="cl"><span class="c"></span>        <span class="s">&#34;int32_t&#34;</span> <span class="p">:</span> <span class="err">$</span>source_type<span class="p">,</span>    <span class="c">// Software pipeline stage
</span></span></span><span class="line"><span class="cl"><span class="c"></span>        <span class="s">&#34;int64_t&#34;</span> <span class="p">:</span> <span class="err">$</span>imm_addr<span class="p">,</span> 
</span></span><span class="line"><span class="cl">        <span class="s">&#34;mlir::DenseI64ArrayAttr&#34;</span> <span class="p">:</span> <span class="err">$</span>mem_addr    <span class="c">// use array for multibuffer
</span></span></span><span class="line"><span class="cl"><span class="c"></span>    <span class="p">)</span><span class="err">;</span>
</span></span><span class="line"><span class="cl">    let <span class="nl">cppNamespace =</span> <span class="s">&#34;::tx8be_mir::tx8be&#34;</span><span class="err">;</span>
</span></span><span class="line"><span class="cl">    let <span class="nl">assemblyFormat =</span> <span class="s">&#34;`&lt;` struct($params) `&gt;`&#34;</span><span class="err">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>MemScopeMode</code> ç”¨äºæè¿°æ•°æ®å­˜å‚¨åœ¨å“ªé‡Œã€‚</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-mlir" data-lang="mlir"><span class="line"><span class="cl">def Tx8be_MemScopeMode <span class="p">:</span> I32EnumAttr<span class="p">&lt;</span><span class="s">&#34;MemScopeMode&#34;</span><span class="p">,</span> <span class="s">&#34;Specify the memory scope&#34;</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">    <span class="p">[</span>
</span></span><span class="line"><span class="cl">        I32EnumAttrCase<span class="p">&lt;</span><span class="s">&#34;DDR&#34;</span><span class="p">,</span> <span class="m">0</span><span class="p">&gt;,</span>
</span></span><span class="line"><span class="cl">        I32EnumAttrCase<span class="p">&lt;</span><span class="s">&#34;SPM&#34;</span><span class="p">,</span> <span class="m">1</span><span class="p">&gt;,</span>
</span></span><span class="line"><span class="cl">        I32EnumAttrCase<span class="p">&lt;</span><span class="s">&#34;3DDRAM&#34;</span><span class="p">,</span> <span class="m">2</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">]&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        let <span class="nl">genSpecializedAttr =</span> <span class="m">0</span><span class="err">;</span>
</span></span><span class="line"><span class="cl">        let <span class="nl">cppNamespace =</span> <span class="s">&#34;::tx8be_mir::tx8be&#34;</span><span class="err">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></div><h2 id="types">Types<a hidden class="anchor" aria-hidden="true" href="#types">#</a></h2>
<p>å®šä¹‰äº†å¾ˆå¤šç±»å‹ï¼Œå®é™…ä¸Šå¸¸ç”¨çš„å°±æ˜¯ AnyTensorOrNone.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-mlir" data-lang="mlir"><span class="line"><span class="cl">def AnyTensorOrNone<span class="p">:</span> AnyTypeOf<span class="p">&lt;[</span>AnyRankedTensor<span class="p">,</span> NoneType<span class="p">]&gt;</span><span class="err">;</span>
</span></span><span class="line"><span class="cl">def Tx8be_Tuple <span class="p">:</span> NestedTupleOf<span class="p">&lt;[</span>AnyRankedTensor<span class="p">]&gt;</span><span class="err">;</span>
</span></span><span class="line"><span class="cl">def AnyTensorOrTuple <span class="p">:</span> AnyTypeOf<span class="p">&lt;[</span>AnyRankedTensor<span class="p">,</span> Tx8be_Tuple<span class="p">]&gt;</span><span class="err">;</span>
</span></span><span class="line"><span class="cl">def Tx8be_Pred <span class="p">:</span> TypeAlias<span class="p">&lt;</span>I1<span class="p">,</span> <span class="s">&#34;pred (AKA boolean or 1-bit integer)&#34;</span><span class="p">&gt;</span><span class="err">;</span>
</span></span><span class="line"><span class="cl">def Tx8be_PredTensor <span class="p">:</span> TensorOf<span class="p">&lt;[</span>Tx8be_Pred<span class="p">]&gt;</span><span class="err">;</span>
</span></span><span class="line"><span class="cl">def Tx8be_Token <span class="p">:</span> Type<span class="p">&lt;</span>CPred <span class="s">&#34;{$_self-&gt;isa&lt;TokenType&gt;()}&#34;</span><span class="p">,</span> <span class="s">&#34;token&#34;</span><span class="p">&gt;</span><span class="err">;</span>
</span></span><span class="line"><span class="cl">def Tx8be_TensorOrTokenOrTuple <span class="p">:</span> AnyTypeOf<span class="p">&lt;[</span>AnyTensor<span class="p">,</span> Tx8be_Token<span class="p">,</span> Tx8be_Tuple<span class="p">]&gt;</span><span class="err">;</span>
</span></span><span class="line"><span class="cl">def Tx8be_SInt <span class="p">:</span> SignlessIntOfWidths<span class="p">&lt;[</span><span class="m">4</span><span class="p">,</span> <span class="m">8</span><span class="p">,</span> <span class="m">16</span><span class="p">,</span> <span class="m">32</span><span class="p">,</span> <span class="m">64</span><span class="p">]&gt;</span><span class="err">;</span>
</span></span><span class="line"><span class="cl">def Tx8be_UInt <span class="p">:</span> UnsignedIntOfWidths<span class="p">&lt;[</span><span class="m">4</span><span class="p">,</span> <span class="m">8</span><span class="p">,</span> <span class="m">16</span><span class="p">,</span> <span class="m">32</span><span class="p">,</span> <span class="m">64</span><span class="p">]&gt;</span><span class="err">;</span>
</span></span><span class="line"><span class="cl">def Tx8be_Int <span class="p">:</span> AnyTypeOf<span class="p">&lt;[</span>Tx8be_SInt<span class="p">,</span> Tx8be_UInt<span class="p">]&gt;</span><span class="err">;</span>
</span></span></code></pre></div><h2 id="operations">Operations<a hidden class="anchor" aria-hidden="true" href="#operations">#</a></h2>
<p>ä»¥å¼€å‘çš„ BatchNorm_InferenceOp ä¸ºä¾‹è®²è§£ä¸€ä¸‹ Tx8be ä¸­å…³äºç®—å­çš„å®šä¹‰ã€‚é¦–å…ˆ batchnorm æ˜¯å°†é€šé“ç»´åº¦è§†ä½œæ ·æœ¬ï¼Œè®¡ç®—å…¶ä»–ç»´åº¦çš„å¹³å‡å€¼å’Œæ–¹å·®åè¿›è¡Œå½’ä¸€åŒ–çš„æ“ä½œã€‚</p>
$$
\begin{aligned}
BatchNorm\colon y&=\gamma\:\frac{x-Mean(x)}{\sqrt{Var(x)+\varepsilon}}+\beta\\
Mean(x)&=\frac{1}{N}\sum_{i=1}^{N}x_{i}\\
Var(x)&=\frac{1}{N}\sum_{i=1}^{N}(x_{i}-Mean(x))^{2}\end{aligned}$$<p>ä¸­æ‹¬å·å†…æ˜¯ä¸€äº›éœ€è¦ç»§æ‰¿çš„ <a href="https://mlir.llvm.org/docs/Interfaces/">Interface</a>. å…¶å…è®¸ attributes, operations å’Œ types å…¬å¼€æ–¹æ³•è°ƒç”¨æ¥å£ï¼Œè€Œä¸éœ€è¦è°ƒç”¨è€…çŸ¥é“ç‰¹å®šçš„æ´¾ç”Ÿç±»å‹ã€‚</p>
<p>arguments æŒ‡å®šäº†ç®—å­éœ€è¦çš„è¾“å…¥ï¼ŒåŒ…æ‹¬å‚æ•°ä»¥åŠä¹‹å‰ä»‹ç»åˆ°çš„ä¸€äº›å±æ€§ã€‚</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-mlir" data-lang="mlir"><span class="line"><span class="cl">def Tx8be_BatchNorm_InferenceOp <span class="p">:</span> Tx8be_Op<span class="p">&lt;</span><span class="s">&#34;BatchNorm_Inference&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span>DeclareOpInterfaceMethods<span class="p">&lt;</span>oplibinterface<span class="p">&gt;,</span>
</span></span><span class="line"><span class="cl">    DeclareOpInterfaceMethods<span class="p">&lt;</span>ShardingInterface<span class="p">&gt;,</span>
</span></span><span class="line"><span class="cl">    DeclareOpInterfaceMethods<span class="p">&lt;</span>ComputeInterface<span class="p">&gt;]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    let <span class="nl">summary =</span> <span class="s">&#34;BatchNorm inference&#34;</span><span class="err">;</span>
</span></span><span class="line"><span class="cl">    let <span class="nl">description =</span> <span class="p">[{</span>
</span></span><span class="line"><span class="cl">        Normalizes the operand <span class="kt">tensor</span> across all dimensions except for the c dimension
</span></span><span class="line"><span class="cl">        and produce a result <span class="kt">tensor</span><span class="p">.</span>
</span></span><span class="line"><span class="cl">    <span class="p">}]</span><span class="err">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    let <span class="nl">arguments =</span> <span class="p">(</span>ins
</span></span><span class="line"><span class="cl">        AnyTensor<span class="p">:</span><span class="err">$</span>input<span class="p">,</span>
</span></span><span class="line"><span class="cl">        AnyTensor<span class="p">:</span><span class="err">$</span>scale<span class="p">,</span>
</span></span><span class="line"><span class="cl">        AnyTensor<span class="p">:</span><span class="err">$</span>offset<span class="p">,</span>
</span></span><span class="line"><span class="cl">        AnyTensor<span class="p">:</span><span class="err">$</span>mean<span class="p">,</span>
</span></span><span class="line"><span class="cl">        AnyTensor<span class="p">:</span><span class="err">$</span>variance<span class="p">,</span>
</span></span><span class="line"><span class="cl">        DefaultValueOptionalStrAttr<span class="p">&lt;</span>StrAttr<span class="p">,</span> <span class="s">&#34;Unknown&#34;</span><span class="p">&gt;:</span><span class="err">$</span>layout_str<span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="c">// The following are backend parameters
</span></span></span><span class="line"><span class="cl"><span class="c"></span>        OptionalAttr<span class="p">&lt;</span>Tx8be_ParallelAttr<span class="p">&gt;:</span><span class="err">$</span>chip_parallel<span class="p">,</span>
</span></span><span class="line"><span class="cl">        OptionalAttr<span class="p">&lt;</span>Tx8be_ParallelAttr<span class="p">&gt;:</span><span class="err">$</span>tile_parallel<span class="p">,</span>
</span></span><span class="line"><span class="cl">        OptionalAttr<span class="p">&lt;</span>Tx8be_DevAttr<span class="p">&gt;:</span><span class="err">$</span>dev_info
</span></span><span class="line"><span class="cl">    <span class="p">)</span><span class="err">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    let <span class="nl">results =</span> <span class="p">(</span>outs AnyTensor<span class="p">:</span><span class="err">$</span>output<span class="p">)</span><span class="err">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="interface">Interface<a hidden class="anchor" aria-hidden="true" href="#interface">#</a></h2>
<p>Interface å®šä¹‰ä¸€äº›é€šç”¨çš„æ–¹æ³•æˆ–è¡Œä¸ºï¼Œè¿™äº›æ–¹æ³•æ²¡æœ‰å…·ä½“å®ç°ã€‚è¦é€šè¿‡ç»§æ‰¿æŸä¸ª Interface æ¥å…·ä½“å®ç°è¯¥æ¥å£çš„æ–¹æ³•å’Œè¡Œä¸ºã€‚tx8ä¸­å®šä¹‰äº† 5 ä¸ª Interface: OpLibInterface, ComputeInterface, ShapeInferenceOpInterface, ShardingInterface, StreamConfigInterface.</p>
<p>BatchNorm ç®—å­å¼€å‘ä¸­åªç”¨åˆ°äº†å‰å››ä¸ªï¼Œä¸‹é¢ä¾æ¬¡ä»‹ç»ä¸€ä¸‹ã€‚</p>
<p><code>ShapeInferenceOpInterface</code> å®šä¹‰äº†ä¸¤ä¸ªæ–¹æ³• <code>inferShapes</code> å’Œ <code>inferLayout</code>. ç»§æ‰¿è¿™ä¸ªæ¥å£çš„è¯å°±éœ€è¦å®ç°è¿™ä¸¤ç§æ–¹æ³•ã€‚æ ¹ä¸»è¦æ˜¯æ ¹æ®è¾“å…¥æ¥æ¨æ–­è¾“å‡ºçš„å½¢çŠ¶å’Œå¸ƒå±€ã€‚</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-mlir" data-lang="mlir"><span class="line"><span class="cl">def ShapeInferenceOpInterface <span class="p">:</span> OpInterface<span class="p">&lt;</span><span class="s">&#34;ShapeInferenceOpInterface&#34;</span><span class="p">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    let <span class="nl">description =</span> <span class="p">[{</span>
</span></span><span class="line"><span class="cl">    <span class="p">}]</span><span class="err">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    let <span class="nl">cppNamespace =</span> <span class="s">&#34;::tx8be_mlir&#34;</span><span class="err">;</span>
</span></span><span class="line"><span class="cl">    let <span class="nl">methods =</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">        InterfaceMethod<span class="p">&lt;</span>
</span></span><span class="line"><span class="cl">            <span class="p">[{</span> <span class="p">}],</span>
</span></span><span class="line"><span class="cl">            <span class="err">/</span><span class="p">*</span><span class="nl">retType=</span><span class="p">*</span><span class="err">/</span><span class="s">&#34;mlir::LogicalResult&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="err">/</span><span class="p">*</span><span class="nl">methodName=</span><span class="p">*</span><span class="err">/</span><span class="s">&#34;inferShapes&#34;</span><span class="p">,</span>  <span class="c">// method name
</span></span></span><span class="line"><span class="cl"><span class="c"></span>            <span class="err">/</span><span class="p">*</span><span class="nl">args=</span><span class="p">*</span><span class="err">/</span><span class="p">(</span>ins <span class="s">&#34;DynamicShapeParam&#34;</span> <span class="p">:</span> <span class="err">$</span>shapeParam<span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">&gt;,</span>
</span></span><span class="line"><span class="cl">        InterfaceMethod<span class="p">&lt;</span>
</span></span><span class="line"><span class="cl">            <span class="p">[{</span> <span class="p">}],</span>
</span></span><span class="line"><span class="cl">            <span class="err">/</span><span class="p">*</span><span class="nl">retType=</span><span class="p">*</span><span class="err">/</span><span class="s">&#34;mlir::LogicalResult&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="err">/</span><span class="p">*</span><span class="nl">methodName=</span><span class="p">*</span><span class="err">/</span><span class="s">&#34;inferLayout&#34;</span><span class="p">,</span>  <span class="c">// method name
</span></span></span><span class="line"><span class="cl"><span class="c"></span>            <span class="err">/</span><span class="p">*</span><span class="nl">args=</span><span class="p">*</span><span class="err">/</span><span class="p">(</span>ins<span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">]</span><span class="err">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>ç”±äº batchnorm ä¸å¯¹è¿™ä¸¤è€…è¿›è¡Œæ”¹å˜ï¼Œå› æ­¤è¾“å‡ºå’Œè¾“å…¥ç›¸åŒã€‚å¦‚æœæ˜¯éœ€è¦æ”¹å˜çš„ç®—å­æ¯”å¦‚ transpose å°±éœ€è¦è¿›è¡Œæ”¹å˜ã€‚</p>
<p><code>input_data &lt;shape=3x4x5x6, layout=NCHW&gt; --&gt; transpose&lt;permutation=(0,2,3,1)&gt; --&gt; output_data&lt;shape=3x5x6x4, layout=NHWC&gt;</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// BatchNorm_Interface.cpp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">::</span><span class="n">mlir</span><span class="o">::</span><span class="n">LogicalResult</span> <span class="n">tx8be</span><span class="o">::</span><span class="n">BatchNorm_InferenceOp</span><span class="o">::</span><span class="n">inferLayout</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">in_op</span> <span class="o">=</span> <span class="n">getValidDefiningOp</span><span class="p">(</span><span class="n">getInput</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">cur_op</span> <span class="o">=</span> <span class="n">getValidDefiningOp</span><span class="p">(</span><span class="n">getOutput</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="n">ASSERT</span><span class="p">(</span><span class="n">in_op</span><span class="o">-&gt;</span><span class="n">hasAttr</span><span class="p">(</span><span class="s">&#34;layout_str&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">ASSERT</span><span class="p">(</span><span class="n">cur_op</span><span class="o">-&gt;</span><span class="n">hasAttr</span><span class="p">(</span><span class="s">&#34;layout_str&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">i_layout</span> <span class="o">=</span> <span class="n">in_op</span><span class="o">-&gt;</span><span class="n">getAttr</span><span class="p">(</span><span class="s">&#34;layout_str&#34;</span><span class="p">).</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">mlir</span><span class="o">::</span><span class="n">StringAttr</span><span class="o">&gt;</span><span class="p">().</span><span class="n">getValue</span><span class="p">().</span><span class="n">str</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">ctx</span> <span class="o">=</span> <span class="n">cur_op</span><span class="o">-&gt;</span><span class="n">getContext</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">cur_op</span><span class="o">-&gt;</span><span class="n">setAttr</span><span class="p">(</span><span class="s">&#34;layout_str&#34;</span><span class="p">,</span> <span class="n">mlir</span><span class="o">::</span><span class="n">StringAttr</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">i_layout</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">in_op</span><span class="o">-&gt;</span><span class="n">hasAttr</span><span class="p">(</span><span class="s">&#34;dev_info&#34;</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">auto</span> <span class="n">i_dev_layout</span> <span class="o">=</span> <span class="n">getDevInfoLayoutMode</span><span class="p">(</span><span class="n">in_op</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">setDevInfoWithLayout</span><span class="p">(</span><span class="n">cur_op</span><span class="o">-&gt;</span><span class="n">getContext</span><span class="p">(),</span> <span class="n">cur_op</span><span class="p">,</span> <span class="n">i_dev_layout</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">::</span><span class="n">mlir</span><span class="o">::</span><span class="n">success</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">::</span><span class="n">mlir</span><span class="o">::</span><span class="n">LogicalResult</span> <span class="n">tx8be</span><span class="o">::</span><span class="n">BatchNorm_InferenceOp</span><span class="o">::</span><span class="n">inferShapes</span><span class="p">(</span><span class="n">DynamicShapeParam</span> <span class="o">&amp;</span><span class="n">shapeParam</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">tx8be</span><span class="o">::</span><span class="n">BatchNorm_InferenceOp</span><span class="o">::</span><span class="n">getOutput</span><span class="p">().</span><span class="n">setType</span><span class="p">(</span><span class="n">getInput</span><span class="p">().</span><span class="n">getType</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">::</span><span class="n">mlir</span><span class="o">::</span><span class="n">success</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="shardinginterface">ShardingInterface<a hidden class="anchor" aria-hidden="true" href="#shardinginterface">#</a></h2>
<p><code>tileShardingSplit</code> å’Œå‰é¢çš„ <code>inferShapes</code> ä»¥åŠ <code>inferLayout</code> ä¸ä¸€æ ·ã€‚åä¸¤è€…æ˜¯ä»è¾“å…¥ä¿¡æ¯æ¨å‡ºè¾“å‡ºçš„ä¿¡æ¯ã€‚è€Œ <code>tileShardingSplit</code> æ˜¯ç”±è¾“å‡ºçš„çš„åˆ‡åˆ†çš„å› å­æ¥æ¨æ–­å‡ºå„ä¸ªè¾“å…¥çš„åˆ‡åˆ†å› å­ã€‚</p>
<p>
<figure class="post-figure">
    <a href="https://share.note.youdao.com/yws/api/personal/file/WEB8d4fed659394922243574186cf74ef3a?method=download&amp;shareKey=d1461507273efadf9613b1496fd1501c" target="_blank" rel="noopener">
        <img loading="lazy" src="https://share.note.youdao.com/yws/api/personal/file/WEB8d4fed659394922243574186cf74ef3a?method=download&amp;shareKey=d1461507273efadf9613b1496fd1501c" alt="BatchNorm ShardingInterface">
    </a><figcaption>BatchNorm ShardingInterface</figcaption></figure></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-mlir" data-lang="mlir"><span class="line"><span class="cl">def ShardingInterface <span class="p">:</span> OpInterface<span class="p">&lt;</span><span class="s">&#34;ShardingInterface&#34;</span><span class="p">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    let <span class="nl">description =</span> <span class="p">[{</span>
</span></span><span class="line"><span class="cl">    <span class="p">}]</span><span class="err">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    let <span class="nl">cppNamespace =</span> <span class="s">&#34;::tx8be_mlir&#34;</span><span class="err">;</span>
</span></span><span class="line"><span class="cl">    let <span class="nl">methods =</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">        InterfaceMethod<span class="p">&lt;</span>
</span></span><span class="line"><span class="cl">            <span class="err">/</span><span class="p">*</span><span class="nl">desc=</span><span class="p">*</span><span class="err">/</span><span class="p">[{</span> 
</span></span><span class="line"><span class="cl">            <span class="p">}],</span> 
</span></span><span class="line"><span class="cl">            <span class="c">// vector for diff operand&#39;s info
</span></span></span><span class="line"><span class="cl"><span class="c"></span>            <span class="err">/</span><span class="p">*</span><span class="nl">retType=</span><span class="p">*</span><span class="err">/</span><span class="s">&#34;std::vector&lt;tx8be_mlr::ShardingSplitParam&gt;&#34;</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">            <span class="err">/</span><span class="p">*</span><span class="nl">methodName=</span><span class="p">*</span><span class="err">/</span><span class="s">&#34;tileShardingSplit&#34;</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">            <span class="err">/</span><span class="p">*</span><span class="nl">args=</span><span class="p">*</span><span class="err">/</span><span class="p">(</span>ins <span class="s">&#34;ShardingSplitParam&#34;</span> <span class="p">:</span> <span class="err">$</span>param<span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">&gt;,</span>
</span></span><span class="line"><span class="cl">        InterfaceMethod<span class="p">&lt;</span>
</span></span><span class="line"><span class="cl">            <span class="err">/</span><span class="p">*</span><span class="nl">desc=</span><span class="p">*[{</span> 
</span></span><span class="line"><span class="cl">            <span class="p">}],</span> 
</span></span><span class="line"><span class="cl">            <span class="err">/</span><span class="p">*</span><span class="nl">retType=</span><span class="p">*</span><span class="err">/</span><span class="s">&#34;std::vector&lt;tx8be_mlr::SliceParam&gt;&#34;</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">            <span class="err">/</span><span class="p">*</span><span class="nl">methodName=</span><span class="p">*</span><span class="err">/</span><span class="s">&#34;temporalSliceShape&#34;</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">            <span class="err">/</span><span class="p">*</span><span class="nl">args=</span><span class="p">*</span><span class="err">/</span><span class="p">(</span>ins <span class="s">&#34;SliceParam&#34;</span> <span class="p">:</span> <span class="err">$</span>param<span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">&gt;,</span>
</span></span><span class="line"><span class="cl">        InterfaceMethod<span class="p">&lt;</span>
</span></span><span class="line"><span class="cl">            <span class="err">/</span><span class="p">*</span><span class="nl">desc=</span><span class="p">*[{</span> 
</span></span><span class="line"><span class="cl">            <span class="p">}],</span> 
</span></span><span class="line"><span class="cl">            <span class="err">/</span><span class="p">*</span><span class="nl">retType=</span><span class="p">*</span><span class="err">/</span><span class="s">&#34;std::vector&lt;tx8be_mlr::WindowParam&gt;&#34;</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">            <span class="err">/</span><span class="p">*</span><span class="nl">methodName=</span><span class="p">*</span><span class="err">/</span><span class="s">&#34;backWindow&#34;</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">            <span class="err">/</span><span class="p">*</span><span class="nl">args=</span><span class="p">*</span><span class="err">/</span><span class="p">(</span>ins <span class="s">&#34;const WindowParam&#34;</span> <span class="p">:</span> <span class="err">$</span>param<span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">]</span><span class="err">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>Sharding æ˜¯ç©ºé—´ä¸Šçš„åˆ‡åˆ†ï¼Œæ„æ€æ˜¯å°†æ•°æ®åˆ†æ•£åˆ°ä¸åŒçš„ Tile ä¸Šã€‚</li>
<li>Split æ˜¯æ—¶é—´ä¸Šçš„åˆ‡åˆ†ï¼Œæ„æ€æ˜¯åˆ‡åˆ†åˆ° Tile ä¸Šçš„å°†æ•°æ®æŒ‰æµæ°´çº¿æ–¹å¼è½®æµè¿›è¡Œ load.</li>
</ul>
<p><code>temporalSliceShape</code> è¿”å›çš„æ˜¯ sharding + split åä¸€ä¸ª Tile ä¸Šå•æ¬¡å¤„ç†çš„æ•°æ®çš„å®é™… shape.</p>
<p>
<figure class="post-figure">
    <a href="https://share.note.youdao.com/yws/api/personal/file/WEB4495c3579079b37d0c2288cc51408601?method=download&amp;shareKey=0513d93d3b51c4782d56c38acb83d0d5" target="_blank" rel="noopener">
        <img loading="lazy" src="https://share.note.youdao.com/yws/api/personal/file/WEB4495c3579079b37d0c2288cc51408601?method=download&amp;shareKey=0513d93d3b51c4782d56c38acb83d0d5" alt="BatchNorm Sharding Split">
    </a><figcaption>BatchNorm Sharding Split</figcaption></figure>
æ ¹æ® batchnorm ç®—å­å®šä¹‰ input åªèƒ½åœ¨é€šé“ç»´åº¦ä¸Š sharding.
split æœ‰ä¸¤ç§é€‰æ‹©</p>
<ol>
<li>å¯¹äº input å’Œ meanï¼Œvarï¼Œscaleï¼Œshift éƒ½åœ¨ C ç»´åº¦ä¸Šåšç›¸åŒçš„åˆ‡åˆ†ã€‚</li>
<li>ä¸å† split meanï¼Œvarï¼Œscaleï¼Œshiftï¼Œåªå¯¹ input çš„ NHW è¿›è¡Œ split.</li>
</ol>
<p>è¿™é‡Œé‡‡ç”¨çš„æ˜¯åè€…ã€‚ç”±äº mean, variance, scale, shift éƒ½æ˜¯ 1x1x1xC çš„å¼ é‡ï¼Œå› æ­¤ split ä¸º (1, 1, 1, 1). åˆ‡åˆ†æœç´¢å¾—åˆ°çš„ç¬¦åˆè¦æ±‚çš„ ShardingSplitParam (ä¸‹å›¾ä¸­ä¸º cn3) ä¼šç»§ç»­å‘ä¸Šä¼ é€’ã€‚</p>
<p>
<figure class="post-figure">
    <a href="https://share.note.youdao.com/yws/api/personal/file/WEBc472f9ed0d922130ec05d93efed54186?method=download&amp;shareKey=8bf08e0631cd4c7880b9756969fd4bef" target="_blank" rel="noopener">
        <img loading="lazy" src="https://share.note.youdao.com/yws/api/personal/file/WEBc472f9ed0d922130ec05d93efed54186?method=download&amp;shareKey=8bf08e0631cd4c7880b9756969fd4bef" alt="Sharding Split Search">
    </a><figcaption>Sharding Split Search</figcaption></figure></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ShardingSplitParam</span><span class="o">&gt;</span> <span class="n">tx8be</span><span class="o">::</span><span class="n">BatchNorm_InferenceOp</span><span class="o">::</span><span class="n">tileShardingSplit</span><span class="p">(</span><span class="n">ShardingSplitParam</span> <span class="o">&amp;</span><span class="n">param</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">shape</span> <span class="o">=</span> <span class="n">getOutput</span><span class="p">().</span><span class="n">getType</span><span class="p">().</span><span class="n">getShape</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">ASSERT</span><span class="p">(</span><span class="n">shape</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">param</span><span class="p">.</span><span class="n">outSharding</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">shape</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">param</span><span class="p">.</span><span class="n">outSplit</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int32_t</span> <span class="n">shape_size</span> <span class="o">=</span> <span class="n">shape</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ShardingSplitParam</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">result</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">param</span><span class="p">);</span> <span class="c1">// input
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">shape_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">outSharding</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">outSharding</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// can only shard in dim C
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">outSharding</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">outSplit</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">outSplit</span><span class="p">[</span><span class="n">shape_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// can only split except dim C
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">outSplit</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">ShardingSplitParam</span> <span class="n">paramMean</span><span class="p">;</span> <span class="c1">// scale/shift/mean/variance
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">outSharding</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">paramMean</span><span class="p">.</span><span class="n">outSharding</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">outSharding</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">paramMean</span><span class="p">.</span><span class="n">outSplit</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">shape_size</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>  <span class="c1">// shape is 1x1x1xCï¼Œsplit must be (1, 1, 1, 1)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="n">ShardingSplitParam</span> <span class="n">paramVar</span> <span class="o">=</span> <span class="n">paramMean</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">ShardingSplitParam</span> <span class="n">paramScale</span> <span class="o">=</span> <span class="n">paramMean</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">ShardingSplitParam</span> <span class="n">paramShift</span> <span class="o">=</span> <span class="n">paramMean</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">result</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">paramScale</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">result</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">paramShift</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">result</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">paramMean</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">result</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">paramVar</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="oplibinterface">OpLibInterface<a hidden class="anchor" aria-hidden="true" href="#oplibinterface">#</a></h2>
<p><code>OpLibInterface</code> æœ‰å››ä¸ªæ–¹æ³•ï¼Œ</p>
<ul>
<li><code>genOpCode</code>: ç”Ÿæˆ main.c æ–‡ä»¶çš„æ—¶å€™æ‰€è°ƒç”¨çš„ä¸€ä¸ªæ¥å£ã€‚</li>
<li><code>getOpClockCycle</code>: è·å– OP çš„æ‰§è¡Œæ—¶é—´ã€‚</li>
<li><code>getImmSpSize</code>: è·å– SPM ä¸Šä¸´æ—¶ç©ºé—´æ‰€éœ€è¦çš„å¤§å°ã€‚</li>
<li><code>queryOpAttr</code>: æŸ¥è¯¢è¿™ä¸ª OP çš„ä¸€äº›å±æ€§ã€‚</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">def</span> <span class="nl">OpLibInterface</span> <span class="p">:</span> <span class="n">OpInterface</span><span class="o">&lt;</span><span class="s">&#34;OpLibInterface&#34;</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">let</span> <span class="n">description</span> <span class="o">=</span> <span class="p">[{</span>
</span></span><span class="line"><span class="cl">        <span class="n">These</span> <span class="n">are</span> <span class="n">the</span> <span class="n">interfaces</span> <span class="k">for</span> <span class="n">connecting</span> <span class="n">tx8be</span><span class="o">-</span><span class="n">oplib</span>
</span></span><span class="line"><span class="cl">        <span class="n">and</span> <span class="n">codegen</span><span class="p">.</span>
</span></span><span class="line"><span class="cl">    <span class="p">}];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">let</span> <span class="n">cppNamespace</span> <span class="o">=</span> <span class="s">&#34;::tx8be_mlir&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">let</span> <span class="n">methods</span> <span class="o">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">        <span class="n">InterfaceMethod</span><span class="o">&lt;</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/*desc=*/</span><span class="p">[{</span><span class="n">To</span> <span class="n">generate</span> <span class="n">the</span> <span class="n">code</span> <span class="n">of</span> <span class="n">op</span><span class="p">.}],</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/*retType=*/</span><span class="s">&#34;std::string&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/*methodName=*/</span><span class="s">&#34;genOpCode&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/*args=*/</span><span class="p">(</span><span class="n">ins</span> <span class="s">&#34;OpCodeParam&#34;</span> <span class="o">:</span> <span class="err">$</span><span class="n">param</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">&gt;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="n">InterfaceMethod</span><span class="o">&lt;</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/*desc=*/</span><span class="p">[{</span><span class="n">To</span> <span class="n">get</span> <span class="n">clock</span> <span class="n">cycle</span> <span class="n">of</span> <span class="n">the</span> <span class="n">op</span><span class="p">.}],</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/*retType=*/</span><span class="s">&#34;uint64_t&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/*methodName=*/</span><span class="s">&#34;getOpClockCycle&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/*args=*/</span><span class="p">(</span><span class="n">ins</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">&gt;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="n">InterfaceMethod</span><span class="o">&lt;</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/*desc=*/</span><span class="p">[{</span><span class="n">To</span> <span class="n">get</span> <span class="n">the</span> <span class="n">immediate</span> <span class="n">SPM</span> <span class="n">buffer</span> <span class="n">size</span><span class="p">.}],</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/*retType=*/</span><span class="s">&#34;uint32_t&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="s">&#34;getImmSpSize&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/*args=*/</span><span class="p">(</span><span class="n">ins</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">&gt;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="n">InterfaceMethod</span><span class="o">&lt;</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/*desc=*/</span><span class="p">[{</span><span class="n">To</span> <span class="n">get</span> <span class="n">the</span> <span class="n">opAttr</span> <span class="n">info</span><span class="p">.}],</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/*retType=*/</span><span class="s">&#34;tx8be_mlr::opAttr&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/*methodName=*/</span><span class="s">&#34;queryOpAttr&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/*args=*/</span><span class="p">(</span><span class="n">ins</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>å…¶ä¸­ <code>queryOpAttr</code> æ¥å£åªéœ€è¦åœ¨å¯¹åº”çš„æ¥å£é‡Œç»™ OpAttr é‡Œçš„å‚æ•°èµ‹å€¼ã€‚</p>
<ul>
<li><code>alignMode</code>: ç®—å­çš„å¯¹é½è¦æ±‚ï¼Œæœ‰Cxå¯¹é½è¦æ±‚ï¼ŒNCx å¯¹é½è¦æ±‚ï¼Œæˆ–è€…ä¸åœ¨æ„å­˜å‚¨æ ¼å¼çš„ã€‚</li>
<li><code>defaultLayout</code>: ç®—å­é»˜è®¤çš„æ’å¸ƒã€‚</li>
<li><code>needPresetToNPU</code>: OP æ˜¯å¦éœ€è¦è¿›è¡Œé¢„è®¾åˆ°å’Œç¡¬ä»¶åŒ¹é…çš„ layout. å½“ç®—å­ç”¨åˆ°çš„æŒ‡ä»¤æ˜¯å¸¦æœ‰ NHWC çš„é…ç½®æ—¶å€™çš„éœ€è¦ã€‚</li>
<li><code>memInplace</code>: è¾“å…¥å’Œè¾“å‡ºèƒ½å¦ä½¿ç”¨åŒä¸€ç‰‡å†…å­˜ã€‚</li>
<li><code>needLoad</code>: ç®—å­æ˜¯å¦éœ€è¦ load æ“ä½œï¼Œæ¯”å¦‚ mask, embedding å°±ä¸éœ€è¦ï¼Œä¼šè·³è¿‡loadvar op ç”Ÿæˆã€‚bit0 è¡¨ç¤º arg idx0ï¼Œbit1 è¡¨ç¤º arg idx1ï¼Œä¸€å…±èƒ½è¡¨ç¤º 64 ä¸ªè¾“å…¥æƒ…å†µã€‚å¦‚æœæ˜¯constè¾“å…¥ï¼Œloadconst ä¹Ÿä¼šè·³è¿‡codegen ä¸ç”Ÿæˆ code.
<blockquote>
<p>ä¸€ä¸ªopå¯èƒ½æœ‰å¤šä¸ª input éƒ½æ²¡æœ‰ loadï¼Œshape æ›´æ–°åªç”¨æœ€åä¸€ä¸ªæ²¡æœ‰ load çš„ operand (ä¸º 0 çš„æœ€é«˜ä½). å¦‚ embedding çš„ shapeä½¿ç”¨æœ€åä¸€ä¸ª operandï¼Œç¬¬ä¸€ä¸ªæ˜¯ weight ä¸ç”¨ç®¡ gshape. scatteræœ‰çš„æœ‰loadï¼Œæœ‰çš„æ²¡æœ‰ï¼Œshape æ›´æ–°åªçœ‹æ²¡æœ‰ load çš„é‚£ä¸ªã€‚</p></blockquote>
</li>
<li><code>needStore</code>:  æ•°æ®æ˜¯å¦éœ€è¦è¿›è¡Œ store æ“ä½œï¼Œä¼šè·³è¿‡store op ç”Ÿæˆã€‚</li>
<li><code>parallel</code>: æ˜¯å¦å…è®¸å¹¶è¡Œæ¨¡å¼ã€‚</li>
<li><code>alignCx</code>: æœ€ä½ç»´åº¦åˆ‡åˆ†æ˜¯å¦åˆ° 64/128 (i8).</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">OpAttr</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ALIGN_MODE</span> <span class="n">alignMode</span><span class="p">{</span><span class="n">ALIGN_MODE</span><span class="o">::</span><span class="n">NPU_UNKNOWN</span><span class="p">};</span>  <span class="c1">// ç®—å­çš„å¯¹é½è¦æ±‚ï¼Œæœ‰Cxå¯¹é½è¦æ±‚ï¼ŒNCxå¯¹é½è¦æ±‚ï¼Œæˆ–è€…ä¸åœ¨æ„å­˜å‚¨æ ¼å¼çš„
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">defaultLayout</span><span class="p">{</span><span class="s">&#34;Tensor&#34;</span><span class="p">};</span>           <span class="c1">// ç®—å­é»˜è®¤çš„layout
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">bool</span> <span class="n">needPresetToNPU</span><span class="p">{</span><span class="nb">false</span><span class="p">};</span>                   <span class="c1">// opæ˜¯å¦éœ€è¦è¿›è¡Œé¢„è®¾åˆ°å’Œç¡¬ä»¶åŒ¹é…çš„layout. å½“ç®—å­ç”¨åˆ°çš„æŒ‡ä»¤æ˜¯å¸¦æœ‰ nhwc çš„é…ç½®æ—¶éœ€è¦
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="n">ENGINE_TYPE</span> <span class="n">engine</span><span class="p">{</span><span class="n">NPU_ENGINE_CT</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="n">memInplace</span><span class="p">{</span><span class="nb">false</span><span class="p">};</span>                        <span class="c1">// opçš„è¾“å…¥å’Œè¾“å‡ºèƒ½å¦ä½¿ç”¨åŒä¸€ç‰‡memoryï¼Œæ¯”å¦‚addçš„outä½¿ç”¨in0çš„
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">uint64_t</span> <span class="n">needLoad</span><span class="p">{</span><span class="mh">0xFFFFFFFFFFFFFFFF</span><span class="p">};</span>         <span class="c1">// ç®—å­æ˜¯å¦éœ€è¦loadæ“ä½œ
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">uint64_t</span> <span class="n">needStore</span><span class="p">{</span><span class="mh">0xFFFFFFFFFFFFFFFF</span><span class="p">};</span>        <span class="c1">// æ•°æ®æ˜¯å¦éœ€è¦è¿›è¡Œstoreæ“ä½œï¼Œä¼šè·³è¿‡store opç”Ÿæˆ
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">bool</span> <span class="n">parallel</span><span class="p">{</span><span class="mi">1</span><span class="p">};</span>                              <span class="c1">// ä¸€èˆ¬è¦ä½¿èƒ½å¹¶è¡Œæ¨¡å¼ï¼Œä¸è¿‡æœ‰çš„memoryå¯èƒ½æœ‰é—®é¢˜ï¼Œå°±ä¸ä½¿èƒ½
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">bool</span> <span class="n">alignCx</span><span class="p">{</span><span class="mi">1</span><span class="p">};</span>                               <span class="c1">// æœ€ä½ç»´åº¦åˆ‡åˆ†æ˜¯å¦åˆ°64/128(i8)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></div><p>batchnorm å…è®¸è¾“å…¥ in çš„ layout ä¸º Cx/NCxï¼Œè¦åœ¨ mlir å±‚çš„ <code>queryOpAttr()</code> é‡Œå°† alignMode è®¾ç½®ä¸ºNPU_ALIGN, ç»´åº¦ä¸º 2/3/4ï¼Œæ•°æ®ç±»å‹ä¸º bf16/fp16/fp32/tf32. å…¶ä»–è¾“å…¥çš„æ ¼å¼ä¸º fp32. è¾“å‡ºçš„ç»´åº¦å’Œç±»å‹ä¸ in ä¿æŒä¸€è‡´ã€‚</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">OpAttr</span> <span class="n">tx8be</span><span class="o">::</span><span class="n">BatchNorm_InferenceOp</span><span class="o">::</span><span class="n">queryOpAttr</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">OpAttr</span> <span class="n">attr</span><span class="p">;</span>  <span class="c1">// åˆ›å»ºä¸€ä¸ª OpAttr å¯¹è±¡
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">attr</span><span class="p">.</span><span class="n">alignMode</span> <span class="o">=</span> <span class="n">ALIGN_MODE</span><span class="o">::</span><span class="n">NPU_ALIGN</span><span class="p">;</span>  <span class="c1">// è®¾ç½®å¯¹é½æ¨¡å¼ä¸º NPU_ALIGN
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">attr</span><span class="p">.</span><span class="n">needPresetToNPU</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>  <span class="c1">// è®¾ç½®éœ€è¦é¢„è®¾åˆ° NPU
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// è·å– in çš„å½¢çŠ¶ï¼Œå¹¶åˆ¤æ–­å…¶ç¬¬ä¸€ä¸ªç»´åº¦æ˜¯å¦ä¸º 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">auto</span> <span class="n">batch</span> <span class="o">=</span> <span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">getType</span><span class="p">().</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">mlir</span><span class="o">::</span><span class="n">ShapedType</span><span class="o">&gt;</span><span class="p">().</span><span class="n">getShape</span><span class="p">()[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="n">attr</span><span class="p">.</span><span class="n">defaultLayout</span> <span class="o">=</span> <span class="n">batch</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">?</span> <span class="s">&#34;Tensor&#34;</span> <span class="o">:</span> <span class="s">&#34;NTensor&#34;</span><span class="p">;</span>  <span class="c1">// æ ¹æ® batch çš„å€¼è®¾ç½®é»˜è®¤å¸ƒå±€
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">attr</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>å¦‚ä¸‹å›¾æ‰€ç¤ºï¼Œåç«¯ç¼–è¯‘å™¨ä¼šè°ƒç”¨ genOpCode ç”Ÿæˆç›¸å¯¹åº”çš„ main.c. ç„¶å host.cpp å†æŠŠ main.c æ”¾åˆ°ä¸åŒçš„å¹³å°ä¸Šé¢å»ç¼–è¯‘å®Œå†å»æ‰§è¡Œã€‚</p>
<p>
<figure class="post-figure">
    <a href="https://share.note.youdao.com/yws/api/personal/file/WEBdb6a91e8bb45cbce292f6fdf1fafd0f4?method=download&amp;shareKey=91e74089c887f70b2b508d9a31b877fd" target="_blank" rel="noopener">
        <img loading="lazy" src="https://share.note.youdao.com/yws/api/personal/file/WEBdb6a91e8bb45cbce292f6fdf1fafd0f4?method=download&amp;shareKey=91e74089c887f70b2b508d9a31b877fd" alt="OpLibInterface">
    </a><figcaption>OpLibInterface</figcaption></figure></p>
<p>main.c ä¸»è¦åšçš„å°±æ˜¯ load &ndash;&gt; compute &ndash;&gt; store è¿™ä¸‰æ­¥ã€‚ä¼ªä»£ç å¦‚ä¸‹ï¼Œç”±äºè¿›è¡Œäº†æ—¶é—´ä¸Šçš„ splitï¼Œéœ€è¦å¾ªç¯å¤šæ¬¡æ‰èƒ½è¯»å–å®Œæ•´çš„æ•°æ®ã€‚</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">input_done</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// load
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">op_dma_load</span> <span class="n">Input</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">input_done</span> <span class="o">=</span> <span class="n">Input</span><span class="p">.</span><span class="n">load_finish</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">op_dma_load</span> <span class="n">scale</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">op_dma_load</span> <span class="n">shift</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">op_dma_load</span> <span class="n">mean</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">op_dma_load</span> <span class="n">varience</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="c1">// compute
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">op_batchnorm_inference</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">input</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">varience</span><span class="p">,</span> <span class="n">out</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// store
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">op_store_var_ncx</span> <span class="n">out</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>op_batchnorm_inference</code> çš„å®šä¹‰å¦‚ä¸‹ï¼Œå…¶ä¸­ imm æ˜¯è¾…åŠ©ç©ºé—´ï¼Œæ­¤å¤„ç”³è¯·äº† 2xsizeof(input) Bytes.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">uint64_t</span> <span class="nf">op_batchnorm_inference</span><span class="p">(</span><span class="n">BATCHNORM_INFER_PARAM</span> <span class="o">*</span><span class="n">param</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">                                <span class="n">TSR</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span> <span class="n">TSR</span> <span class="o">*</span><span class="n">scale</span><span class="p">,</span> <span class="n">TSR</span> <span class="o">*</span><span class="n">shift</span><span class="p">,</span> <span class="n">TSR</span> <span class="o">*</span><span class="n">mean</span><span class="p">,</span> <span class="n">TSR</span> <span class="o">*</span><span class="n">var</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">                                <span class="n">TSR</span> <span class="o">*</span><span class="n">imm</span><span class="p">,</span> <span class="n">TSR</span> <span class="o">*</span><span class="n">out</span><span class="p">);</span>
</span></span></code></pre></div><p>å…¶ä¸­ TSR æ˜¯ä¸€ä¸ªè‡ªå®šä¹‰çš„ç»“æ„ä½“ï¼ŒåŒ…æ‹¬æ•°æ®æ ¼å¼ï¼Œåœ°å€ä»¥åŠä¸€ä¸ª L_shape (load shape). é‡Œé¢è®°å½•äº†å¼ é‡å®Œæ•´çš„å¤§å° shape_wholeï¼Œä»¥åŠæœ¬ Tile ä¸Šæ¯ä¸ªç»´åº¦èµ·å§‹ä¸‹æ ‡ shape_startï¼Œæ¯ä¸ªç»´åº¦åŠ è½½çš„å¤§å° shape_slice å’Œ shape çš„ç»´åº¦å¤§å° dim.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">L_SHAPE</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int32_t</span> <span class="n">shape_whole</span><span class="p">[</span><span class="n">MAX_SHAPE_DIM</span><span class="p">];</span>  <span class="c1">// the whole shape
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int32_t</span> <span class="n">shape_start</span><span class="p">[</span><span class="n">MAX_SHAPE_DIM</span><span class="p">];</span>  <span class="c1">// start idx of the shape slice
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int32_t</span> <span class="n">shape_slice</span><span class="p">[</span><span class="n">MAX_SHAPE_DIM</span><span class="p">];</span>  <span class="c1">// length of the shape slice
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int32_t</span> <span class="n">shape_real</span><span class="p">[</span><span class="n">MAX_SHAPE_DIM</span><span class="p">];</span>   <span class="c1">// real length of the shape slice
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int32_t</span> <span class="n">dim</span><span class="p">;</span>                         <span class="c1">// dimension of the shape
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="n">L_SHAPE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">G_SHAPE</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int32_t</span> <span class="n">spatial_start</span><span class="p">[</span><span class="n">MAX_SHAPE_DIM</span><span class="p">];</span>  <span class="c1">// [start, end]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int32_t</span> <span class="n">spatial_end</span><span class="p">[</span><span class="n">MAX_SHAPE_DIM</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int32_t</span> <span class="n">dynamic_offset</span><span class="p">[</span><span class="n">MAX_SHAPE_DIM</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int32_t</span> <span class="n">shape</span><span class="p">[</span><span class="n">MAX_SHAPE_DIM</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int32_t</span> <span class="n">dim</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int32_t</span> <span class="n">done</span><span class="p">;</span>                         <span class="c1">// done for dma load finish
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int32_t</span> <span class="n">batch_offset</span><span class="p">[</span><span class="n">MAX_SHAPE_DIM</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">G_SHAPE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">TSR</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Data_Format</span> <span class="n">format</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint64_t</span> <span class="n">addr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">L_SHAPE</span><span class="o">*</span> <span class="n">shape</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">TSR</span><span class="p">;</span>
</span></span></code></pre></div><p>
<figure class="post-figure">
    <a href="https://share.note.youdao.com/yws/api/personal/file/WEB863424dc56bf5d86b25f817e06a1c716?method=download&amp;shareKey=de577bac9b2b5b108c4a3e8a275d07ea" target="_blank" rel="noopener">
        <img loading="lazy" src="https://share.note.youdao.com/yws/api/personal/file/WEB863424dc56bf5d86b25f817e06a1c716?method=download&amp;shareKey=de577bac9b2b5b108c4a3e8a275d07ea" alt="BatchNorm Design">
    </a><figcaption>BatchNorm Design</figcaption></figure></p>
<p>å¯¹äºé fp32 ç±»å‹æ•°æ® (ä»¥ fp16 ä¸ºä¾‹) è®¡ç®—è¿‡ç¨‹ä¸ç©ºé—´åˆ†é…å¦‚ä¸‹å›¾æ‰€ç¤ºã€‚</p>
<ol>
<li>ç±»å‹è½¬æ¢æˆ fp32: gatherScatter.</li>
<li>è°ƒç”¨ fp16-&gt;fp32 å‡½æ•°è¿›è¡Œè½¬æ¢ã€‚</li>
<li>å¾ªç¯è®¡ç®— x-Mean (å› ä¸ºå¯¹ in çš„ NHW ç»´åº¦è¿›è¡Œäº† split)ï¼Œç»“æœå­˜å…¥ imm_a.</li>
<li>Varience è‡ªåŠ  epsilon(1e-6).</li>
<li>Varience è¿›è¡Œ rsqrt æ“ä½œã€‚</li>
<li>Varience ä¸ x-Mean è¿›è¡Œå¾ªç¯ä¹˜ã€‚</li>
<li>å¾ªç¯ä¹˜ scale.</li>
<li>å¾ªç¯åŠ  shift.</li>
<li>fp32 è½¬å› f16.</li>
<li>gatherScatter åˆ° out å¤„ã€‚</li>
</ol>
<p>
<figure class="post-figure">
    <a href="https://share.note.youdao.com/yws/api/personal/file/WEB427f45ff2571bf94eea6a0b81f897ba1?method=download&amp;shareKey=57a2c93fd8b252f86c47c8e71e325f2c" target="_blank" rel="noopener">
        <img loading="lazy" src="https://share.note.youdao.com/yws/api/personal/file/WEB427f45ff2571bf94eea6a0b81f897ba1?method=download&amp;shareKey=57a2c93fd8b252f86c47c8e71e325f2c" alt="Batchnorm Computation Flow">
    </a><figcaption>Batchnorm Computation Flow</figcaption></figure></p>
<p>è¿™é‡Œéœ€è¦æ³¨æ„çš„æ˜¯ shift(1, 1, 1, C) å’Œå½’ä¸€åŒ–åçš„ x(N, H, W, C) ç›¸ä¹˜çš„æ—¶å€™ï¼Œè¿™æ—¶å€™å°±ç”¨åˆ°äº†ä¹‹å‰æ‰€è¯´çš„ VuV_mul å’Œ VuV_mul_loop æŒ‡ä»¤ã€‚</p>
<p>å½“ C &lt;= 32 æ—¶ï¼Œä¸€ä¸ª batch å†…çš„æ•°æ®æ’å¸ƒå¦‚ä¸‹ (ä»¥ (4x112x2x30) x (1x1x1x30) ä¸ºä¾‹)ï¼Œæ­¤æ—¶æˆ‘ä»¬åœ¨ batch ç»´åº¦ä¸Šå¾ªç¯è°ƒç”¨ VuV_mul æŒ‡ä»¤å°±å¯ä»¥ã€‚</p>
<p>
<figure class="post-figure">
    <a href="https://share.note.youdao.com/yws/api/personal/file/WEB7e47cbd16c9c6777c91a22a0c2685f91?method=download&amp;shareKey=c305ac14d29df963a8884def061ef96f" target="_blank" rel="noopener">
        <img loading="lazy" src="https://share.note.youdao.com/yws/api/personal/file/WEB7e47cbd16c9c6777c91a22a0c2685f91?method=download&amp;shareKey=c305ac14d29df963a8884def061ef96f" alt="Channel &lt;= 32">
    </a><figcaption>Channel &lt;= 32</figcaption></figure></p>
<p>å½“ C &gt; 32 æ—¶ï¼Œéœ€è¦å‘ 64 å¯¹é½ï¼Œä¸€ä¸ª batch å†…çš„æ•°æ®æ’å¸ƒå¦‚ä¸‹ (ä»¥ (4x112x2x129) x (1x1x1x129) ä¸ºä¾‹)ï¼Œæ¯ä¸€ä¸ª Cx/C0 å¯¹åº”ç€ä¸€æ¬¡ VuV_mul. æ­¤æ—¶æˆ‘ä»¬åœ¨ batch ç»´åº¦ä¸Šå¾ªç¯è°ƒç”¨ VuV_mul_loop æŒ‡ä»¤å°±å¯ä»¥ã€‚</p>
<p>
<figure class="post-figure">
    <a href="https://share.note.youdao.com/yws/api/personal/file/WEBfacfc3b8b6722744fa958775ab8a88f4?method=download&amp;shareKey=968a25dfbb972d2e97c7b09f284733be" target="_blank" rel="noopener">
        <img loading="lazy" src="https://share.note.youdao.com/yws/api/personal/file/WEBfacfc3b8b6722744fa958775ab8a88f4?method=download&amp;shareKey=968a25dfbb972d2e97c7b09f284733be" alt="Channel &gt; 32">
    </a><figcaption>Channel &gt; 32</figcaption></figure></p>
<p>ä¸‹é¢æ¥è¯´æ˜å¦‚ä½•è°ƒç”¨æŒ‡ä»¤ï¼Œé¦–å…ˆè¦æ˜ç¡®è°ƒç”¨çš„æŒ‡ä»¤æ˜¯å±äºå“ªä¸€ä¸ªæ¨¡å—çš„ã€‚ä¾‹å¦‚ç¬¬å››æ­¥åŠ  epsilon æˆ‘ä»¬éœ€è¦è°ƒç”¨ addVs æŒ‡ä»¤ï¼Œå…¶å±äº CGRA æ¨¡å—ã€‚</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">enum</span> <span class="nc">OP_INSTR_TYPE</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">I_CGRA</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">I_NEUR</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">I_RDMA</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">I_WDMA</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">I_TDMA</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">I_SCALAR</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">I_DTE</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">I_CSR</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">OP_INSTR_TYPE</span><span class="p">;</span>
</span></span></code></pre></div><p>æ¯ä¸ªæ¨¡å—ä¸‹çš„æŒ‡ä»¤æœ‰è‡ªå·±çš„å‚æ•°å½¢å¼ï¼Œä¸‹é¢åˆ—ä¸¾ä¸€äº›ã€‚</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// I_CGRA
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">CT_Param</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint32_t</span> <span class="n">inter_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Ncc_CT_GR_Ctl_Regs</span> <span class="n">ctrl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Ncc_CT_GR_Param_Regs</span> <span class="n">param</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">CT_Param</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// I_NEUR
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">TsmNeInstr</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint32_t</span> <span class="n">inter_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Ncc_NE_GR_Ctl_Regs</span> <span class="n">ctrl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Ncc_NE_GR_Param_Regs</span> <span class="n">param</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">TsmNeInstr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// I_(R/W)DMA
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">DMA_Param</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint32_t</span> <span class="n">inter_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Ncc_DMA_GR_Ctl_Regs</span> <span class="n">ctrl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Ncc_DMA_GR_Param_Regs</span> <span class="n">param</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">DMA_Param</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// I_TDMA
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">TD_Param</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint32_t</span> <span class="n">inter_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Ncc_TDMA_GR_Ctl_Regs</span> <span class="n">ctrl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Ncc_TDMA_GR_Param_Regs</span> <span class="n">param</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">TD_Param</span><span class="p">;</span>
</span></span></code></pre></div><p>è¿˜æ˜¯ä»¥ AddVS æŒ‡ä»¤ä¸ºä¾‹ï¼Œæµç¨‹å¦‚ä¸‹</p>
<ol>
<li>å£°æ˜æ¨¡å—çš„æŒ‡ä»¤å‚æ•°ã€‚</li>
<li>å£°æ˜å¯¹åº”çš„æŒ‡ä»¤ç±»å‹æŒ‡é’ˆï¼ŒAddVS å±äº arith ç±»å‹çš„æŒ‡ä»¤ã€‚getTsmOpPointer()-&gt;arith_pointer;`.</li>
<li>æ ¹æ®è°ƒç”¨æŒ‡ä»¤ä¼ å…¥å‚æ•°ï¼ŒæŒ‡ä»¤ä¼šæ ¹æ®ä¼ å…¥å‚æ•°é…ç½®å¥½ ct_param ä¸Šå¯„å­˜å™¨çš„å€¼ã€‚ç„¶åå†è¿›è¡Œ TsmExecute. æœ€åå†æŠŠå•è¯æŒ‡ä»¤çš„æ‰§è¡Œæ—¶é—´è¿›è¡Œç´¯åŠ ã€‚</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">CT_Param</span> <span class="n">ct_param</span> <span class="o">=</span> <span class="p">{</span><span class="n">I_CGRA</span><span class="p">,</span> <span class="p">{</span><span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="mi">0</span><span class="p">}};</span>  <span class="c1">// step 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">TsmArith</span> <span class="o">*</span><span class="n">arith</span> <span class="o">=</span> <span class="p">(</span><span class="n">TsmArith</span> <span class="o">*</span><span class="p">)</span><span class="n">getTsmOpPointer</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">arith_pointer</span><span class="p">;</span>  <span class="c1">// step 2
</span></span></span><span class="line"><span class="cl"><span class="c1">// variance add epsilon
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">float</span> <span class="n">epsilon</span> <span class="o">=</span> <span class="mf">1e-6</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">arith</span><span class="o">-&gt;</span><span class="n">addVS</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ct_param</span><span class="p">,</span>  <span class="c1">// engine params
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">varAddr</span><span class="p">,</span>  <span class="c1">// vector address
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="o">*</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">epsilon</span><span class="p">),</span>  <span class="c1">// scalar address
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">varAddr</span><span class="p">,</span>  <span class="c1">// result address
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">mid_tensor_info</span><span class="p">.</span><span class="n">total_num</span><span class="p">,</span>  <span class="c1">// vector elements num
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">RND_NEAREST_EVEN</span><span class="p">,</span>  <span class="c1">// round method
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">Fmt_FP32</span><span class="p">);</span>  <span class="c1">// data format
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">cycle_single</span> <span class="o">=</span> <span class="n">TsmExecute</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ct_param</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">cycle_total</span> <span class="o">=</span> <span class="n">ADD_VALID_CYCLE</span><span class="p">(</span><span class="n">cycle_total</span><span class="p">,</span> <span class="n">cycle_single</span><span class="p">);</span>
</span></span></code></pre></div><h2 id="computeinteface">ComputeInteface<a hidden class="anchor" aria-hidden="true" href="#computeinteface">#</a></h2>
<p><code>ComputeInterface</code> è¿™ä¸ªæ¥å£ä¸»è¦æ˜¯æ¯ä¸ª OP é€šè¿‡ onednn å¾—åˆ° CPU ä»£ç ã€‚æˆ–è€…è®¡ç®—æ¯”è¾ƒç®€å•çš„ OP å¦‚æœåœ¨ onednn çš„æ¥å£ä¸­æ²¡æœ‰æ‰¾åˆ°å¯¹åº”çš„è®¡ç®—ï¼Œä¹Ÿå¯ä»¥åœ¨ compute æ¥å£ä¸­æ‰‹å†™å½“å‰ OP çš„ CPU å®ç°çš„ C++ä»£ç ã€‚æœ€ç»ˆç”Ÿæˆç»“æœä¼šç”¨æ¥æ£€éªŒç®—å­æ­£ç¡®æ€§ã€‚</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-mlir" data-lang="mlir"><span class="line"><span class="cl">def ComputeInterface <span class="p">:</span> OpInterface<span class="p">&lt;</span><span class="s">&#34;ComputeInterface&#34;</span><span class="p">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  let <span class="nl">description =</span> <span class="p">[]</span><span class="err">;</span>
</span></span><span class="line"><span class="cl">  let <span class="nl">cppNamespace =</span> <span class="s">&#34;::tx8be_mlir&#34;</span><span class="err">;</span>
</span></span><span class="line"><span class="cl">  let <span class="nl">methods =</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    InterfaceMethod<span class="p">&lt;</span>
</span></span><span class="line"><span class="cl">      <span class="err">/</span><span class="p">*</span><span class="nl">desc=</span><span class="p">*</span><span class="err">/</span><span class="p">[],</span>
</span></span><span class="line"><span class="cl">      <span class="err">/</span><span class="p">*</span><span class="nl">retType=</span><span class="p">*</span><span class="err">/</span><span class="s">&#34;::mlir::LogicalResult&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="err">/</span><span class="p">*</span><span class="nl">methodName=</span><span class="p">*</span><span class="err">/</span><span class="s">&#34;compute&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="err">/</span><span class="p">*</span><span class="nl">args=</span><span class="p">*</span><span class="err">/</span><span class="p">(</span>ins <span class="s">&#34;ComputeParam&amp;&#34;</span><span class="p">:</span><span class="err">$</span>param<span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">&gt;,</span>
</span></span><span class="line"><span class="cl">  <span class="p">]</span><span class="err">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h1 id="test-case">Test Case<a hidden class="anchor" aria-hidden="true" href="#test-case">#</a></h1>
<p>TestCase ä¸»è¦ä½œç”¨æ˜¯å†™å•ç®—å­æˆ–è€…å¤šä¸ª (å•ç®—å­çš„ä¸Šä¸‹æ–‡ç®—å­) çš„æµ‹è¯•ï¼ŒåŒ…æ‹¬å›ºå®šé…ç½®æµ‹è¯•å’Œéšæœºé…ç½®æµ‹è¯•,éšæœºé…ç½®æ—¶ä¸»è¦å¯¹äºç®—å­æ”¯æŒçš„ä¸åŒ dim, layout, dtype, shape è¿™å››é¡¹åšéšæœºã€‚æµç¨‹ä¸»è¦åšä»¥ä¸‹å‡ ä»¶äº‹ã€‚</p>
<p><strong>init_param</strong></p>
<p>é€šè¿‡æ•°ç»„æ¥é…ç½®å›ºå®šæµ‹è¯• case æˆ–è€…éšæœºæµ‹è¯•èŒƒå›´ï¼Œç„¶åé€šè¿‡æŒ‡å®šæˆ–éšæœºçš„æ–¹å¼ç”Ÿæˆå¯¹åº”çš„è¾“å…¥ï¼Œè¾“å‡ºçš„ shapeï¼Œ dim ä¿¡æ¯ï¼Œé™¤æ­¤ä¹‹å¤–å‚ä¸éšæœºçš„ä¸€èˆ¬è¿˜åŒ…æ‹¬æ•°æ®å¯¹é½æ–¹å¼éšæœºï¼Œæ•°æ®ç±»å‹éšæœºï¼Œå³åœ¨ç®—å­å¯æ”¯æŒçš„èŒƒå›´å†…äº§ç”Ÿéšæœºçš„ FP16/FP32 ä¸åŒçš„æ•°æ®ç±»å‹æ¥ä¿è¯æµ‹è¯•çš„å……åˆ†å’Œå…¨é¢ã€‚</p>
<p>é™¤æ­¤ä¹‹å¤–è¿˜ä¼šç”Ÿæˆ MLIR Module. è¿™ä¸ª module æ˜¯åŸæ¥å°±ç»™å®šçš„ï¼Œåœ¨è¿™é‡Œåšçš„äº‹æƒ…æ˜¯é¦–å…ˆæ–°å»ºä¸€ä¸ªç©ºçš„ func. ç„¶ååœ¨è¿™ä¸ª func ä¸­æ„é€ ä¸€ä¸ª blockï¼Œé‡Œé¢å»å¡«å…¥éœ€è¦æµ‹è¯•çš„è¿™äº› OP çš„ç»“æ„ã€‚</p>
<ul>
<li>Moduleï¼šä¸€ä¸ªç¨‹åºçš„å®¹å™¨ï¼ŒåŒ…å«å¤šä¸ªå‡½æ•°ã€‚</li>
<li>Funcï¼šå®šä¹‰ä¸€ä¸ªå‡½æ•°ï¼ŒåŒ…å«å¤šä¸ª Block.</li>
<li>Blockï¼šå®šä¹‰å‡½æ•°çš„åŸºæœ¬æ‰§è¡Œå•å…ƒï¼ŒåŒ…å«å¤šä¸ª Operation.</li>
<li>Operationï¼šè¡¨ç¤ºå…·ä½“çš„è®¡ç®—æˆ–æ“ä½œï¼Œæ˜¯ç¨‹åºä¸­çš„åŸºæœ¬æŒ‡ä»¤ã€‚</li>
</ul>
<h2 id="mlir-structure">
<figure class="post-figure">
    <a href="https://share.note.youdao.com/yws/api/personal/file/WEBfdb91efc229999a9b488d5131959f4b0?method=download&amp;shareKey=a3935de13b565d4c37e06857c6c43f90" target="_blank" rel="noopener">
        <img loading="lazy" src="https://share.note.youdao.com/yws/api/personal/file/WEBfdb91efc229999a9b488d5131959f4b0?method=download&amp;shareKey=a3935de13b565d4c37e06857c6c43f90" alt="MLIR Structure">
    </a><figcaption>MLIR Structure</figcaption></figure></h2>
<p>init_data</p>
<p>è¿™ä¸ªæ–¹æ³•ä¸»è¦ç”¨æ¥é€šè¿‡ä¸Šé¢ Param ç”Ÿæˆçš„ dimã€è¾“å…¥æˆ–è€…è¾“å‡º shapeã€æ•°æ®ç±»å‹æ¥ç”Ÿæˆéšæœºçš„æ•°æ®ï¼Œæ•°æ®èŒƒå›´ä¸€å®šè¦æ ¹æ®ç®—å­æƒ…å†µé…ç½®ï¼Œä¸ç„¶æ— æ•ˆæ•°å€¼å¯èƒ½ä¼šåœ¨ç»“æœä¸­å‡ºç° Nan. è¿˜è¦è€ƒè™‘ä¸€äº›ç®—å­çš„ç‰¹ç‚¹ï¼Œä¿è¯æµ‹è¯•çš„å……åˆ†æ€§ï¼Œä¾‹å¦‚åˆ›å»º relu çš„æ•°æ®æ—¶ï¼Œæœ€å¥½æ­£è´Ÿå€¼éƒ½æœ‰è¦†ç›–ã€‚</p>
<hr>
<p>compile</p>
<p>compile æ–¹æ³•æœ‰ä¸¤ä¸ªåŠŸèƒ½</p>
<ol>
<li>è°ƒç”¨ Computelnterface ç”Ÿæˆ onednn æˆ–è€…æ‰‹å†™ CPU ç®—å­å®ç°çš„ç»“æœã€‚</li>
<li>æ·»åŠ ä¸€äº›é…ç½®å‚æ•°ï¼Œè·‘å‡º tx8be mlir codegen çš„ç»“æœã€‚è¿™å…¶ä¸­ä¼šç»å†ä¸€äº›éå¸¸å¤æ‚çš„ passï¼Œç¨åå†ä»‹ç»ã€‚</li>
</ol>
<hr>
<p>saveInfoFile</p>
<p>saveInfoFile æ–¹æ³•ä¸»è¦æ˜¯æŠŠåˆ›å»ºå‡ºçš„ Data æ•°æ®å†™æˆ.bin æ–‡ä»¶ä¿å­˜ã€‚å¹¶æŠŠåˆ›å»ºå‡ºçš„ module çš„ä¿¡æ¯ä¿å­˜åœ¨ json æ–‡ä»¶ã€‚</p>
<h1 id="overview-of-workflow">Overview of Workflow<a hidden class="anchor" aria-hidden="true" href="#overview-of-workflow">#</a></h1>
<p>åç«¯æ¥æ”¶çš„æ˜¯ MLIR çš„è®¡ç®—å›¾ï¼Œç„¶åç»è¿‡ç¼–è¯‘å™¨åç«¯çš„å¤„ç†ï¼Œç„¶åç”Ÿæˆæœ€åçš„ BE IRï¼Œå…¶ä¸­ä¸­åŒ…å«äº†ä¸€äº› Oplib çš„ç®—å­ã€‚æœ€ç»ˆè¿™ä¸ª BEIR ä¼šè°ƒç”¨ OP çš„ç®—å­ï¼Œç„¶åå»è·‘åœ¨ C model æˆ–è€…æ˜¯å®é™…çš„ç¡¬ä»¶èŠ¯ç‰‡ä¸Šé¢ã€‚åç«¯ç¼–è¯‘å™¨ä¸»è¦è´Ÿè´£å››ä¸ªæ–¹é¢
layout åˆå§‹åŒ–å’Œä¼ é€’ã€const ç®¡ç†ã€åˆ‡åˆ†ç­–ç•¥åŠå…¶ SPM åˆ†é…å’Œ DDR åˆ†é…ã€‚</p>
<h1 id="layout-initialization-and-pass">Layout Initialization and Pass.<a hidden class="anchor" aria-hidden="true" href="#layout-initialization-and-pass">#</a></h1>
<p>layout å¯ä»¥åˆ†ä¸ºä»¥ä¸‹å‡ ç§</p>
<ul>
<li>layout_str: ä¸­ç«¯ä½¿ç”¨
<ul>
<li>CNN Op: 1. Feature (NCHW/NHWC) etc. 2. Weight (OIHW/HWOI) etc.</li>
<li>Non-CNN Op: å¤§æ¨¡å‹ä¸­å¸¸è§ï¼ŒTensor/NTensorï¼Œå®ƒä»¬çš„åŒºåˆ«æ˜¯ç¬¬ 0 ç»´æ˜¯å¦ä¸º 1.</li>
</ul>
</li>
<li>mem_layout: åç«¯ä½¿ç”¨ï¼Œä»£è¡¨äº†åœ¨èŠ¯ç‰‡ä¸Šçš„å®é™…æ’å¸ƒ
<ul>
<li>Tensor/NTensor: æ•°æ®çš„ç´§å¯†æ’å¸ƒ</li>
<li>Cx/NCx: å¯¹ Tensor/NTensor æ ¼å¼åŒ–åçš„ç»“æœï¼Œæ–¹ä¾¿æ˜“ç¡¬ä»¶è¯»å–ã€‚</li>
</ul>
</li>
</ul>
<table>
  <thead>
      <tr>
          <th>dtype</th>
          <th>channel</th>
          <th>description</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>bf16/fp16 <br>/fp32/tf32</td>
          <td>c &lt;= 32</td>
          <td>NHWC, Cå‘4/8/16/32å¯¹é½ï¼ŒN çš„èµ·å§‹åœ°å€å‘ 2048bit å¯¹é½</td>
      </tr>
      <tr>
          <td></td>
          <td>c &gt; 32</td>
          <td>N[CxHW64, HWC0], C0 å‘ 4/8/16/32 å¯¹é½ï¼ŒN çš„èµ·å§‹åœ°å€å‘2048bit å¯¹é½<br>åœ¨ä¸€ä¸ª batch å†…å°† tensor æŒ‰ C åˆ†æˆ Cx*64 å’Œ C0ä¸¤éƒ¨åˆ†</td>
      </tr>
      <tr>
          <td>int8</td>
          <td>c &lt;= 64</td>
          <td>NHWC, C å‘ 4/8/16/32/64å¯¹é½ï¼ŒNçš„èµ·å§‹åœ°å€å‘2048bitå¯¹é½</td>
      </tr>
      <tr>
          <td></td>
          <td>c &gt; 64</td>
          <td>N[CxHW128, HWC0], C0 å‘ 4/8/16/32/64 å¯¹é½ï¼ŒNçš„èµ·å§‹åœ°å€å‘ 2048bit å¯¹é½ <br> åœ¨ä¸€ä¸ª batch å†…å°† tensor æŒ‰ C åˆ†æˆ Cx*128 å’ŒC0 ä¸¤éƒ¨åˆ†</td>
      </tr>
  </tbody>
</table>
<h2 id="layoutinitpass">layoutInitPass<a hidden class="anchor" aria-hidden="true" href="#layoutinitpass">#</a></h2>
<p>layoutInitPass ç”¨äºåˆå§‹åŒ–è®¡ç®—å›¾ä¸­ GemmOP å’Œ ConvOP çš„ layout_strï¼Œå…¶ä»–çš„æ‰€æœ‰ç®—å­ layout_str éƒ½è®¾ç½®ä¸º UNKNOWN. ä¸‹å›¾ä¸­çš„ <code>GemmOP layout_str = &quot;Tensor-Tensor-Tensor&quot;</code> åˆ†åˆ«è¡¨ç¤ºä¸¤ä¸ªè¾“å…¥å’Œè¾“å‡ºçš„æ•°æ®æ’å¸ƒã€‚</p>
<p>
<figure class="post-figure">
    <a href="https://share.note.youdao.com/yws/api/personal/file/WEB95a6e97d5ae8432b8367189a36987f31?method=download&amp;shareKey=8df50a04c4e2ed29be9e93d3da958e35" target="_blank" rel="noopener">
        <img loading="lazy" src="https://share.note.youdao.com/yws/api/personal/file/WEB95a6e97d5ae8432b8367189a36987f31?method=download&amp;shareKey=8df50a04c4e2ed29be9e93d3da958e35" alt="LayoutStr">
    </a><figcaption>LayoutStr</figcaption></figure></p>
<h2 id="layouttransmitpass">layoutTransmitPass<a hidden class="anchor" aria-hidden="true" href="#layouttransmitpass">#</a></h2>
<p>layoutTransmitPass ä¼šç”¨å·²çŸ¥çš„ GemmOP å’Œ ConvOP layout ä¿¡æ¯è¿›è¡Œæ‰©æ•£ï¼Œå¾—åˆ°å…¨å›¾çš„ layout_str.</p>
<ol>
<li>æ¯ä¸ªç®—å­åˆå§‹åŒ–ä¸ºä¸€ä¸ªèŠ‚ç‚¹ï¼Œæœ‰inputNodeså®¹å™¨å’ŒoutputNodeså®¹å™¨åˆ†åˆ«å­˜æ”¾è‡ªå·±çš„è¾“å…¥å’Œè¾“å‡ºèŠ‚ç‚¹ã€‚</li>
<li>GemmOp å’Œ ConvOp ä½œä¸ºèµ·å§‹èŠ‚ç‚¹ï¼Œå‘å‰å’Œå‘åæ¨å¯¼ layout (ç®—å­çš„ <code>inferlayout()</code> æ¥å£)ï¼Œæ–°æ¨å‡ºlayout çš„èŠ‚ç‚¹ä½œä¸ºä¸‹ä¸€æ‰¹èµ·å§‹èŠ‚ç‚¹é€’å½’æ¨å¯¼ã€‚</li>
<li>é‡åˆ°æ— æ³•æ¨å¯¼çš„èŠ‚ç‚¹ (å¦‚ Reshapeï¼ŒBroadCast) åˆ™ç»ˆæ­¢æ¨å¯¼ã€‚å°†å…¶ä½™æ— æ³•æ¨å¯¼çš„èŠ‚ç‚¹ layout ç›´æ¥åˆå§‹åŒ–ä¸º Tensor.</li>
</ol>
<p>
<figure class="post-figure">
    <a href="https://share.note.youdao.com/yws/api/personal/file/WEB9d187e7b17a4b2ee65f01169f8c6a141?method=download&amp;shareKey=c405975eba9c1da95539f89ac8b3de8a" target="_blank" rel="noopener">
        <img loading="lazy" src="https://share.note.youdao.com/yws/api/personal/file/WEB9d187e7b17a4b2ee65f01169f8c6a141?method=download&amp;shareKey=c405975eba9c1da95539f89ac8b3de8a" alt="layoutTransmitPass">
    </a><figcaption>layoutTransmitPass</figcaption></figure></p>
<h2 id="layoutaligntonpupass">layoutAlignToNpuPass<a hidden class="anchor" aria-hidden="true" href="#layoutaligntonpupass">#</a></h2>
<p>layoutAlignToNpuPass ç”¨äºåœ¨æ•°æ®å¯¹é½å†²çªçš„åœ°æ–¹æ’å…¥ channelNormï¼Œå¹¶å°† layout_str æ˜ å°„åˆ° mem_layout. åœ¨ NPU ä¸ŠæŸäº›ç®—å­åªæ”¯æŒ <code>COMPACT</code> layoutï¼Œæœ‰äº›åªæ”¯æŒ <code>ALIGN</code> layoutï¼Œæœ‰äº›åˆ™éƒ½å¯ä»¥ <code>BOTH</code>.</p>
<ol>
<li>è¾“å…¥é»˜è®¤éå¯¹é½æ’å¸ƒï¼Œä»è¾“å…¥å‡ºå‘éå†æ•´å›¾ï¼Œæ£€æŸ¥å½“å‰ç®—å­ä¸å…¶æ‰€æœ‰ user ä¹‹é—´çš„å¯¹é½è¦æ±‚ï¼Œè‹¥å†²çªï¼Œè®°å½•æ’å…¥ç‚¹ (ç®—å­çš„å¯¹é½è¦æ±‚å¯ä»¥åœ¨ <code>OpLibInterface</code> æ¥å£ä¸­çš„ <code>queryOpAttr()</code> æ–¹æ³•ä¸­æŸ¥è¯¢åˆ°).</li>
<li>æ ¹æ®è®°å½•çš„æ’å…¥ç‚¹ï¼Œå†æ¬¡åˆ†ææ’å…¥ç‚¹å‰åçš„ç®—å­å¯¹é½è¦æ±‚ï¼Œä»¥ç¡®å®šchannelnormçš„æ–¹å‘ï¼Œæ’å…¥ channelnorm.</li>
<li>èµ‹å€¼ <code>dev_info</code>ï¼Œå°† <code>layout_str</code> æ˜ å°„åˆ° <code>mem_layout</code>.</li>
</ol>
<blockquote>
<p>dev_infoç”¨æ¥æè¿°æ•°æ®åœ¨è®¾å¤‡ä¸Šçš„ä¸€äº›å±æ€§ï¼Œæœ‰æˆå‘˜ï¼šimm_size (è¾…åŠ©ç©ºé—´å¤§å°), mem_layout, temporal_mem_slice, imm_addr, mem_addr.</p></blockquote>
<p>
<figure class="post-figure">
    <a href="https://share.note.youdao.com/yws/api/personal/file/WEB41f3c705e0f54e9291a5a2a7916f6045?method=download&amp;shareKey=e9af8cbf6c2e348e4584018bcb4d4782" target="_blank" rel="noopener">
        <img loading="lazy" src="https://share.note.youdao.com/yws/api/personal/file/WEB41f3c705e0f54e9291a5a2a7916f6045?method=download&amp;shareKey=e9af8cbf6c2e348e4584018bcb4d4782" alt="layoutAlignToNpuPass">
    </a><figcaption>layoutAlignToNpuPass</figcaption></figure></p>
<p>LayoutAlignOptPass åº”ç”¨å‡ ä¸ª RewritePattern ç”¨äºåˆ é™¤å†—ä½™çš„ channelnorm.</p>
<ol>
<li><strong>ConstChannelNormErase</strong>: ConstantOp ç»´åº¦ä¸º 1 å¹¶ä¸”åªæœ‰ 1 ä¸ª user çš„æ—¶å€™å¯ä»¥åˆ å»å¹¶ä¸”å°† devInfolayout è®¾ç½®ä¸º Cx.</li>
</ol>
<details class="custom-details">
    <summary class="custom-summary">ConstChannelNormErase Implementation</summary>
    <div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// const can be directly considered to be aligned
</span></span></span><span class="line"><span class="cl"><span class="c1">// constop(dim &lt; 2) -&gt; channelNorm -&gt; constop
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">ConstChannelNormErase</span> <span class="o">:</span> <span class="k">public</span> <span class="n">mlir</span><span class="o">::</span><span class="n">OpRewritePattern</span><span class="o">&lt;</span><span class="n">txbe</span><span class="o">::</span><span class="n">ConstantOp</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">ConstChannelNormErase</span><span class="p">(</span><span class="n">mlir</span><span class="o">::</span><span class="n">MLIRContext</span> <span class="o">*</span><span class="n">context</span><span class="p">,</span> <span class="cm">/*benefit=*/</span><span class="mi">1</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">mlir</span><span class="o">::</span><span class="n">LogicalResult</span> <span class="n">matchAndRewrite</span><span class="p">(</span><span class="n">txbe</span><span class="o">::</span><span class="n">ConstantOp</span> <span class="n">op</span><span class="p">,</span> <span class="n">mlir</span><span class="o">::</span><span class="n">PatternRewriter</span> <span class="o">&amp;</span><span class="n">rewriter</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// If const has multi user, can not erase
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">hasOneUse</span><span class="p">())</span> <span class="k">return</span> <span class="n">mlir</span><span class="o">::</span><span class="n">failure</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">user</span> <span class="o">=</span> <span class="o">*</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">getUsers</span><span class="p">().</span><span class="n">begin</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isa</span><span class="o">&lt;</span><span class="n">txbe</span><span class="o">::</span><span class="n">ChannelNormOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">user</span><span class="p">))</span> <span class="k">return</span> <span class="n">mlir</span><span class="o">::</span><span class="n">failure</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">shape</span> <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">getResult</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">getType</span><span class="p">().</span><span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">mlir</span><span class="o">::</span><span class="n">ShapedType</span><span class="o">&gt;</span><span class="p">().</span><span class="n">getShape</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">shape</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="n">mlir</span><span class="o">::</span><span class="n">failure</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">llvm</span><span class="o">::</span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">Operation</span><span class="o">*&gt;</span> <span class="n">userVec</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">userVec</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">userVec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">user</span><span class="o">-&gt;</span><span class="n">getUsers</span><span class="p">().</span><span class="n">begin</span><span class="p">(),</span> <span class="n">user</span><span class="o">-&gt;</span><span class="n">getUsers</span><span class="p">().</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">channelNormUser</span> <span class="p">:</span> <span class="n">userVec</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">channelNormUser</span><span class="o">-&gt;</span><span class="n">replaceUsesOfWith</span><span class="p">(</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">getResult</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">getResult</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// set align=true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">setDevInfoWithLayout</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">getContext</span><span class="p">(),</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">getLayoutStr</span><span class="p">().</span><span class="n">str</span><span class="p">(),</span> <span class="nb">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">user</span><span class="o">-&gt;</span><span class="n">use_empty</span><span class="p">())</span> <span class="n">rewriter</span><span class="p">.</span><span class="n">eraseOp</span><span class="p">(</span><span class="n">user</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">success</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div></div>
</details><br>
<details class="custom-details">
    <summary class="custom-summary">RedudantChannelnormErase Implementation</summary>
    <div><ol start="2">
<li><strong>RedudantChannelnormErase</strong>: å¦‚æœè¯¥ channelnormOp çš„è¾“å…¥æ˜¯æ¥è‡ªä¸€ä¸ª constOp å¹¶ä¸”åªæœ‰ä¸€ä¸ªè¾“å‡ºï¼Œåˆ™æ£€æŸ¥æ˜¯å¦è¿˜æœ‰å…¶ä»–çš„ channelnormOp ä¹Ÿä½¿ç”¨ã€‚å¦‚æœæ˜¯ï¼Œåˆ™è®©å®ƒä»¬ç›´æ¥ä½¿ç”¨è¯¥ channelnormOp çš„ç»“æœï¼Œä»¥æ¶ˆé™¤å¤šä½™çš„ channelnormOp.</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// A pass to erase redundant channel normalization operations
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">RedundantChannelNormErase</span> <span class="o">:</span> <span class="k">public</span> <span class="n">mlir</span><span class="o">::</span><span class="n">OpRewritePattern</span><span class="o">&lt;</span><span class="n">tx8be</span><span class="o">::</span><span class="n">ChannelNormOp</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">RedundantChannelNormErase</span><span class="p">(</span><span class="n">mlir</span><span class="o">::</span><span class="n">MLIRContext</span> <span class="o">*</span><span class="n">context</span><span class="p">)</span> <span class="o">:</span> <span class="n">OpRewritePattern</span><span class="o">&lt;</span><span class="n">tx8be</span><span class="o">::</span><span class="n">ChannelNormOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="cm">/*benefit=*/</span><span class="mi">1</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">mlir</span><span class="o">::</span><span class="n">LogicalResult</span> <span class="n">matchAndRewrite</span><span class="p">(</span><span class="n">tx8be</span><span class="o">::</span><span class="n">ChannelNormOp</span> <span class="n">op</span><span class="p">,</span> <span class="n">mlir</span><span class="o">::</span><span class="n">PatternRewriter</span> <span class="o">&amp;</span><span class="n">rewriter</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Define the input operation and its defining operation
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// def represents the operation that generates the op input data
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">auto</span> <span class="n">def</span> <span class="o">=</span> <span class="n">op</span><span class="p">.</span><span class="n">getInput</span><span class="p">().</span><span class="n">getDefiningOp</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Check if the defining operation is a ConstantOp and has more than one result
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">isa</span><span class="o">&lt;</span><span class="n">tx8be</span><span class="o">::</span><span class="n">ConstantOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">def</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">def</span><span class="o">-&gt;</span><span class="n">getNumResults</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">mlir</span><span class="o">::</span><span class="n">failure</span><span class="p">();</span> <span class="c1">// Fail if conditions are not met
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Get the size in bits of the input shape
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">auto</span> <span class="n">size</span> <span class="o">=</span> <span class="n">op</span><span class="p">.</span><span class="n">getInput</span><span class="p">().</span><span class="n">getType</span><span class="p">().</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">ShapedType</span><span class="o">&gt;</span><span class="p">().</span><span class="n">getSizeInBits</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">Operation</span> <span class="o">*</span><span class="n">sameOp</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span> <span class="c1">// Pointer to a potentially redundant operation
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Iterate over all users of the defining operation
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">user</span> <span class="p">:</span> <span class="n">def</span><span class="o">-&gt;</span><span class="n">getUsers</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">user</span> <span class="o">==</span> <span class="n">op</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Skip if the user is the current operation
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">isa</span><span class="o">&lt;</span><span class="n">tx8be</span><span class="o">::</span><span class="n">ChannelNormOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">user</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// Check if the user is another ChannelNormOp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">sameOp</span> <span class="o">=</span> <span class="n">user</span><span class="p">;</span> <span class="c1">// Store the redundant operation
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sameOp</span><span class="p">)</span> <span class="k">return</span> <span class="n">mlir</span><span class="o">::</span><span class="n">failure</span><span class="p">();</span> <span class="c1">// Fail if no redundant operation is found
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Replace all uses of the redundant operation with the current operation&#39;s results
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">op</span><span class="o">-&gt;</span><span class="n">replaceAllUsesWith</span><span class="p">(</span><span class="n">sameOp</span><span class="o">-&gt;</span><span class="n">getOpResults</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">use_empty</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// Erase the current operation if it has no more uses
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">rewriter</span><span class="p">.</span><span class="n">eraseOp</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">success</span><span class="p">();</span> <span class="c1">// Return success if the rewrite is completed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div></div>
</details><br>
<h1 id="const-management">Const Management<a hidden class="anchor" aria-hidden="true" href="#const-management">#</a></h1>
<p>å¸¸é‡ç»Ÿä¸€ä½¿ç”¨ <code>ConstContainer</code> ç±»æ¥è¿›è¡Œç®¡ç†ã€‚é€šè¿‡ map æ¥è®°å½•æ¯ä¸ªå¸¸é‡å¯¹åº”çš„ ParamInfo. ä¸€ä¸ªå¸¸é‡å¯èƒ½è¢«åˆ†é…åˆ°å¤šä¸ªèŠ¯ç‰‡ä¸Šï¼Œæ¯ä¸ªèŠ¯ç‰‡ä¸Šæ•°æ®å¯èƒ½ç›¸åŒï¼Œä¹Ÿå¯èƒ½ä¸åŒã€‚</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">ParamInfo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;*</span> <span class="n">data_ptr</span><span class="p">;</span>  <span class="c1">// const value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="kt">int32_t</span><span class="o">&gt;</span> <span class="n">chip_id</span><span class="p">;</span>  <span class="c1">// which chips has this const, -1 indicates all chip has the same param.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">uint32_t</span> <span class="n">label</span><span class="p">;</span>  <span class="c1">// Indicates whether the data is assigned to a certain chip_id. 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// class ConstContainer {
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">ConstContainer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">ConstContainer</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">ConstContainer</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// some public functions
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ParamInfo</span><span class="o">&gt;&gt;</span> <span class="n">_data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int32_t</span><span class="p">,</span> <span class="kt">uint64_t</span><span class="o">&gt;&gt;</span> <span class="n">oidToSize</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="n">oidToNid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="moveconstantpass">MoveConstantPass<a hidden class="anchor" aria-hidden="true" href="#moveconstantpass">#</a></h2>
<p>MoveConstantPass: åˆ›å»ºå›¾çš„ <code>ConstContainer</code>ï¼Œç„¶ååº”ç”¨ <code>ConstantToLoadConst</code> Rewrite Pattern. è½¬æ¢å®Œæˆåä¼šè°ƒç”¨ <code>updateConstContainer</code> æ›´æ–° <code>ConstContainer</code> å„ä¸ª const çš„ ID. ç”¨ä¸€ä¸ªå¤§å°ä¸º <code>4*1024*tile_num</code> (DDR_BANK_SIZE) <code>thresholdSize</code> å°†å¤§äºè¿™ä¸ªå€¼çš„ const å…¨éƒ¨æ”¾åœ¨å‰é¢ï¼Œå°çš„æ”¾åœ¨åé¢ã€‚</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">MoveConstantPass</span><span class="o">::</span><span class="n">runOnOperation</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// create constant container
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">createConstContainer</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// get module op
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">ModuleOp</span> <span class="n">module</span> <span class="o">=</span> <span class="n">getOperation</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Set pattern
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">MLIRContext</span> <span class="o">*</span><span class="n">context</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">getContext</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">RewritePatternSet</span> <span class="nf">patterns</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">patterns</span><span class="p">.</span><span class="n">insert</span><span class="o">&lt;</span><span class="n">ConstantToLoadConst</span><span class="o">&gt;</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="n">FrozenRewritePatternSet</span> <span class="n">frozen_patterns</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="n">FrozenRewritePatternSet</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">patterns</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Set config
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">GreedyRewriteConfig</span> <span class="n">config</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">config</span><span class="p">.</span><span class="n">useTopDownTraversal</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">func</span> <span class="p">:</span> <span class="n">module</span><span class="p">.</span><span class="n">getOps</span><span class="o">&lt;</span><span class="n">func</span><span class="o">::</span><span class="n">FuncOp</span><span class="o">&gt;</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Region</span> <span class="o">&amp;</span><span class="n">body</span> <span class="o">=</span> <span class="n">func</span><span class="p">.</span><span class="n">getBody</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">failed</span><span class="p">(</span><span class="n">applyPatternsAndFoldGreedily</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="n">frozen_patterns</span><span class="p">,</span> <span class="n">config</span><span class="p">)))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">llvm</span><span class="o">::</span><span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Failed when move const in main graph.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">signalPassFailure</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">subgraph</span> <span class="p">:</span> <span class="n">module</span><span class="p">.</span><span class="n">getOps</span><span class="o">&lt;</span><span class="n">tx8be</span><span class="o">::</span><span class="n">SubgraphOp</span><span class="o">&gt;</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Region</span> <span class="o">&amp;</span><span class="n">body</span> <span class="o">=</span> <span class="n">subgraph</span><span class="p">.</span><span class="n">getBody</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">failed</span><span class="p">(</span><span class="n">applyPatternsAndFoldGreedily</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="n">frozen_patterns</span><span class="p">,</span> <span class="n">config</span><span class="p">)))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">llvm</span><span class="o">::</span><span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Failed when move const in subgraph.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">signalPassFailure</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">TileInfo</span> <span class="n">tinfo</span> <span class="o">=</span> <span class="n">get_tileinfo</span><span class="p">(</span><span class="n">module</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">updateConstContainer</span><span class="p">(</span><span class="n">tinfo</span><span class="p">.</span><span class="n">tile_num</span><span class="p">);</span>  <span class="c1">// update id by thresholdSize
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">updateLdConstop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>ConstantToLoadConst</code> é¦–å…ˆé€šè¿‡åˆ†æè¯¥å¸¸é‡çš„æ‰€æœ‰ usersï¼Œæ¥åˆ¤æ–­è¿™ä¸ªå¸¸é‡æ˜¯å¦éœ€è¦ LoadConstOp. å¦‚æœéœ€è¦åŠ è½½ï¼Œå®ƒä¼šå°†åŸå§‹å¸¸é‡çš„æ•°æ®æ³¨å†Œåˆ°ä¸€ä¸ªå…¨å±€å®¹å™¨ä¸­å¹¶è·å¾—ä¸€ä¸ª IDï¼Œç„¶ååˆ›å»ºä¸€ä¸ªæ–°çš„ LoadConstOp ï¼Œå¹¶å°†æ­¤ ID åŠå…¶ä»–ç¡¬ä»¶å±æ€§èµ‹äºˆå®ƒã€‚æ¥ç€ï¼Œå®ƒä¼šæ›´æ–°æ‰€æœ‰ä½¿ç”¨è€…ï¼Œå°†å®ƒä»¬çš„è¾“å…¥ä»æ—§çš„ ConstantOp é‡å®šå‘åˆ°è¿™ä¸ªæ–°çš„ LoadConstOpï¼Œæœ€åå†åˆ é™¤æ— ç”¨çš„åŸå§‹å¸¸é‡ã€‚æœ€åå†æ›´æ–°æ‰€æœ‰ const çš„ ID.</p>
<details class="custom-details">
    <summary class="custom-summary">ConstantToLoadConst Implementation</summary>
    <div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">ConstantToLoadConst</span> <span class="o">:</span> <span class="k">public</span> <span class="n">mlir</span><span class="o">::</span><span class="n">OpRewritePattern</span><span class="o">&lt;</span><span class="n">tx8be</span><span class="o">::</span><span class="n">ConstantOp</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">ConstantToLoadConst</span><span class="p">(</span><span class="n">mlir</span><span class="o">::</span><span class="n">MLIRContext</span> <span class="o">*</span><span class="n">context</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="o">:</span> <span class="n">OpRewritePattern</span><span class="o">&lt;</span><span class="n">tx8be</span><span class="o">::</span><span class="n">ConstantOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="cm">/*benefit=*/</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">mlir</span><span class="o">::</span><span class="n">LogicalResult</span>
</span></span><span class="line"><span class="cl">  <span class="n">matchAndRewrite</span><span class="p">(</span><span class="n">tx8be</span><span class="o">::</span><span class="n">ConstantOp</span> <span class="n">op</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                  <span class="n">mlir</span><span class="o">::</span><span class="n">PatternRewriter</span> <span class="o">&amp;</span><span class="n">rewriter</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint32_t</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Store constant data to constant container 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Determine if this constant operation needs an explicit load instruction.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">bool</span> <span class="n">needLoad</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">v</span> <span class="o">=</span> <span class="n">op</span><span class="p">.</span><span class="n">getOutput</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Iterate over all operations that use this output value.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">user_op</span> <span class="p">:</span> <span class="n">v</span><span class="p">.</span><span class="n">getUsers</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Get the argument index of the user op that corresponds to our output value.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int32_t</span> <span class="n">arg_idx</span> <span class="o">=</span> <span class="n">getArgumentIdx</span><span class="p">(</span><span class="n">user_op</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Assert that the user operation implements our custom OpLibInterface.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">ASSERT</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">tx8be</span><span class="o">::</span><span class="n">OpLibInterface</span><span class="o">&gt;</span><span class="p">(</span><span class="n">user_op</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Get the library attributes for this user operation.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">auto</span> <span class="n">opAttr</span> <span class="o">=</span> <span class="n">llvm</span><span class="o">::</span><span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">tx8be</span><span class="o">::</span><span class="n">OpLibInterface</span><span class="o">&gt;</span><span class="p">(</span><span class="n">user_op</span><span class="p">).</span><span class="n">queryOpAttr</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Skip if the user is a TupleOp, which might have special handling.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">isa</span><span class="o">&lt;</span><span class="n">tx8be</span><span class="o">::</span><span class="n">TupleOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">user_op</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">opAttr</span><span class="p">.</span><span class="n">needLoad</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">arg_idx</span><span class="p">))</span> <span class="p">{</span>  <span class="c1">// Check if the &#39;needLoad&#39; attribute
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">needLoad</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">ASSERT</span><span class="p">(</span><span class="n">needLoad</span> <span class="o">==</span> <span class="nb">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Set attributes
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Safely iterate over the users. This is important because we are modifying the use-list inside the loop.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">use</span> <span class="p">:</span> <span class="n">llvm</span><span class="o">::</span><span class="n">make_early_inc_range</span><span class="p">(</span><span class="n">op</span><span class="p">.</span><span class="n">getOutput</span><span class="p">().</span><span class="n">getUses</span><span class="p">()))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Operation</span> <span class="o">*</span><span class="n">userOp</span> <span class="o">=</span> <span class="n">use</span><span class="p">.</span><span class="n">getOwner</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Create the new, hardware-specific LoadConst operation.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">txbe</span><span class="o">::</span><span class="n">LoadConstOp</span> <span class="n">newLoadConst</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">            <span class="n">rewriter</span><span class="p">.</span><span class="n">create</span><span class="o">&lt;</span><span class="n">txbe</span><span class="o">::</span><span class="n">LoadConstOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">op</span><span class="p">.</span><span class="n">getLoc</span><span class="p">(),</span> <span class="n">op</span><span class="p">.</span><span class="n">getOutput</span><span class="p">().</span><span class="n">getType</span><span class="p">(),</span> <span class="n">ValueRange</span><span class="p">{},</span> <span class="n">attrs</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">needLoad</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// this constant does not need an explicit load... 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// Get a builder to set attributes.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">OpBuilder</span> <span class="nf">builder</span><span class="p">(</span><span class="n">newLoadConst</span><span class="p">.</span><span class="n">getContext</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// Set a &#39;bypasscodegen&#39; attribute, signaling special handling for this op in later stages.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">newLoadConst</span><span class="p">.</span><span class="n">getOperation</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">setAttr</span><span class="p">(</span><span class="s">&#34;bypasscodegen&#34;</span><span class="p">,</span> <span class="n">builder</span><span class="p">.</span><span class="n">getBoolAttr</span><span class="p">(</span><span class="nb">true</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Set the layout string attribute on the new LoadConst op.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">newLoadConst</span><span class="o">-&gt;</span><span class="n">setAttr</span><span class="p">(</span><span class="s">&#34;layout_str&#34;</span><span class="p">,</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">getAttr</span><span class="p">(</span><span class="s">&#34;layout_str&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// CRITICAL STEP: Rewire the user&#39;s operand to point to the result of the new LoadConst op.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">userOp</span><span class="o">-&gt;</span><span class="n">setOperand</span><span class="p">(</span><span class="n">use</span><span class="p">.</span><span class="n">getOperandNumber</span><span class="p">(),</span> <span class="n">newLoadConst</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// After all uses have been replaced, erase the original, now-dead ConstantOp.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">rewriter</span><span class="p">.</span><span class="n">eraseOp</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">success</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></div>
</details><br>
<h2 id="constnormpass">constNormPass<a hidden class="anchor" aria-hidden="true" href="#constnormpass">#</a></h2>
<p>constNormPass: éå†å›¾ä¸­çš„ LoadConstOp. å®ƒä¼šå¯»æ‰¾ä¸€ä¸ªç‰¹å®šçš„æ¨¡å¼ï¼šå¦‚æœä¸€ä¸ª LoadConstOp çš„å”¯ä¸€ user æ˜¯ä¸€ä¸ª ChannelNormOpï¼Œé‚£ä¹ˆä¼šé€šè¿‡ <code>constChannelNormErase</code> å‡½æ•°è¿›è¡Œæ¶ˆé™¤å’Œå°†å¯¹å…¶ä¿¡æ¯åŒæ­¥åˆ° LoadConstOp. æœ€åé€šè¿‡ <code>processMultiUse</code> ç¡®ä¿æ‰€æœ‰åŠ è½½åŒä¸€ä¸ªåº•å±‚å¸¸é‡æ•°æ®çš„ LoadConstOp å®ä¾‹ï¼Œéƒ½å…·æœ‰å®Œå…¨ç›¸åŒçš„å†…å­˜å¸ƒå±€ã€‚</p>
<details class="custom-details">
    <summary class="custom-summary">ConstNormPass Implementation</summary>
    <div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">ConstNormPass</span><span class="o">::</span><span class="n">runOnOperation</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ModuleOp</span> <span class="n">module</span> <span class="o">=</span> <span class="n">getOperation</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">func</span><span class="o">::</span><span class="n">FuncOp</span> <span class="n">mainGraphFunc</span> <span class="o">=</span> <span class="n">getMainFuncOp</span><span class="p">(</span><span class="n">module</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">Operation</span> <span class="o">*&gt;</span> <span class="n">deletedChannelnorm</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Walk the main function to find a specific pattern: LoadConst -&gt; ChannelNorm.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">mainGraphFunc</span><span class="p">.</span><span class="n">walk</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">Operation</span><span class="o">*</span> <span class="n">constOp</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">isa</span><span class="o">&lt;</span><span class="n">tx8be</span><span class="o">::</span><span class="n">LoadConstOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">constOp</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">Operation</span><span class="o">*&gt;</span> <span class="n">users</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">users</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">constOp</span><span class="o">-&gt;</span><span class="n">getUsers</span><span class="p">().</span><span class="n">begin</span><span class="p">(),</span> <span class="n">constOp</span><span class="o">-&gt;</span><span class="n">getUsers</span><span class="p">().</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">            <span class="kt">bool</span> <span class="n">flag</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// Check if any user is a ChannelNormOp.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">user</span> <span class="p">:</span> <span class="n">users</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">isa</span><span class="o">&lt;</span><span class="n">tx8be</span><span class="o">::</span><span class="n">ChannelNormOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">user</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">flag</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="c1">// If the LoadConst has exactly one user, and that user is a ChannelNormOp,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// mark the ChannelNormOp for deletion.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">&amp;&amp;</span> <span class="n">users</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">it</span> <span class="p">:</span> <span class="n">users</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// The erase logic is commented out, maybe handled by constChannelNormErase or done later.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="n">deletedChannelnorm</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Erase all the marked ChannelNormOps. This is done in a separate loop
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// to avoid iterator invalidation issues.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">op</span> <span class="p">:</span> <span class="n">deletedChannelnorm</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">op</span><span class="o">-&gt;</span><span class="n">erase</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Set up and run a nested pass pipeline.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">OpPassManager</span> <span class="nf">thisPM</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">getOpName</span><span class="p">().</span><span class="n">value</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// This pipeline will only apply to LoadConstOp operations inside functions.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">OpPassManager</span> <span class="o">&amp;</span><span class="n">loadConstOpPM</span> <span class="o">=</span> <span class="n">thisPM</span><span class="p">.</span><span class="n">nest</span><span class="o">&lt;</span><span class="n">func</span><span class="o">::</span><span class="n">FuncOp</span><span class="o">&gt;</span><span class="p">().</span><span class="n">nest</span><span class="o">&lt;</span><span class="n">tx8be</span><span class="o">::</span><span class="n">LoadConstOp</span><span class="o">&gt;</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Add the ConstNormDoPass to the pipeline.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">loadConstOpPM</span><span class="p">.</span><span class="n">addPass</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">ConstNormDoPass</span><span class="o">&gt;</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Run the newly constructed pipeline on the module.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">runPipeline</span><span class="p">(</span><span class="n">thisPM</span><span class="p">,</span> <span class="n">getOperation</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// After the pipeline, run a final cleanup/consistency check function.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">processMultiUse</span><span class="p">(</span><span class="n">module</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// change unpack input0 qweight shape after ConstNormDoPass. (Original comment)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// This logic is likely inside the runOnOperation() method of ConstNormDoPass.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">mainGraphFunc</span><span class="p">.</span><span class="n">walk</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">Operation</span><span class="o">*</span> <span class="n">constOp</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">isa</span><span class="o">&lt;</span><span class="n">tx8be</span><span class="o">::</span><span class="n">LoadConstOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">constOp</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="c1">// Collect all users of this LoadConstOp.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">Operation</span><span class="o">*&gt;</span> <span class="n">users</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="n">users</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">constOp</span><span class="o">-&gt;</span><span class="n">getUsers</span><span class="p">().</span><span class="n">begin</span><span class="p">(),</span> <span class="n">constOp</span><span class="o">-&gt;</span><span class="n">getUsers</span><span class="p">().</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">          
</span></span><span class="line"><span class="cl">          <span class="c1">// Check if any user is an UnpackOp.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="kt">bool</span> <span class="n">flag</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">user</span> <span class="p">:</span> <span class="n">users</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">              <span class="k">if</span> <span class="p">(</span><span class="n">isa</span><span class="o">&lt;</span><span class="n">tx8be</span><span class="o">::</span><span class="n">UnpackOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">user</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                  <span class="n">flag</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                  <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">              <span class="p">}</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          <span class="c1">// If there is exactly one user, and it&#39;s an UnpackOp...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">&amp;&amp;</span> <span class="n">users</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">              <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">it</span> <span class="p">:</span> <span class="n">users</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                  <span class="c1">// This check seems to ensure we are modifying the correct operand.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                  <span class="k">if</span> <span class="p">(</span><span class="n">constOp</span><span class="o">-&gt;</span><span class="n">getResult</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                  <span class="c1">// Get the original shape and type.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                  <span class="n">llvm</span><span class="o">::</span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="p">,</span> <span class="mi">6</span><span class="o">&gt;</span> <span class="n">oShape</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                  <span class="k">auto</span> <span class="n">type</span> <span class="o">=</span> <span class="n">constOp</span><span class="o">-&gt;</span><span class="n">getResult</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">getType</span><span class="p">().</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">ShapedType</span><span class="o">&gt;</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">                  <span class="k">auto</span> <span class="n">shape</span> <span class="o">=</span> <span class="n">type</span><span class="p">.</span><span class="n">getShape</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                  <span class="c1">// Apply the shape transformation: e.g., for unpacking packed data.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                  <span class="n">oShape</span><span class="p">.</span><span class="n">push_back</span><span class="p">((</span><span class="kt">int32_t</span><span class="p">)</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">4</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                  <span class="n">oShape</span><span class="p">.</span><span class="n">push_back</span><span class="p">((</span><span class="kt">int32_t</span><span class="p">)</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">4</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                  <span class="c1">// Create a new tensor type with the new shape.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                  <span class="k">auto</span> <span class="n">oType</span> <span class="o">=</span> <span class="n">mlir</span><span class="o">::</span><span class="n">RankedTensorType</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">oShape</span><span class="p">,</span> <span class="n">type</span><span class="p">.</span><span class="n">getElementType</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">                  <span class="c1">// Update the type of the LoadConstOp&#39;s result in-place.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                  <span class="n">constOp</span><span class="o">-&gt;</span><span class="n">getResult</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">setType</span><span class="p">(</span><span class="n">oType</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                  <span class="p">}</span>
</span></span><span class="line"><span class="cl">              <span class="p">}</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span></code></pre></div></div>
</details><br>
<p><code>constChannelNormErase</code> å¤„ç† LoadConstOp -&gt; ChannelNormOp è¿™ç§æ¨¡å¼ã€‚è®©æ‰€æœ‰åŸæœ¬ä½¿ç”¨ ChannelNormOp è®¡ç®—ç»“æœçš„æ“ä½œï¼Œç°åœ¨æ”¹ä¸ºç›´æ¥ä½¿ç”¨ ChannelNormOp çš„è¾“å…¥æ•°æ®ã€‚è·å– LoadConstOp å½“å‰çš„è®¾å¤‡ä¿¡æ¯å’Œ layoutï¼Œè®¡ç®—å‡ºä¸€ä¸ªæ–°çš„ç»è¿‡å¯¹é½çš„å¸ƒå±€ <code>align_dev_layout</code>ï¼Œç„¶åç”¨è¿™ä¸ªæ–°å¸ƒå±€å»æ›´æ–° LoadConstOp.</p>
<details class="custom-details">
    <summary class="custom-summary">constChannelNormErase Implementation</summary>
    <div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// This function erases a ChannelNormOp by bypassing it and updating the source constant&#39;s layout.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">constChannelNormErase</span><span class="p">(</span><span class="n">tx8be</span><span class="o">::</span><span class="n">ChannelNormOp</span> <span class="n">op</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Find the defining operation of the ChannelNorm&#39;s operand, which should be a LoadConstOp.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">auto</span> <span class="n">defOp</span> <span class="o">=</span> <span class="n">llvm</span><span class="o">::</span><span class="n">dyn_cast_or_null</span><span class="o">&lt;</span><span class="n">tx8be</span><span class="o">::</span><span class="n">LoadConstOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">getDefiningOp</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// If the source is not a LoadConstOp, do nothing.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">defOp</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Collect all users of the ChannelNormOp&#39;s result.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">llvm</span><span class="o">::</span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">Operation</span><span class="o">*&gt;</span> <span class="n">userVec</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">userVec</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">userVec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">getUsers</span><span class="p">().</span><span class="n">begin</span><span class="p">(),</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">getUsers</span><span class="p">().</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">user</span> <span class="p">:</span> <span class="n">userVec</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Replace all uses of the ChannelNormOp&#39;s result with the result of the LoadConstOp..
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">user</span><span class="o">-&gt;</span><span class="n">replaceUsesOfWith</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">getResult</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="c1">// After bypassing, the layout of the source constant might need to be adjusted
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// to reflect the transformation that the ChannelNormOp was supposed to perform.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// set const layout to cx mode 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">auto</span> <span class="n">dev_layout</span> <span class="o">=</span> <span class="n">getDevInfoLayoutMode</span><span class="p">(</span><span class="n">defOp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="n">align_dev_layout</span> <span class="o">=</span> <span class="n">get_aligned_layout</span><span class="p">((</span><span class="n">LAYOUT_MODE</span><span class="p">)</span><span class="n">dev_layout</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">setDevInfoWithLayout</span><span class="p">(</span><span class="n">defOp</span><span class="o">-&gt;</span><span class="n">getContext</span><span class="p">(),</span> <span class="n">defOp</span><span class="p">,</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">tx8be</span><span class="o">::</span><span class="n">LayoutMode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">align_dev_layout</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></div>
</details><br>
<p><code>processMultiUse</code> ä¿è¯æ‰€æœ‰å¯¹åŒä¸€ä»½å¸¸é‡æ•°æ®çš„å¼•ç”¨ï¼Œå…¶ mem_layout éƒ½æ˜¯å®Œå…¨ä¸€è‡´çš„ã€‚æµç¨‹å¦‚ä¸‹</p>
<ol>
<li><code>processMultiUse</code> éå†è®¡ç®—å›¾ä¸­çš„æ‰€æœ‰ LoadConstOpï¼Œä»¥ <code>const_map_id</code> ä¸º keyï¼Œå°†æ‰€æœ‰æŒ‡å‘åŒä¸€ä¸ªç‰©ç†å¸¸é‡çš„ LoadConstOp å®ä¾‹åˆ†ç»„å­˜æ”¾åœ¨ä¸€èµ·ã€‚</li>
<li>éå†è¿™ä¸ª mapï¼Œåªå¤„ç†é‚£äº›åŒ…å«å¤šä¸ª LoadConstOp å®ä¾‹çš„ç»„ (<code>kv.second.size() &gt; 1</code>).</li>
<li>åœ¨æ¯ä¸ªç»„å†…ï¼Œç¡®å®šä¸€ä¸ªæ­£ç¡®çš„å¸ƒå±€ã€‚ä»£ç é€»è¾‘æ˜¯ä»¥ç»„å†…çš„ç¬¬ä¸€ä¸ª LoadConstOp çš„å¸ƒå±€ä¸ºåŸºå‡†ï¼Œä½†å¦‚æœå‘ç°ç»„å†…æœ‰ <code>is_cx_layout</code>ï¼Œåˆ™ä¼šé‡‡ç”¨è¿™ä¸ªä¼˜å…ˆçš„å¸ƒå±€ä½œä¸ºæ ‡å‡†ã€‚</li>
<li>ä¸€æ—¦ç¡®å®šäº†æ ‡å‡†å¸ƒå±€ï¼Œä¼šå†æ¬¡éå†è¯¥ç»„å†…çš„æ‰€æœ‰ LoadConstOp å®ä¾‹ã€‚è°ƒç”¨ <code>setDevInfoWithLayout</code> å‡½æ•°ï¼Œå¼ºåˆ¶å°†æ¯ä¸€ä¸ªå®ä¾‹çš„å¸ƒå±€å±æ€§ä¿®æ”¹ä¸ºåˆšæ‰ç¡®å®šçš„é‚£ä¸ªæ ‡å‡†å¸ƒå±€ã€‚</li>
</ol>
<details class="custom-details">
    <summary class="custom-summary">processMultiUse Implementation</summary>
    <div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// This function processes multi-use constants to ensure their layouts are consistent.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">ConstNormPass</span><span class="o">::</span><span class="n">processMultiUse</span><span class="p">(</span><span class="n">ModuleOp</span> <span class="n">module</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">func</span><span class="o">::</span><span class="n">FuncOp</span> <span class="n">mainGraphFunc</span> <span class="o">=</span> <span class="n">getMainFuncOp</span><span class="p">(</span><span class="n">module</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="c1">// When a const is used by multiple users, multiple loadconsts will be generated,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// but only one loadconst will have its layout set. The others will be skipped.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// We need to go over them uniformly. 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// First, find all previous useless constant ops.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Group all LoadConstOp instances by their underlying constant data ID (const_map_id).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int32_t</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">mlir</span><span class="o">::</span><span class="n">Operation</span> <span class="o">*&gt;&gt;</span> <span class="n">allconst</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">mainGraphFunc</span><span class="p">.</span><span class="n">walk</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">Operation</span><span class="o">*</span> <span class="n">constOp</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">isa</span><span class="o">&lt;</span><span class="n">tx8be</span><span class="o">::</span><span class="n">LoadConstOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">constOp</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">auto</span> <span class="n">cOp</span> <span class="o">=</span> <span class="n">llvm</span><span class="o">::</span><span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">tx8be</span><span class="o">::</span><span class="n">LoadConstOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">constOp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="kt">uint32_t</span> <span class="n">t_map_id</span> <span class="o">=</span> <span class="n">cOp</span><span class="p">.</span><span class="n">getConstMapId</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="n">allconst</span><span class="p">[</span><span class="n">t_map_id</span><span class="p">].</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">constOp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Based on duplication, find if the layout needs to be changed to cx. 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Check if there is also a Cx with the same layout. 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Iterate over each group of LoadConstOps that share the same data.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">kv</span> <span class="p">:</span> <span class="n">allconst</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">kv</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Process only if there are multiple users.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// Assume the layout of the first user is the correct one.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">auto</span> <span class="n">layout</span> <span class="o">=</span> <span class="p">(</span><span class="n">LAYOUT_MODE</span><span class="p">)</span><span class="n">getDevInfoLayoutMode</span><span class="p">(</span><span class="n">kv</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">front</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">      
</span></span><span class="line"><span class="cl">      <span class="c1">// This loop is for validation, checking if layouts are inconsistent.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">op</span> <span class="p">:</span> <span class="n">kv</span><span class="p">.</span><span class="n">second</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">auto</span> <span class="n">layout2</span> <span class="o">=</span> <span class="p">(</span><span class="n">LAYOUT_MODE</span><span class="p">)</span><span class="n">getDevInfoLayoutMode</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">is_cx_layout</span><span class="p">(</span><span class="n">layout2</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ALIGN_NOT</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="n">layout</span> <span class="o">=</span> <span class="n">layout2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1">// Force all LoadConstOps in this group to have the same, correct layout.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">op</span> <span class="p">:</span> <span class="n">kv</span><span class="p">.</span><span class="n">second</span><span class="p">)</span> <span class="p">{</span>  
</span></span><span class="line"><span class="cl">        <span class="k">auto</span> <span class="n">ctx</span> <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">getContext</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">ASSERT</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">hasAttr</span><span class="p">(</span><span class="s">&#34;dev_info&#34;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="s">&#34;Must have dev_info!&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">setDevInfoWithLayout</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="p">(</span><span class="n">tx8be</span><span class="o">::</span><span class="n">LayoutMode</span><span class="p">)</span><span class="n">layout</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></div>
</details><br>
<h1 id="sharding-search-and-spm-management">Sharding Search and SPM Management<a hidden class="anchor" aria-hidden="true" href="#sharding-search-and-spm-management">#</a></h1>
<p>ç¬¬ä¸€æ­¥æ˜¯å¯¹ç®—å­è¿›è¡Œ Group åˆ’åˆ†ï¼Œæ’å…¥ load &amp; store. å¯¹æ¯ä¸€ä¸ª subGraph ä¼šåº”ç”¨å¦‚ä¸‹çš„ 3 ä¸ª Pass:</p>
<ul>
<li><strong>GroupPatternPass</strong>ï¼šåº”ç”¨é…ç½®å¥½çš„ group config (opt_group).</li>
<li><strong>GroupOptimizationPass</strong>: å¦‚æœæ²¡æœ‰é…ç½®ï¼Œåˆ™ä¼šä¸ºæ¯ä¸ª compute op åˆ›å»ºä¸€ä¸ª group.</li>
<li><strong>GroupLdStPass</strong>: ä¸ºæ¯ä¸ªéœ€è¦çš„ groupOp æ’ å…¥loadOp å’Œ storeOpï¼Œå¹¶æ·»åŠ  group_tag.
<ul>
<li>group_tag = 0: éœ€è¦ load æˆ– storeï¼Œæ„å‘³ç€è¯¥ group éœ€è¦åç»­çš„åˆ‡åˆ†æœç´¢ã€‚</li>
<li>group_tag = 2: ä¸éœ€è¦ load æˆ– storeï¼Œæ„å‘³ç€è¯¥ group çš„op éƒ½åœ¨ DDR ä¸Šæ“ä½œï¼Œæ— éœ€å‚ä¸åç»­çš„åˆ‡åˆ†æœç´¢ã€‚</li>
</ul>
</li>
</ul>
<p>SPM ä¸Šä¸€å®šè¦èƒ½æ”¾ä¸‹åˆ‡åˆ†åçš„ç»“æœã€‚Group æ˜¯åˆ‡åˆ†æœç´¢å’Œ SPM åˆ†é…çš„åŸºæœ¬çš„å•ä½ã€‚æ€æƒ³å°±æ˜¯å°½é‡æŠŠè¿ç»­æ‰§è¡Œçš„ç®—å­ç»„åˆåœ¨ä¸€èµ·ï¼Œä¸€ç›´åœ¨ SPM ä¸Šè¿è¡Œè€Œä¸æ˜¯å­˜å› DDR å†è¯»å…¥ï¼Œä»¥æ­¤æ¥å‡å°‘è®¿å­˜æ—¶é—´ã€‚GroupOp åœ¨ td æ–‡ä»¶ä¸­å®šä¹‰æ‰€åŒ…å«çš„è¾“å…¥å¦‚ä¸‹:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-tablegen" data-lang="tablegen"><span class="line"><span class="cl"><span class="k">let</span> <span class="nv">regions</span> <span class="p">=</span> <span class="p">(</span><span class="nv">region</span> <span class="nv">SizedRegion</span><span class="p">&lt;</span><span class="m">1</span><span class="p">&gt;:</span><span class="nv">$body</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">let</span> <span class="nv">arguments</span> <span class="p">=</span> <span class="p">(</span><span class="nv">ins</span>
</span></span><span class="line"><span class="cl">    <span class="nv">Variadic</span><span class="p">&lt;</span><span class="nv">AnyTensorOrNone</span><span class="p">&gt;:</span><span class="nv">$operands</span><span class="p">,</span>      <span class="c">// è¾“å…¥å‚æ•°ä¸º æ“ä½œæ•°çš„æ•°é‡å¯å˜çš„çš„å¼ é‡
</span></span></span><span class="line"><span class="cl"><span class="c"></span>    <span class="nv">DefaultValuedAttr</span><span class="p">&lt;</span><span class="nv">BoolAttr</span><span class="p">,</span> <span class="s">&#34;false&#34;</span><span class="p">&gt;:</span><span class="nv">$pipeline_parallel</span><span class="p">,</span> <span class="c">// æ˜¯å¦ç”¨æµæ°´çº¿å¹¶è¡Œ
</span></span></span><span class="line"><span class="cl"><span class="c"></span>    <span class="nv">DefaultValuedAttr</span><span class="p">&lt;</span><span class="nv">I32Attr</span><span class="p">,</span> <span class="s">&#34;1&#34;</span><span class="p">&gt;:</span><span class="nv">$sp_stage_num</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nv">OptionalAttr</span><span class="p">&lt;</span><span class="nv">Tx8e_RegionAttr</span><span class="p">&gt;:</span><span class="nv">$dev_region</span><span class="p">,</span> <span class="c">// è®¾å¤‡çš„ç©ºé—´å±æ€§
</span></span></span><span class="line"><span class="cl"><span class="c"></span>    <span class="nv">OptionalAttr</span><span class="p">&lt;</span><span class="nv">UI32Attr</span><span class="p">&gt;:</span><span class="nv">$spm_alloc_size</span><span class="p">,</span>   <span class="c">// groupå ç”¨çš„spmå¤§å°
</span></span></span><span class="line"><span class="cl"><span class="c"></span>    <span class="nv">OptionalAttr</span><span class="p">&lt;</span><span class="nv">I32Attr</span><span class="p">&gt;:</span><span class="nv">$group_tag</span><span class="p">,</span>         <span class="c">// 0: æ­£å¸¸åˆ‡åˆ†, 1: split nht, 2: ä¸åˆ‡åˆ† (reshape)
</span></span></span><span class="line"><span class="cl"><span class="c"></span>    <span class="nv">OptionalAttr</span><span class="p">&lt;</span><span class="nv">DenseI32ArrayAttr</span><span class="p">&gt;:</span><span class="nv">$stream_online_check</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nv">OptionalAttr</span><span class="p">&lt;</span><span class="nv">DenseI32ArrayAttr</span><span class="p">&gt;:</span><span class="nv">$stream_offline</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nv">DefaultValuedAttr</span><span class="p">&lt;</span><span class="nv">BoolAttr</span><span class="p">,</span> <span class="s">&#34;true&#34;</span><span class="p">&gt;:</span><span class="nv">$need_barrier</span><span class="p">,</span>   <span class="c">// æ˜¯å¦éœ€è¦tileåŒæ­¥
</span></span></span><span class="line"><span class="cl"><span class="c"></span>    <span class="nv">DefaultValuedAttr</span><span class="p">&lt;</span><span class="nv">SI32Attr</span><span class="p">,</span> <span class="s">&#34;-1&#34;</span><span class="p">&gt;:</span><span class="nv">$group_id</span><span class="p">,</span>         <span class="c">// group idåºå·
</span></span></span><span class="line"><span class="cl"><span class="c"></span>    <span class="nv">DefaultValuedAttr</span><span class="p">&lt;</span><span class="nv">SI32Attr</span><span class="p">,</span> <span class="s">&#34;-1&#34;</span><span class="p">&gt;:</span><span class="nv">$template_id</span>      <span class="c">// å¤ç”¨å…¶ä»–groupçš„id, å°äº0ä¸ºä¸å¤ç”¨
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">let</span> <span class="nv">results</span> <span class="p">=</span> <span class="p">(</span><span class="nv">outs</span> <span class="nv">Variadic</span><span class="p">&lt;</span><span class="nv">AnyTensorOrNone</span><span class="p">&gt;:</span><span class="nv">$results</span><span class="p">);</span>
</span></span></code></pre></div><p>è¿˜æœ‰ä¸€äº›å¸¸ç”¨åˆ°çš„ç»“æ„ä½“
<code>SecsInfo</code> è®°å½•äº†å•ä¸ª Opåœ¨åˆ†å¸ƒå¼ç­–ç•¥æœç´¢è¿‡ç¨‹ä¸­çš„æ‰€æœ‰çŠ¶æ€å’Œä¿¡æ¯ã€‚</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">SecsInfo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int32_t</span><span class="o">&gt;</span> <span class="n">sharding</span><span class="p">;</span>  <span class="c1">// space 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int32_t</span><span class="o">&gt;</span> <span class="n">split</span><span class="p">;</span>  <span class="c1">// time
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int32_t</span><span class="o">&gt;</span> <span class="n">splitry</span><span class="p">;</span>  <span class="c1">// å½“å‰æœç´¢çš„ sharding çš„ split
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int32_t</span><span class="o">&gt;</span> <span class="n">reduceSplit</span><span class="p">;</span>  <span class="c1">// é’ˆå¯¹éœ€è¦è¿›è¡Œè§„çº¦ (Reduction) çš„ç»´åº¦çš„åˆ‡åˆ†ç­–ç•¥ã€‚
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int32_t</span> <span class="n">reducesplit</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>  <span class="c1">// ä¸€ä¸ªæ ‡è®°ä½ï¼Œç”¨äºæŒ‡ç¤ºreduceSplitæ˜¯å¦è¢«ä½¿ç”¨
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ******************** ä»¥ä¸‹å˜é‡ä¸ºfactorSpaceä½¿ç”¨éƒ¨åˆ† ********************
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">sfinish</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>  <span class="c1">// æ ‡è®° split/reduceSplit ç›¸å…³çš„ç­–ç•¥æ˜¯å¦å·²ç¡®å®šã€‚
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="c1">// æšä¸¾ç±»å‹ï¼Œå®šä¹‰äº†å½“å‰ç®—å­æ‰€å¤„çš„åˆ‡åˆ†æ¨¡å¼ï¼Œç‰¹åˆ«å…³æ³¨éœ€è¦é€šä¿¡çš„Reduceç»´åº¦ã€‚
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="cm">/* SHARDING_MODE çš„å¯èƒ½å€¼è§£é‡Šï¼š
</span></span></span><span class="line"><span class="cl"><span class="cm">   * SHARDING_INIT: åˆå§‹çŠ¶æ€ï¼Œå°šæœªç¡®å®šæ¨¡å¼ã€‚
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 0: ä¸åˆ‡åˆ†è§„çº¦ (reduce) ç»´åº¦ã€‚æ„å‘³ç€æ•°æ®åœ¨æ¯ä¸ªè®¾å¤‡ä¸Šæ˜¯å®Œæ•´çš„ï¼Œæ— éœ€é€šä¿¡ã€‚
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 1: å•è¾¹åˆ‡åˆ†è§„çº¦ç»´åº¦ã€‚ä¾‹å¦‚ï¼Œåªåˆ‡åˆ†æƒé‡ï¼Œä¸åˆ‡åˆ†è¾“å…¥ï¼Œæ•°æ®åœ¨ä¸åŒtileä¸Šéœ€è¦é€šä¿¡ã€‚
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 2: ä¸¤è¾¹éƒ½åˆ‡åˆ†è§„çº¦ç»´åº¦ã€‚
</span></span></span><span class="line"><span class="cl"><span class="cm">   * 3: å¯¹æƒé‡(weight)çš„è¾“å‡ºé€šé“(output channel)ç»´åº¦è¿›è¡Œåˆ‡åˆ†ï¼Œä½†ä¸å±äºå¼ é‡å¹¶è¡Œ(TP)ï¼Œå¯èƒ½éœ€è¦fn/océ€šä¿¡ã€‚
</span></span></span><span class="line"><span class="cl"><span class="cm">  */</span>
</span></span><span class="line"><span class="cl">  <span class="n">SHARDING_MODE</span> <span class="n">shardingMode</span><span class="p">{</span><span class="n">SHARDING_INIT</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">rfinish</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>   <span class="c1">// æ ‡è®° reduceSplit ç›¸å…³çš„ç­–ç•¥æ˜¯å¦å·²å®Œæˆå¤„ç†ã€‚
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="n">nfirst</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>  <span class="c1">// æ ‡è®°æœç´¢æ–¹å‘ã€‚1: search from dim0 -&gt; dim n-1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="n">finish</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>  <span class="c1">// è¡¨ç¤ºè¯¥ç®—å­çš„ç­–ç•¥æœç´¢æ˜¯å¦å·²å…¨éƒ¨å®Œæˆã€‚æ•´ä¸ªæœç´¢æµç¨‹: sharding -&gt; shardingmode -&gt; split -&gt; reduceSplit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">sliceShapeMin</span><span class="p">;</span> <span class="c1">// æ ‡è®°åˆ‡åˆ†åçš„å¼ é‡ (slice) åœ¨æ¯ä¸ªç»´åº¦ä¸Šæ˜¯å¦å·²è¾¾åˆ°æŸä¸ªæœ€å°å°ºå¯¸é™åˆ¶ã€‚
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ******************** ä»¥ä¸‹å˜é‡ä¸ºsliceInfoä½¿ç”¨éƒ¨åˆ† ********************
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span> <span class="n">TemporalShape</span><span class="p">;</span>  <span class="c1">// åˆ‡åˆ†åï¼Œä¸´æ—¶çš„å¼ é‡å½¢çŠ¶
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">reduce_sharding_space</span><span class="p">;</span>  <span class="c1">// è§„çº¦ç»´åº¦åˆ‡åˆ†çš„æœç´¢ç©ºé—´
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">reduce_sharding</span><span class="p">;</span>  <span class="c1">// // æœ€ç»ˆé€‰å®šçš„è§„çº¦ç»´åº¦åˆ‡åˆ†ç­–ç•¥
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="n">sharding2_finish</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>  <span class="c1">// æ ‡è®°ç¬¬äºŒé˜¶æ®µåˆ‡åˆ† (å¯èƒ½ä¸è§„çº¦ç›¸å…³) æ˜¯å¦å®Œæˆ
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></div><h2 id="grouppatternpass">GroupPatternPass<a hidden class="anchor" aria-hidden="true" href="#grouppatternpass">#</a></h2>
<p><code>GroupPatternPass</code> å…¶æ ¸å¿ƒåŠŸèƒ½æ˜¯åœ¨ç»™å®šçš„è®¡ç®—å›¾ (subgraphOp) ä¸­ï¼Œé€šè¿‡ä¸€ç§é«˜æ•ˆçš„æ¨¡å¼åŒ¹é…ç®—æ³•ï¼Œè¯†åˆ«å‡ºé¢„å®šä¹‰çš„ã€å¯ä¼˜åŒ–çš„å­å›¾æ¨¡å¼ (Operator Patterns)ï¼Œå¹¶å°†åŒ¹é…åˆ°çš„ç®—å­ (Operations) è¿›è¡Œåˆ†ç»„ã€‚è¿™ç§åˆ†ç»„é€šå¸¸æ˜¯å›¾ä¼˜åŒ– (å¦‚ç®—å­èåˆã€ç®—å­è°ƒåº¦) çš„ç¬¬ä¸€æ­¥ã€‚</p>
<p>è¯¥ Pass é¦–å…ˆè·å–é…ç½®ï¼Œå†³å®šä»å“ªé‡ŒåŠ è½½æ¨¡å¼ (ä¸€ä¸ª mapï¼Œå…¶é”®æ˜¯æ¨¡å¼ï¼Œå³ä¸€ä¸ªç®—å­åºåˆ— <code>std::vector&lt;TX8BE_OPS&gt;</code>ï¼Œå€¼æ˜¯ä¸€ä¸ªæ•´æ•° <code>int</code>ï¼Œä»£è¡¨æ¨¡å¼ä¼˜å…ˆçº§ï¼Œè¶Šå¤§ä¼˜å…ˆçº§è¶Šé«˜) ã€‚ç„¶åï¼Œå®ƒè°ƒç”¨ <code>aca.insertPatterns</code> å°†è¿™äº›æ¨¡å¼&quot;ç¼–è¯‘&quot;åˆ° Automation å¼•æ“ä¸­ã€‚æ¥ç€ï¼Œè°ƒç”¨ <code>aca.search</code> æ‰§è¡ŒåŒ¹é…ã€‚æœ€åï¼Œä» manager ä¸­è·å–åŒ¹é…ç»“æœ (groups) ï¼Œå¹¶å¯¹è¿™äº› groups è¿›è¡Œåç»­å¤„ç†ï¼Œä¾‹å¦‚åˆ›å»ºæ–°çš„é€»è¾‘åˆ†ç»„å’Œè¿›è¡Œæ‹“æ‰‘æ’åºã€‚</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"> <span class="kt">void</span> <span class="n">GroupPatternPass</span><span class="o">::</span><span class="n">runOnOperation</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">     <span class="n">TFUNC_SCOPE</span><span class="p">(</span><span class="n">DEBUG</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">     <span class="k">auto</span> <span class="n">subgraphOp</span> <span class="o">=</span> <span class="n">getOperation</span><span class="p">();</span> <span class="c1">// Get the current operation (e.g., a function) the pass is running on.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> 
</span></span><span class="line"><span class="cl">     <span class="n">PatternManager</span> <span class="n">manager</span><span class="p">;</span> <span class="c1">// A manager to hold graph rewriting information.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>     <span class="n">Automation</span> <span class="nf">aca</span><span class="p">(</span><span class="o">&amp;</span><span class="n">manager</span><span class="p">);</span> <span class="c1">// Custom &#39;Automation&#39; class for pattern matching logic.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> 
</span></span><span class="line"><span class="cl">     <span class="k">auto</span> <span class="n">minfo</span> <span class="o">=</span> <span class="n">getModuleConfig</span><span class="p">(</span><span class="n">getModuleByOp</span><span class="p">(</span><span class="n">getOperation</span><span class="p">()));</span> 
</span></span><span class="line"><span class="cl">     <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">path</span> <span class="o">=</span> <span class="s">&#34;&#34;</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">     <span class="k">auto</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">path</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="o">?</span> <span class="n">getPatternsFromFile</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>  <span class="c1">// Load patterns from a file if path is specified.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                           <span class="o">:</span> <span class="p">(</span><span class="n">patternConfigMap</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">GroupPatternMode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">minfo</span><span class="p">.</span><span class="n">opt_group</span><span class="p">)));</span> <span class="c1">// Otherwise, load from a pre-defined map using a config key.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>     <span class="n">TLOG</span><span class="p">(</span><span class="n">INFO</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;[GroupPatternPass] config id: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">minfo</span><span class="p">.</span><span class="n">opt_group</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">     <span class="n">aca</span><span class="p">.</span><span class="n">insertPatterns</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span> <span class="c1">// Insert the loaded patterns into the Automation engine. This is the starting point for building the matching structure.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>     <span class="n">TLOG</span><span class="p">(</span><span class="n">INFO</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;[Automation]: </span><span class="se">\n</span><span class="s">&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">printTree</span><span class="p">(</span><span class="n">aca</span><span class="p">.</span><span class="n">root</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">     <span class="n">aca</span><span class="p">.</span><span class="n">search</span><span class="p">(</span><span class="n">subgraphOp</span><span class="p">);</span> <span class="c1">// Execute the search for all patterns on the given subgraph. (search function code is not provided but its role is clear).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">manager</span><span class="p">.</span><span class="n">applyAll</span><span class="p">();</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     <span class="k">auto</span> <span class="n">groups</span> <span class="o">=</span> <span class="n">manager</span><span class="p">.</span><span class="n">getGroups</span><span class="p">();</span> <span class="c1">// Retrieve the groups of operations that were matched.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>     <span class="n">manager</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     <span class="k">auto</span> <span class="n">newGroups</span> <span class="o">=</span> <span class="n">createGroups</span><span class="p">(</span><span class="n">subgraphOp</span><span class="p">,</span> <span class="n">groups</span><span class="p">);</span> <span class="c1">// Create new group structures from the matched results.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>     <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">group</span> <span class="p">:</span> <span class="n">newGroups</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="n">sortTopologically</span><span class="p">(</span><span class="n">group</span><span class="o">-&gt;</span><span class="n">getBlock</span><span class="p">());</span> <span class="c1">// Topologically sort the operations within each new group to maintain data dependencies.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>     <span class="p">}</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span></code></pre></div><p><code>insertPatterns</code> å¯¹äºæ¯ä¸€ä¸ªæ¨¡å¼ï¼Œå®ƒé¦–å…ˆè°ƒç”¨ processPattern æ¥å¤„ç†å…¶ä¸­çš„ OR, WILDCARD ç®—å­ã€‚</p>
<ul>
<li>å½“é‡åˆ° OR æ—¶ï¼Œå®ƒä¼šå°†æ¨¡å¼æ‹†åˆ†ã€‚ä¾‹å¦‚ï¼ŒA B OR C D è¿™æ ·çš„æ¨¡å¼ä¼šè¢«æ‹†è§£æˆä¸¤ä¸ªç‹¬ç«‹çš„æ¨¡å¼ A B å’Œ C D è¿›è¡Œå¤„ç†ã€‚</li>
<li>å½“é‡åˆ° WILDCARD æ—¶ï¼Œå®ƒä¼šç”Ÿæˆå¤šä¸ªæ¨¡å¼ã€‚æ ¹æ®ä»£ç  <code>for (int i = 0; i &lt; 5; i++)</code> å’Œ <code>temp.push_back(*(it - 1))</code>ï¼ŒOP * å¯èƒ½ä¼šè¢«æ‰©å±•æˆ OP, OP OP, OP OP OP, OP OP OP OP ç­‰ä¸€ç³»åˆ—é‡å¤æ¨¡å¼ã€‚</li>
<li>å®ƒé€šè¿‡é€’å½’è°ƒç”¨è‡ªèº«ï¼Œä»¥å¤„ç†ä¸€ä¸ªæ¨¡å¼ä¸­åŒ…å«å¤šä¸ªç‰¹æ®Šç®—å­çš„æƒ…å†µã€‚
æœ€ç»ˆï¼Œå®ƒè¿”å›ä¸€ä¸ªç”±å¤šä¸ªå…·ä½“ã€æ— ç‰¹æ®Šç®—å­çš„æ¨¡å¼ç»„æˆçš„åˆ—è¡¨ã€‚ç„¶åï¼Œå®ƒå°†è¿™äº›æ‰©å±•åçš„å…·ä½“æ¨¡å¼é€ä¸€ä¼ é€’ç»™ <code>insertPattern</code> å‡½æ•°ï¼Œä»¥æ„å»º Trie æ ‘ã€‚</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Automation</span><span class="o">::</span><span class="n">insertPatterns</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TX8BE_OPS</span><span class="o">&gt;</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">patterns</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TX8BE_OPS</span><span class="o">&gt;&gt;</span> <span class="n">tempPatterns</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">it</span> <span class="p">:</span> <span class="n">patterns</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Iterate through each pattern from the input map.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="k">auto</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">processPattern</span><span class="p">(</span><span class="n">it</span><span class="p">.</span><span class="n">first</span><span class="p">);</span> <span class="c1">// Pre-process the pattern. This can expand one pattern into many.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">p</span> <span class="p">:</span> <span class="n">temp</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// For each of the generated concrete patterns...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">insertPattern</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">it</span><span class="p">.</span><span class="n">second</span><span class="p">);</span> <span class="c1">// ...insert it into the main data structure (the Trie).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>insertPattern</code> æ¥æ”¶ä¸€ä¸ªå…·ä½“çš„æ¨¡å¼ï¼Œå¹¶å°†å…¶æ’å…¥åˆ° Trie æ ‘ä¸­ã€‚Trie æ ‘æ˜¯å®ç°é«˜æ•ˆå‰ç¼€åŒ¹é…çš„å…³é”®ã€‚ä»rootèŠ‚ç‚¹å¼€å§‹ éå†æ¨¡å¼ä¸­çš„æ¯ä¸ª op. å¦‚æœå½“å‰èŠ‚ç‚¹æ²¡æœ‰æŒ‡å‘opçš„å­èŠ‚ç‚¹ï¼Œå°±åˆ›å»ºä¸€ä¸ªç„¶åç§»åŠ¨åˆ°è¯¥å­èŠ‚ç‚¹ã€‚å½“æ¨¡å¼éå†å®Œæˆåï¼Œåœ¨æœ€ç»ˆçš„èŠ‚ç‚¹ä¸Šå­˜å‚¨å®Œæ•´æ¨¡å¼æœ¬èº« (<code>node-&gt;pattern</code>) å’Œå®ƒçš„ ID (<code>node-&gt;output</code>) ã€‚è¿™è¡¨æ˜ä¸€ä¸ªæœ‰æ•ˆçš„æ¨¡å¼åœ¨æ­¤ç»“æŸã€‚</p>
<details class="custom-details">
    <summary class="custom-summary">insertPattern Implementation</summary>
    <div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">TrieNode</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">TrieNode</span><span class="p">(</span><span class="n">TX8BE_OPS</span> <span class="n">id</span><span class="p">)</span> <span class="o">:</span> <span class="n">id</span><span class="p">(</span><span class="n">id</span><span class="p">)</span> <span class="p">{}</span> <span class="c1">// Constructor to initialize the node with an operation ID.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">TX8BE_OPS</span> <span class="n">id</span><span class="p">;</span> <span class="c1">// The operation (Op) type this node represents. This is the &#39;character&#39; in our sequence.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">output</span><span class="p">;</span> <span class="c1">// Stores the integer IDs of the patterns that end at this node. A non-empty vector indicates a valid pattern match.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TX8BE_OPS</span><span class="o">&gt;</span> <span class="n">pattern</span><span class="p">;</span> <span class="c1">// Stores the complete operator sequence for the pattern that ends here.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">TX8BE_OPS</span><span class="p">,</span> <span class="n">NodePtr</span><span class="o">&gt;</span> <span class="n">children</span><span class="p">;</span> <span class="c1">// A map from an operation type to the next node in the trie. `NodePtr` is likely a shared_ptr or unique_ptr to another TrieNode.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Automation</span><span class="o">::</span><span class="n">insertPattern</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TX8BE_OPS</span><span class="o">&gt;</span> <span class="n">pattern</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">patterns_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">pattern</span><span class="p">);</span> <span class="c1">// Store the raw pattern vector.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">auto</span> <span class="n">node</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span> <span class="c1">// Start from the root of the Trie.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">op</span> <span class="p">:</span> <span class="n">pattern</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Iterate through each operation in the pattern sequence.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="o">==</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// If a path for this operation does not exist...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">node</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">op</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">TrieNode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">op</span><span class="p">);</span> <span class="c1">// ...create a new node in the Trie.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">op</span><span class="p">];</span> <span class="c1">// Move to the next node in the Trie.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">node</span><span class="o">-&gt;</span><span class="n">pattern</span> <span class="o">=</span> <span class="n">pattern</span><span class="p">;</span> <span class="c1">// At the end of the pattern, mark this node as a terminal node by storing the full pattern.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">node</span><span class="o">-&gt;</span><span class="n">output</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">index</span><span class="p">);</span> <span class="c1">// Store the original pattern index/ID at this terminal node.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div></div>
</details><br>
<p><code>searchOp</code> å‡½æ•°çš„åŠŸèƒ½æ˜¯ï¼šç»™å®šä¸€ä¸ªèµ·å§‹ Trie èŠ‚ç‚¹ (parentNode) å’Œä¸€ä¸ªMLIRç®—å­ (op)ï¼Œå®ƒä¼šå°è¯•å°† op ä¸parentNode çš„å­èŠ‚ç‚¹è¿›è¡ŒåŒ¹é…ï¼Œå¹¶åœ¨åŒ¹é…æˆåŠŸåï¼Œé€’å½’åœ°å¯¹å…¶æ‰€æœ‰åç»§ç®—å­ (users) è¿›è¡Œ DFS æ¨¡å¼åŒ¹é…ï¼Œæœ€ç»ˆè¿”å›è¿™æ¡è·¯å¾„ä¸Šæ‰€èƒ½æ‰¾åˆ°çš„â€œæœ€ä½³â€åŒ¹é…æ¨¡å¼çš„æœ«ç«¯TrieèŠ‚ç‚¹ã€‚</p>
<p>è¿™é‡Œçš„â€œæœ€ä½³â€é€šå¸¸æŒ‡æœ€é•¿çš„åŒ¹é…æ¨¡å¼ï¼Œæˆ–è€…åœ¨æœ‰å¤šä¸ªåŒæ ·é•¿åº¦çš„æ¨¡å¼æ—¶ï¼Œé€‰æ‹©ä¼˜å…ˆçº§æœ€é«˜çš„é‚£ä¸ª (æ ¹æ®èŠ‚ç‚¹ä¸­çš„ <code>output.front()</code>) å¤§å°æ¯”è¾ƒæ¥åˆ¤æ–­ã€‚</p>
<details class="custom-details">
    <summary class="custom-summary">searchOp Implementation</summary>
    <div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">NodePtr</span> <span class="n">Automation</span><span class="o">::</span><span class="n">searchOp</span><span class="p">(</span><span class="n">NodePtr</span> <span class="n">parentNode</span><span class="p">,</span> <span class="n">Operation</span><span class="o">*</span> <span class="n">op</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">opId</span> <span class="o">=</span> <span class="n">getOpId</span><span class="p">(</span><span class="n">op</span><span class="p">);</span> <span class="c1">// Get the enumerated ID (e.g., TX8BE_OPS::CONV) for the current MLIR operation.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">isRealOp</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">parentNode</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">opId</span><span class="p">)</span> <span class="o">==</span> <span class="n">parentNode</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// If the current op is a &#34;real&#34; operation (not a terminator, etc.) but cannot be found in the children of the parent Trie node, it&#39;s a mismatch.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// This &#39;if&#39; block seems to be an early exit for a specific case, possibly redundant with the final return.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">parentNode</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">opId</span><span class="p">)</span> <span class="o">!=</span> <span class="n">parentNode</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// If a path exists in the Trie for the current operation `opId`. This is a potential match.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="c1">// If the current op matches, continue downwards
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">auto</span> <span class="n">currentNode</span> <span class="o">=</span> <span class="n">parentNode</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">opId</span><span class="p">];</span> <span class="c1">// Move to the matched Trie node.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">auto</span> <span class="n">tempNode</span> <span class="o">=</span> <span class="n">currentNode</span><span class="p">;</span> <span class="c1">// `tempNode` will store the longest match found so far starting from this path.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="c1">// --- Query Operation Attributes and Users ---
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">auto</span> <span class="n">queryInterface</span> <span class="o">=</span> <span class="n">llvm</span><span class="o">::</span><span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">tx8e_mlir</span><span class="o">::</span><span class="n">OpLibInterface</span><span class="o">&gt;</span><span class="p">(</span><span class="n">op</span><span class="p">);</span> <span class="c1">// Get a specific interface from the operation for querying attributes.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">auto</span> <span class="n">needStore</span> <span class="o">=</span> <span class="n">queryInterface</span><span class="p">.</span><span class="n">queryOpAttr</span><span class="p">().</span><span class="n">needStore</span><span class="p">;</span> <span class="c1">// Check an attribute, e.g., if the op&#39;s result needs to be stored.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">llvm</span><span class="o">::</span><span class="n">SmallSet</span><span class="o">&lt;</span><span class="n">Operation</span><span class="o">*</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">users</span><span class="p">;</span> <span class="c1">// Find all direct users of the current operation&#39;s result.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">user</span> <span class="p">:</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">getUsers</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">users</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">user</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">auto</span> <span class="n">sortedUsers</span> <span class="o">=</span> <span class="n">manager_</span><span class="o">-&gt;</span><span class="n">sortOps</span><span class="p">(</span><span class="n">users</span><span class="p">);</span> <span class="c1">// Sort the users, likely topologically or based on some priority.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="c1">// --- Recursively Search Through Users ---
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">user</span> <span class="p">:</span> <span class="n">sortedUsers</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isRealOp</span><span class="p">(</span><span class="n">user</span><span class="p">))</span> <span class="k">continue</span><span class="p">;</span> <span class="c1">// Skip non-essential ops.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">            <span class="k">auto</span> <span class="n">interface</span> <span class="o">=</span> <span class="n">llvm</span><span class="o">::</span><span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">tx8e_mlir</span><span class="o">::</span><span class="n">OpLibInterface</span><span class="o">&gt;</span><span class="p">(</span><span class="n">user</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">auto</span> <span class="n">needLoad</span> <span class="o">=</span> <span class="n">interface</span><span class="p">.</span><span class="n">queryOpAttr</span><span class="p">().</span><span class="n">needLoad</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">needStore</span> <span class="o">&amp;&amp;</span> <span class="n">needLoad</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span> <span class="c1">// Skip paths with certain attribute mismatches (e.g., store-load dependency).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">            <span class="c1">// Recursively call searchOp for the user operation, starting from the current Trie node.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">auto</span> <span class="n">terminalNode</span> <span class="o">=</span> <span class="n">searchOp</span><span class="p">(</span><span class="n">currentNode</span><span class="p">,</span> <span class="n">user</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// --- Update Best Match ---
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">terminalNode</span><span class="o">-&gt;</span><span class="n">output</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">tempNode</span><span class="o">-&gt;</span><span class="n">output</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// If both the previous best match (`tempNode`) and the new match (`terminalNode`) are valid patterns...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// Compare priority, take the one with the highest priority as the current node pattern)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">if</span> <span class="p">(</span><span class="n">terminalNode</span><span class="o">-&gt;</span><span class="n">output</span><span class="p">.</span><span class="n">front</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">tempNode</span><span class="o">-&gt;</span><span class="n">output</span><span class="p">.</span><span class="n">front</span><span class="p">())</span> <span class="p">{</span> <span class="o">/</span> <span class="p">...</span><span class="n">update</span> <span class="err">`</span><span class="n">tempNode</span><span class="err">`</span> <span class="n">to</span> <span class="n">the</span> <span class="k">new</span> <span class="n">one</span> <span class="k">if</span> <span class="n">it</span> <span class="n">has</span> <span class="n">a</span> <span class="n">higher</span> <span class="n">priority</span> <span class="p">(</span><span class="n">assuming</span> <span class="n">the</span> <span class="kt">int</span> <span class="n">ID</span> <span class="n">represents</span> <span class="n">priority</span><span class="p">).</span>
</span></span><span class="line"><span class="cl">                    <span class="n">tempNode</span> <span class="o">=</span> <span class="n">terminalNode</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="o">!</span><span class="n">terminalNode</span><span class="o">-&gt;</span><span class="n">output</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// If `tempNode` was not a valid pattern end, but `terminalNode` is, update it.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">tempNode</span> <span class="o">=</span> <span class="n">terminalNode</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// TFOOTER(TRACE)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="n">tempNode</span><span class="p">;</span> <span class="c1">// Return the node corresponding to the longest/best pattern found from this point.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Indicates parent node cannot match current op, return parent node)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">parentNode</span><span class="p">;</span> <span class="c1">// If no match was found for `opId` in the Trie, return the original `parentNode`.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div></div>
</details><br>
<p><code>search</code>éå†è®¡ç®—å­å›¾ (subgraph) ä¸­çš„æ¯ä¸€ä¸ªç®—å­ï¼Œå¹¶ä»¥è¯¥ç®—å­ä¸ºèµ·ç‚¹ï¼Œå°è¯•è¿›è¡Œæ¨¡å¼åŒ¹é…ã€‚</p>
<ol>
<li>é¢„å¤„ç†é˜¶æ®µ (ç¬¬ä¸€ä¸ª walk)
åœ¨æ­£å¼å¼€å§‹åŒ¹é…ä¹‹å‰ï¼Œå‡½æ•°ä¼šå…ˆéå†ä¸€æ¬¡æ•´ä¸ªå­å›¾ï¼Œç›®çš„æ˜¯æ”¶é›†å’Œæ³¨å†Œä¸€äº›å…ƒæ•°æ®ï¼š</li>
</ol>
<ul>
<li><code>manager_-&gt;opOrder_</code>: ä¸€ä¸ª vector è®°å½•å›¾ä¸­æ‰€æœ‰ç®—å­çš„å‡ºç°é¡ºåºã€‚</li>
<li><code>manager_-&gt;opIndexMap_</code>: ä¸ºæ¯ä¸ªç®—å­åˆ†é…ä¸€ä¸ªå”¯ä¸€çš„æ•´æ•°ç´¢å¼•ã€‚
è¿™äº›ä¿¡æ¯å¯¹äºåç»­çš„ç®¡ç†å’Œå¯èƒ½çš„å›¾å˜æ¢ (å¦‚æ‹“æ‰‘æ’åº) éå¸¸é‡è¦ã€‚</li>
</ul>
<ol start="2">
<li>é€ç‚¹åŒ¹é…é˜¶æ®µ (ç¬¬äºŒä¸ª walk)å®ƒå†æ¬¡éå†å­å›¾ä¸­çš„æ¯ä¸€ä¸ªç®—å­ op æ¯æ¬¡éƒ½æ˜¯ä» Trie æ ‘çš„æ ¹èŠ‚ç‚¹ root å¼€å§‹ <code>searchOp(root, op)</code> å‡½æ•°ã€‚æ„å‘³ç€å°è¯•ä»é›¶å¼€å§‹åŒ¹é…æ‰€æœ‰å·²çŸ¥çš„æ¨¡å¼ã€‚ searchOp ä¼šè¿”å›ä» op å¼€å§‹èƒ½æ‰¾åˆ°çš„æœ€é•¿/æœ€ä¼˜çš„åŒ¹é…æ¨¡å¼çš„æœ«ç«¯èŠ‚ç‚¹ (terminalNode).</li>
</ol>
<ul>
<li>å¦‚æœå…¶ output åˆ—è¡¨ä¸ä¸ºç©ºï¼Œè¯´æ˜ searchOp æˆåŠŸåœ°æ‰¾åˆ°äº†ä¸€æ¡å®Œæ•´çš„åŒ¹é…è·¯å¾„ã€‚å‡½æ•°å°±ä¼šå°†è¿™ä¸ªåŒ¹é…ç»“æœè®°å½•ä¸‹æ¥ï¼šåœ¨ manager ä¸­æ›´æ–° Pattern å¯¹è±¡ï¼Œå¹¶åœ¨æœ¬åœ°çš„ result map ä¸­å»ºç«‹ä»èµ·å§‹ç®—å­ opåˆ°æ¨¡å¼IDçš„æ˜ å°„ã€‚</li>
<li>åä¹‹è¯´æ˜ä» op å¼€å§‹æ— æ³•åŒ¹é…ä»»ä½•å®Œæ•´çš„æ¨¡å¼ï¼Œäºæ˜¯å°±ä»€ä¹ˆä¹Ÿä¸åšï¼Œç»§ç»­æ£€æŸ¥ä¸‹ä¸€ä¸ªç®—å­ã€‚</li>
</ul>
<details class="custom-details">
    <summary class="custom-summary">search Implementation</summary>
    <div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Automation</span><span class="o">::</span><span class="n">search</span><span class="p">(</span><span class="n">tx8e</span><span class="o">::</span><span class="n">SubgraphOp</span> <span class="n">subgraph</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// k: the starting operation of a matched pattern
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// v: the type/ID of the matched pattern
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">Operation</span><span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">manager_</span><span class="o">-&gt;</span><span class="n">initDefsMap</span><span class="p">(</span><span class="n">subgraph</span><span class="p">);</span> <span class="c1">// Initialize manager with definition information from the subgraph.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">subgraph</span><span class="o">-&gt;</span><span class="n">walk</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">Operation</span><span class="o">*</span> <span class="n">op</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// First pass: walk through the subgraph to gather metadata.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">manager_</span><span class="o">-&gt;</span><span class="n">opOrder_</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">op</span><span class="p">);</span> <span class="c1">// Record the sequential order of all operations.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">manager_</span><span class="o">-&gt;</span><span class="n">opIndexMap_</span><span class="p">[</span><span class="n">op</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span><span class="o">++</span><span class="p">;</span> <span class="c1">// Assign a unique index to each operation.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Second pass: walk through the subgraph again to perform the actual pattern matching.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">subgraph</span><span class="o">-&gt;</span><span class="n">walk</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">Operation</span><span class="o">*</span> <span class="n">op</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Skip the return operation of the subgraph as it&#39;s not part of a computational pattern.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">isa</span><span class="o">&lt;</span><span class="n">tx8e</span><span class="o">::</span><span class="n">SubgraphOp</span><span class="p">,</span> <span class="n">tx8e</span><span class="o">::</span><span class="n">SubgraphReturnOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">op</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">WalkResult</span><span class="o">::</span><span class="n">skip</span><span class="p">();</span> <span class="c1">// In newer MLIR, this might be `return;`. Skips processing this op&#39;s children.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">auto</span> <span class="n">pattern</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Pattern</span><span class="o">&gt;</span><span class="p">(</span><span class="n">op</span><span class="p">);</span> <span class="c1">// Create a Pattern object, representing a potential match starting at `op`.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">manager_</span><span class="o">-&gt;</span><span class="n">patterns_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">pattern</span><span class="p">);</span> <span class="c1">// Add this potential pattern to the manager&#39;s list.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">manager_</span><span class="o">-&gt;</span><span class="n">patternMap_</span><span class="p">[</span><span class="n">op</span><span class="p">]</span> <span class="o">=</span> <span class="n">pattern</span><span class="p">;</span> <span class="c1">// Map the operation `op` to its corresponding Pattern object.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="c1">// terminalNode å°±æ˜¯æœ€ååŒ¹é…åˆ°çš„ä¸€ä¸ªNode (terminalNode is the final matched Node)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// This is the main call to the recursive search function, starting from the Trie root for each `op`.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">auto</span> <span class="n">terminalNode</span> <span class="o">=</span> <span class="n">searchOp</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">op</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// If the Node has an output, it means a match was found. If multiple matches exist, they are replaced based on priority during the search phase
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// The final result is a match for the highest-priority pattern
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">terminalNode</span><span class="o">-&gt;</span><span class="n">output</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// Check if the search returned a valid pattern-terminating node.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// If a match was found, update the Pattern object with the results from the terminal node.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">pattern</span><span class="o">-&gt;</span><span class="n">setPattern</span><span class="p">(</span><span class="n">terminalNode</span><span class="o">-&gt;</span><span class="n">output</span><span class="p">.</span><span class="n">front</span><span class="p">(),</span> <span class="n">terminalNode</span><span class="o">-&gt;</span><span class="n">pattern</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// Record the result: map the starting operation `op` to the matched pattern&#39;s ID.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">result</span><span class="p">[</span><span class="n">op</span><span class="p">]</span> <span class="o">=</span> <span class="n">terminalNode</span><span class="o">-&gt;</span><span class="n">output</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">WalkResult</span><span class="o">::</span><span class="n">advance</span><span class="p">();</span> <span class="c1">// Proceed to the next operation in the walk.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div></div>
</details><br>
<h2 id="groupoptimizationpass">GroupOptimizationPass<a hidden class="anchor" aria-hidden="true" href="#groupoptimizationpass">#</a></h2>
<p>ä¼šéå†ä¸€ä¸ªè®¡ç®— subGraph ä¸­çš„æ‰€æœ‰ OP. å¯¹äºæ¯ä¸€ä¸ªé€šè¿‡ç­›é€‰çš„æ™®é€šè®¡ç®—æ“ä½œï¼Œä¼šè°ƒç”¨ <code>createSingleGroup</code> å‡½æ•°æ¥ä¸ºå…¶åˆ›å»ºä¸€ä¸ªä¸“å±çš„ GroupOp.
<code>createSingleGroup</code> ä¼šæ£€æŸ¥åŸå§‹ OP çš„æ‰€æœ‰è¾“å…¥ã€‚å¦‚æœè¾“å…¥æ¥è‡ªå¦ä¸€ä¸ªè®¡ç®—æ“ä½œï¼Œé‚£ä¹ˆè¿™ä¸ªè¾“å…¥å°±ä¼šæˆä¸ºæ–° GroupOp çš„è¾“å…¥ã€‚å¦‚æœè¾“å…¥æ˜¯ LoadConstOpï¼Œåˆ™è¢«è§†ä¸ºè¿™ä¸ªåˆ†ç»„çš„å†…éƒ¨ä¾èµ–ï¼Œè€Œä¸æ˜¯å¤–éƒ¨è¾“å…¥ã€‚åŸå§‹ op çš„æ‰€æœ‰è¾“å‡ºä¼šç›´æ¥æˆä¸ºæ–° GroupOp çš„è¾“å‡ºã€‚</p>
<p>æ–°çš„ GroupOp æ‹¥æœ‰ä¸Šä¸€æ­¥å®šä¹‰çš„è¾“å…¥å’Œè¾“å‡ºã€‚åŸå§‹çš„æ“ä½œ op å’Œå®ƒçš„å¸¸é‡ä¾èµ– (dependencies) è¢«ç§»åŠ¨åˆ°è¿™ä¸ªæ–°åˆ›å»ºçš„ GroupOp å†…éƒ¨ã€‚æœ€åï¼Œä¿®æ”¹åŸå§‹æ“ä½œ OP çš„è¿æ¥å…³ç³»ï¼Œä½¿å…¶åœ¨åˆ†ç»„å†…éƒ¨èƒ½å¤Ÿæ­£ç¡®åœ°æ¥æ”¶è¾“å…¥å¹¶äº§ç”Ÿè¾“å‡ºã€‚ä¼ªä»£ç å¦‚ä¸‹</p>
<pre tabindex="0"><code>for op in subGraph.ops:

  // æ£€æŸ¥æ“ä½œçš„ç±»å‹
  if op == (GroupOp || ReturnOp || LoadConstOp || NoneOp):
    continue

  createSingleGroup(op)

------------------------------------
createSingleGroup(op):
  for pre_op in op.inputsOp:
    // åˆ¤æ–­å‰ç½®æ“ä½œæ˜¯å¦ä¸ºâ€œåŠ è½½å¸¸é‡â€æˆ–â€œç©ºæ“ä½œâ€
    if pre_op == (LoadConstOp || NoneOp):
      // å¦‚æœæ˜¯ï¼Œåˆ™å°†å…¶æ·»åŠ åˆ°ä¾èµ–é¡¹ (dependencies) é›†åˆä¸­
      dependencies.add(pre_op)
    else:
      // å¦‚æœæ˜¯å…¶ä»–æ™®é€šæ“ä½œï¼Œåˆ™å°†å…¶ç»“æœæ·»åŠ åˆ°æ–°åˆ†ç»„çš„è¾“å…¥ (groupInput) ä¸­
      groupInput.add(pre_op.result)

  for result in op.results:  // éå†å½“å‰æ“ä½œçš„æ‰€æœ‰è¾“å‡ºç»“æœ
    // å°†è¿™äº›ç»“æœæ·»åŠ åˆ°æ–°åˆ†ç»„çš„è¾“å‡º (groupOutput) ä¸­
    groupOutput.add(result)

  // ä½¿ç”¨æ”¶é›†å¥½çš„è¾“å…¥å’Œè¾“å‡ºåˆ›å»ºä¸€ä¸ªæ–°çš„ GroupOp (åˆ†ç»„æ“ä½œ) 
  create GroupOp(groupInput, groupOutput)

  // å°†ä¾èµ–é¡¹ (å¦‚å¸¸é‡) ç§»åŠ¨åˆ°æ–°åˆ†ç»„çš„æœ«å°¾ (æˆ–å†…éƒ¨) 
  move dependencies to group end

  // å°†åŸå§‹æ“ä½œ op æœ¬èº«ä¹Ÿç§»åŠ¨åˆ°æ–°åˆ†ç»„çš„æœ«å°¾ (æˆ–å†…éƒ¨) 
  move op to group end

  // ä¿®æ”¹åŸå§‹æ“ä½œ op çš„è¾“å…¥å’Œè¾“å‡ºï¼Œä½¿å…¶åœ¨æ–°åˆ†ç»„å†…éƒ¨æ­£ç¡®è¿æ¥
  change op input and output
</code></pre><p>
<figure class="post-figure">
    <a href="https://share.note.youdao.com/yws/api/personal/file/WEBca62e625dd418d0b51deb2e46c83f873?method=download&amp;shareKey=3b9dddfeca5108a0665fce242dd1019d" target="_blank" rel="noopener">
        <img loading="lazy" src="https://share.note.youdao.com/yws/api/personal/file/WEBca62e625dd418d0b51deb2e46c83f873?method=download&amp;shareKey=3b9dddfeca5108a0665fce242dd1019d" alt="GroupOptimizationPass">
    </a><figcaption>GroupOptimizationPass</figcaption></figure></p>
<h2 id="groupldstpass">GroupLdStPass<a hidden class="anchor" aria-hidden="true" href="#groupldstpass">#</a></h2>
<p><code>GroupLdStPass</code> ä½œç”¨ç”¨æ˜¯å¤„ç† GroupOp çš„è¾“å…¥å’Œè¾“å‡ºï¼Œé€šè¿‡æ˜¾å¼æ’å…¥ Load å’Œ Store æ“ä½œï¼Œæ¥â€œå›ºåŒ–â€å’Œâ€œéš”ç¦»â€GroupOp çš„è¾¹ç•Œã€‚</p>
<p>Load æ’å…¥æµç¨‹</p>
<ol>
<li>è¯†åˆ« Load éœ€æ±‚: å‡½æ•°éå† GroupOp çš„æ¯ä¸€ä¸ªè¾“å…¥å‚æ•°vã€‚ç„¶åï¼Œå®ƒæŸ¥æ‰¾æ‰€æœ‰åœ¨ GroupOp å¤–éƒ¨ä½¿ç”¨ v çš„ç®—å­ (userOp) ã€‚é€šè¿‡æ£€æŸ¥è¿™äº›userOpçš„å±æ€§ (needLoad) ï¼Œå®ƒåˆ¤æ–­å“ªäº› userOp éœ€è¦ä¸€ä¸ªæ˜¾å¼çš„ Load æ“ä½œæ¥è·å– v çš„å€¼ã€‚</li>
<li>å¤„ç†ç‰¹æ®Šå¸ƒå±€: ä»£ç ä¸­æœ‰ä¸€æ®µç‰¹æ®Šçš„é€»è¾‘ (<code>if(isa&lt;...&gt;)</code>) ï¼Œç”¨äºå¤„ç† Addã€Sub ç­‰äºŒå…ƒç®—å­ã€‚å®ƒæ£€æŸ¥è¾“å…¥çš„layout å¦‚æœå­˜åœ¨ä¸åŒ¹é…çš„æƒ…å†µ (ä¾‹å¦‚ä¸€ä¸ªNCxå¸ƒå±€å’Œä¸€ä¸ªTensorå¸ƒå±€) ï¼Œå®ƒå¯èƒ½ä¼šå¼ºåˆ¶layoutç»Ÿä¸€ï¼Œä»¥ç¡®ä¿ç¡¬ä»¶èƒ½å¤Ÿæ­£ç¡®è®¡ç®—ã€‚</li>
<li>æ’å…¥ LoadVarOp: åœ¨ç¡®å®šäº†æ‰€æœ‰éœ€è¦ Load çš„å¤–éƒ¨ç”¨æˆ·åï¼Œå¦‚æœè¿™æ ·çš„ç”¨æˆ·å­˜åœ¨ (<code>usersLoad.size() != 0</code>)ï¼Œå®ƒä¼šåœ¨GroupOpçš„å…¥å£å¤„åˆ›å»ºä¸€ä¸ªtx8e::LoadVarOpæ“ä½œã€‚</li>
<li>é‡å®šå‘æ•°æ®æµ: å°†æ‰€æœ‰å¤–éƒ¨ç”¨æˆ·å¯¹åŸå§‹è¾“å…¥ v çš„è¿æ¥ (SSA use-def chain) ï¼Œå…¨éƒ¨æ–­å¼€ï¼Œå¹¶é‡æ–°è¿æ¥åˆ°æ–°åˆ›å»ºçš„LoadVarOpçš„è¾“å‡ºä¸Š (replaceUsesOfWith).</li>
</ol>
<p>Store æ’å…¥æµç¨‹</p>
<ol>
<li>è¯†åˆ«å­˜å‚¨éœ€æ±‚: å‡½æ•°æ‰¾åˆ° GroupOp å†…éƒ¨çš„ return æ“ä½œï¼Œå¹¶éå†å®ƒçš„æ¯ä¸€ä¸ªæ“ä½œæ•° (å³ GroupOp çš„è¾“å‡ºå€¼). é€šè¿‡æ£€æŸ¥äº§ç”Ÿè¿™äº›è¾“å‡ºå€¼çš„å†…éƒ¨ç®—å­ (pre_op) çš„needStoreå±æ€§ï¼Œæ¥åˆ¤æ–­å“ªäº›è¾“å‡ºéœ€è¦è¢«æ˜¾å¼åœ°Storeï¼Œä»¥ä¾¿å¤–éƒ¨ä¸–ç•Œèƒ½å¤Ÿè®¿é—®ã€‚</li>
<li>æ’å…¥ StoreVarOp: å¦‚æœä¸€ä¸ªè¾“å‡ºå€¼éœ€è¦è¢«å­˜å‚¨ï¼Œå‡½æ•°ä¼šåœ¨ GroupOp çš„æœ«å°¾ã€return æ“ä½œä¹‹å‰ï¼Œåˆ›å»ºä¸€ä¸ªtx8e::StoreVarOp æ¥æ”¶ GroupOp çš„å†…éƒ¨è®¡ç®—ç»“æœã€‚</li>
<li>æ›´æ–°è¿”å›ç»“æœ: StoreVarOpæœ¬èº«ä¹Ÿæœ‰ä¸€ä¸ªè¾“å‡ºã€‚å‡½æ•°ä¼šæ›´æ–° GroupOp çš„ return æ“ä½œï¼Œä½¿å…¶è¿”å› StoreVarOp çš„è¾“å‡ºï¼Œè€Œä¸æ˜¯åŸå§‹çš„å†…éƒ¨è®¡ç®—ç»“æœã€‚</li>
</ol>
<details class="custom-details">
    <summary class="custom-summary">GroupLdStPass Implementation</summary>
    <div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">GroupLdStPass</span><span class="o">::</span><span class="n">runOnOperation</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">subgraph</span><span class="p">.</span><span class="n">walk</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">tx8e</span><span class="o">::</span><span class="n">GroupOp</span> <span class="n">g_op</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//  For each group&#39;s input, insert a load. If used by multiple ops, multiple loads are inserted
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">v</span> <span class="p">:</span> <span class="n">g_op</span><span class="p">.</span><span class="n">getBody</span><span class="p">().</span><span class="n">front</span><span class="p">().</span><span class="n">getArguments</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// Iterate over each input argument of the group.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Operation</span><span class="o">*</span> <span class="n">pre_op</span> <span class="o">=</span> <span class="n">getValidDefiningOp</span><span class="p">(</span><span class="n">v</span><span class="p">);</span> <span class="c1">// Find the operation that produces this input.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">Operation</span><span class="o">*</span><span class="p">,</span> <span class="kt">int32_t</span><span class="o">&gt;</span> <span class="n">usersLoad</span><span class="p">;</span> <span class="c1">// A map to store users that need to load this input.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">userOp</span> <span class="p">:</span> <span class="n">v</span><span class="p">.</span><span class="n">getUsers</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// Find all users of this input argument.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// Check if the user needs a &#39;load&#39; based on its attributes.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">opAttr</span><span class="p">.</span><span class="n">needLoad</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">arg_idx</span><span class="p">)))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// If a load is needed, record the user and its argument index.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">usersLoad</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">userOp</span><span class="p">,</span> <span class="n">arg_idx</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          <span class="c1">// This block handles complex layout logic for Add/Sub/Mul/Div ops.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="c1">// It seems to ensure that if one input to &#39;add&#39; is rank1 tensor, the other is also handled correctly,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="c1">// potentially by forcing a specific layout (`LayoutMode::Cx`).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="k">if</span> <span class="p">(</span><span class="n">isa</span><span class="o">&lt;</span><span class="n">tx8e</span><span class="o">::</span><span class="n">AddOp</span><span class="p">,</span> <span class="n">tx8e</span><span class="o">::</span><span class="n">SubOp</span><span class="p">,</span> <span class="n">tx8e</span><span class="o">::</span><span class="n">DivOp</span><span class="p">,</span> <span class="n">tx8e</span><span class="o">::</span><span class="n">MulOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">userOp</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">              <span class="c1">// ... [å¤æ‚å¸ƒå±€é€»è¾‘]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="p">}</span>
</span></span><span class="line"><span class="cl">          
</span></span><span class="line"><span class="cl">          <span class="k">if</span> <span class="p">(</span><span class="n">usersLoad</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// there are users that require a load operation.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>              <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">NamedAttribute</span><span class="o">&gt;</span> <span class="n">tmp_attrs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">              <span class="c1">// ... [æ„å»ºLoadVarOpçš„å±æ€§]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>              <span class="c1">// Create the Load operation.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>              <span class="k">auto</span> <span class="n">ld</span> <span class="o">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">create</span><span class="o">&lt;</span><span class="n">tx8e</span><span class="o">::</span><span class="n">LoadVarOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">g_op</span><span class="p">.</span><span class="n">getLoc</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">getType</span><span class="p">(),</span> <span class="n">v</span><span class="p">,</span> <span class="n">tmp_attrs</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">              <span class="c1">// ... [è®¾ç½®åŠ¨æ€shapeå±æ€§]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>              
</span></span><span class="line"><span class="cl">              <span class="c1">// For each user that needs the load...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>              <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">userOp</span> <span class="p">:</span> <span class="n">usersLoad</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                  <span class="c1">// ...replace its use of the original input `v` with the result of the new `Load` operation `ld`.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                  <span class="n">userOp</span><span class="p">.</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">replaceUsesOfWith</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">ld</span><span class="p">.</span><span class="n">getOutput</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">              <span class="p">}</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1">// For each group&#39;s output, insert a store
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">builder</span><span class="p">.</span><span class="n">setInsertionPointToEnd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">);</span> <span class="c1">// Set the insertion point to the end of the group&#39;s body.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">Operation</span> <span class="o">*</span><span class="n">g_return</span> <span class="o">=</span> <span class="n">g_op</span><span class="p">.</span><span class="n">getBody</span><span class="p">().</span><span class="n">front</span><span class="p">().</span><span class="n">getTerminator</span><span class="p">();</span> <span class="c1">// Get the return operation of the group.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">g_return</span><span class="o">-&gt;</span><span class="n">getNumOperands</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Iterate over each output of the group.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="k">auto</span> <span class="n">value</span> <span class="o">=</span> <span class="n">g_return</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="k">auto</span> <span class="n">pre_op</span> <span class="o">=</span> <span class="n">value</span><span class="p">.</span><span class="n">getDefiningOp</span><span class="p">();</span> <span class="c1">// Find the operation inside the group that produces this output.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="c1">// Check if this output value needs to be stored for external users.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">tx8e</span><span class="o">::</span><span class="n">OpLibInterface</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pre_op</span><span class="p">)).</span><span class="n">queryOpAttr</span><span class="p">().</span><span class="n">needStore</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">              <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          <span class="c1">// ... [æ„å»ºStoreVarOpçš„å±æ€§]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="c1">// Create the Store operation.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="k">auto</span> <span class="n">st</span> <span class="o">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">create</span><span class="o">&lt;</span><span class="n">tx8e</span><span class="o">::</span><span class="n">StoreVarOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">g_op</span><span class="p">.</span><span class="n">getLoc</span><span class="p">(),</span> <span class="n">value</span><span class="p">.</span><span class="n">getType</span><span class="p">(),</span> <span class="n">value</span><span class="p">,</span> <span class="n">st_attrs</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="c1">// ... [è®¾ç½®åŠ¨æ€shapeå±æ€§]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">          <span class="c1">// Update the group&#39;s return instruction to return the result of the store op.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">g_return</span><span class="o">-&gt;</span><span class="n">setOperand</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">st</span><span class="p">.</span><span class="n">getOutput</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">g_return</span><span class="o">-&gt;</span><span class="n">moveBefore</span><span class="p">(</span><span class="n">gBlock</span><span class="p">,</span> <span class="n">block</span><span class="p">.</span><span class="n">end</span><span class="p">());</span> <span class="c1">// Move the return instruction (not standard MLIR, might be custom logic).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">updateIR</span><span class="p">(</span><span class="n">g_op</span><span class="p">);</span> <span class="c1">// Update the IR of the group op.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div></div>
</details><br>
<h2 id="groupmappingpass">GroupMappingPass<a hidden class="anchor" aria-hidden="true" href="#groupmappingpass">#</a></h2>
<p><code>GroupMappingPass</code> ä½œç”¨æ˜¯å°†é¡¶å±‚æ¨¡å— (Module) ä¸­å®šä¹‰çš„å…¨å±€ç»´åº¦ä¿¡æ¯ (x_dim å’Œ y_dim) è®¾ç½®åˆ°æ¯ä¸€ä¸ª GroupOp æˆ– GroupOp çš„è°ƒç”¨ç‚¹ä¸Šã€‚</p>
<details class="custom-details">
    <summary class="custom-summary">GroupMappingPass Implementation</summary>
    <div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// Defines a function to perform a simple mapping of groups.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">simpleGroupMapping</span><span class="p">(</span><span class="n">ModuleOp</span> <span class="n">module</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Get x and y dimension from the module&#39;s attributes.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// These attributes are likely defined globally for the entire compilation.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint32_t</span> <span class="n">x_dim</span> <span class="o">=</span> <span class="n">module</span><span class="o">-&gt;</span><span class="n">getAttrOfType</span><span class="o">&lt;</span><span class="n">IntegerAttr</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tx8e</span><span class="o">::</span><span class="n">ModuleAttr</span><span class="o">::</span><span class="n">TileDx</span><span class="p">).</span><span class="n">getInt</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="kt">uint32_t</span> <span class="n">y_dim</span> <span class="o">=</span> <span class="n">module</span><span class="o">-&gt;</span><span class="n">getAttrOfType</span><span class="o">&lt;</span><span class="n">IntegerAttr</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tx8e</span><span class="o">::</span><span class="n">ModuleAttr</span><span class="o">::</span><span class="n">TileDy</span><span class="p">).</span><span class="n">getInt</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Create an OpBuilder instance, which is a helper to create/modify MLIR operations.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">OpBuilder</span> <span class="n">builder</span><span class="p">(</span><span class="n">module</span><span class="p">.</span><span class="n">getContext</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Get the &#39;main&#39; function from the module.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">func</span><span class="o">::</span><span class="n">FuncOp</span> <span class="n">main</span> <span class="o">=</span> <span class="n">module</span><span class="p">.</span><span class="n">getMainFuncOp</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Get the first block (entry block) of the main function.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">auto</span><span class="o">&amp;</span> <span class="n">main_block</span> <span class="o">=</span> <span class="n">main</span><span class="p">.</span><span class="n">getBody</span><span class="p">().</span><span class="n">front</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">inner</span> <span class="p">:</span> <span class="n">main_block</span><span class="p">.</span><span class="n">getOperations</span><span class="p">())</span> <span class="p">{</span>  <span class="c1">// Iterate over all operations within the main function&#39;s body
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">isa</span><span class="o">&lt;</span><span class="n">tx8e</span><span class="o">::</span><span class="n">CallOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">inner</span><span class="p">))</span> <span class="p">{</span>  <span class="c1">// The module&#39;s main function contains CallOps. This implies an indirect call to a subgraph.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// Find the subgraph definition (&#39;SubraphOp&#39;) using the symbol name from the CallOp.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">tx8e</span><span class="o">::</span><span class="n">SubgraphOp</span> <span class="n">sg</span> <span class="o">=</span> <span class="n">module</span><span class="p">.</span><span class="n">lookupSymbol</span><span class="o">&lt;</span><span class="n">tx8e</span><span class="o">::</span><span class="n">SubgraphOp</span><span class="o">&gt;</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">          <span class="n">llvm</span><span class="o">::</span><span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">tx8e</span><span class="o">::</span><span class="n">CallOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">inner</span><span class="p">).</span><span class="n">getCallee</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">      
</span></span><span class="line"><span class="cl">      <span class="c1">// Walk through the operations inside the called subgraph.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// We are looking for the &#39;GroupOp&#39; which is the actual unit of computation.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">sg</span><span class="p">.</span><span class="n">walk</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">tx8e</span><span class="o">::</span><span class="n">GroupOp</span> <span class="n">gop</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Set a &#39;dev_region&#39; attribute on the located GroupOp.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">setDevRegionAttr</span><span class="p">(</span><span class="n">builder</span><span class="p">,</span> <span class="n">module</span><span class="p">.</span><span class="n">getContext</span><span class="p">(),</span> <span class="n">gop</span><span class="p">.</span><span class="n">getOperation</span><span class="p">(),</span> <span class="n">x_dim</span><span class="p">,</span> <span class="n">y_dim</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">isa</span><span class="o">&lt;</span><span class="n">tx8e</span><span class="o">::</span><span class="n">GroupOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">inner</span><span class="p">))</span> <span class="p">{</span>  <span class="c1">// The module&#39;s main function directly contains GroupOps.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// Directly set the &#39;dev_region&#39; attribute on the GroupOp found in the main function.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">setDevRegionAttr</span><span class="p">(</span><span class="n">builder</span><span class="p">,</span> <span class="n">module</span><span class="p">.</span><span class="n">getContext</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">                       <span class="n">llvm</span><span class="o">::</span><span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">tx8e</span><span class="o">::</span><span class="n">GroupOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">inner</span><span class="p">).</span><span class="n">getOperation</span><span class="p">(),</span> <span class="n">x_dim</span><span class="p">,</span> <span class="n">y_dim</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">GroupMappingPass</span><span class="o">::</span><span class="n">runOnOperation</span><span class="p">()</span> <span class="p">{</span>  <span class="c1">// It will operate on the entire ModuleOp.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">auto</span> <span class="n">module</span> <span class="o">=</span> <span class="n">getOperation</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">simpleGroupMapping</span><span class="p">(</span><span class="n">module</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div></div>
</details><br>
<h2 id="groupcostpass">GroupCostPass<a hidden class="anchor" aria-hidden="true" href="#groupcostpass">#</a></h2>
<p><code>GroupCostPass</code> ä½œç”¨æ˜¯ä¸ºä¸€ä¸ª GroupOp åœ¨æ‰€æœ‰å¯èƒ½çš„åˆ‡åˆ†ç­–ç•¥ä¸­ï¼Œé€šè¿‡ Cost Model æœç´¢å¹¶åº”ç”¨æœ€ä¼˜çš„ä¸€ä¸ªã€‚ç®—æ³•æµç¨‹å¦‚ä¸‹ã€‚</p>
<p>å‡†å¤‡é˜¶æ®µ (Preparation):</p>
<ol>
<li>Bailout Condition: <code>if (gop-&gt;hasAttr(&quot;group_tag&quot;) &amp;&amp; ... == 2) return;</code> å¦‚æœ GroupOpçš„ <code>group_tag==2</code>ï¼Œé‚£ä¹ˆè¿™ä¸ª Pass å°±æ— éœ€ä¸ºå®ƒæœç´¢åˆ‡åˆ†ç­–ç•¥äº†ï¼Œç›´æ¥è¿”å›ã€‚</li>
<li>æ‹·è´ç¼–è¯‘é€‰é¡¹: <code>costoption_lg.dynCompile = compileOption_-&gt;dynCompile;</code> ä»ä¸€ä¸ªå…¨å±€çš„<code>compileOption_</code> ä¸­æ‹·è´äº†ä¸€ç³»åˆ—ç¼–è¯‘å‚æ•°åˆ°å±€éƒ¨çš„ costoption_lg ä¸­. è¡¨æ˜ Pass çš„è¡Œä¸ºå¯ä»¥è¢«å¤–éƒ¨é…ç½®æ‰€å½±å“ã€‚</li>
<li>åˆ›å»ºæœç´¢ç©ºé—´: <code>auto space = std::make_shared&lt;SliceSpace&gt;();</code> åˆ›å»ºäº†ä¸€ä¸ªåä¸º space çš„å¯¹è±¡ï¼Œè¿™ä¸ª SliceSpace ç±»å°è£…äº†è¯¥ GroupOp çš„å®Œæ•´æœç´¢ç©ºé—´ã€‚å®ƒåŒ…å«äº†æ‰€æœ‰å¯èƒ½çš„å¼ é‡åˆ‡åˆ†æ–¹å¼ã€‚</li>
<li>æ¨¡æ¿æœºåˆ¶: <code>if (useTemplate) { ... }</code> æ£€æŸ¥ <code>compileOption_-&gt;sliceHelpMap</code> çš„å…¨å±€æ˜ å°„ã€‚å¦‚æœä¹‹å‰å·²ç»ä¸ºç›¸ä¼¼çš„ GroupOp (ç”± GroupKey æ ‡è¯†) è®¡ç®—è¿‡æœ€ä¼˜ç­–ç•¥ï¼Œå®ƒå°±ä¼šç›´æ¥ä»ç¼“å­˜ä¸­è¯»å–ç»“æœ (sliceHelp) ï¼Œä»è€Œé¿å…æ˜‚è´µçš„é‡å¤æœç´¢ã€‚å¦‚æœæ‰¾åˆ°äº†æ¨¡æ¿ï¼Œå®ƒä¼šç›´æ¥åº”ç”¨å¹¶æå‰è¿”å›ã€‚</li>
</ol>
<p>æœè¿­ä»£æœç´¢å¾ªç¯ (The Core: Iterative Search Loop)</p>
<ol>
<li><code>while (1)</code> å¾ªç¯: è¿™ä¸ªæ— é™å¾ªç¯æ˜¯æœç´¢ç®—æ³•çš„ä¸»ä½“ã€‚</li>
<li>æ¢ç´¢ç­–ç•¥: åœ¨å¾ªç¯å†…éƒ¨ï¼Œspaceå¯¹è±¡ä¼šç”Ÿæˆä¸€ä¸ªå€™é€‰çš„åˆ‡åˆ†ç­–ç•¥ã€‚è¿™é€šè¿‡ <code>space-&gt;shardingLevel</code> å’Œ<code>space-&gt;factorSpace_</code> æ¥æ§åˆ¶ï¼Œå®ƒä»¬å…±åŒå®šä¹‰äº†å½“å‰æ­£åœ¨å°è¯•çš„åˆ‡åˆ†ç»´åº¦å’Œæ–¹å¼ã€‚</li>
<li>åˆ¤æ–­æœç´¢æ˜¯å¦å®Œæˆ: <code>if (space-&gt;shardingLevel.isSpaceFinish() &amp;&amp; ...)</code>. åœ¨æ¯æ¬¡è¿­ä»£å¼€å§‹æ—¶ï¼Œå®ƒä¼šæ£€æŸ¥æ˜¯å¦å·²ç»éå†äº†æ‰€æœ‰çš„åˆ‡åˆ†å¯èƒ½æ€§ã€‚å¦‚æœæœç´¢ç©ºé—´å·²è€—å°½ï¼Œå¾ªç¯å°±ä¼šç»ˆæ­¢ã€‚</li>
<li>æˆæœ¬ä¼°ç®—: å¦‚æœæ‰¾åˆ°ä¸€ä¸ªæœ‰æ•ˆçš„å€™é€‰ç­–ç•¥ï¼Œæ¥ä¸‹æ¥å°±æ˜¯ä¼°ç®—è¿™ä¸ªç­–ç•¥çš„æˆæœ¬ã€‚åŠ¨æ€æ„å»ºPassæµæ°´çº¿:</li>
</ol>
<ul>
<li><code>auto pm = std::make_unique&lt;LgPassManager&gt;(...);</code> æ·»åŠ ä¸€ç³»åˆ—ä¼°ç®—Pass:
<ul>
<li><code>pm-&gt;add_pass(createDataSplitNewPass(space));</code> // æ ¹æ®ç­–ç•¥è¿›è¡Œæ•°æ®åˆ‡åˆ†</li>
<li><code>pm-&gt;add_pass(createTimeStepNewPass(space));</code> // åˆ’åˆ†æ—¶é—´æ­¥</li>
<li><code>pm-&gt;add_pass(createSPMAllocPass(space));</code>    // æ¨¡æ‹ŸSPM (ç‰‡ä¸Šå†…å­˜) åˆ†é…</li>
<li><code>pm-&gt;add_pass(createEstimatePass(space));</code>    // ä¼°ç®—æ€§èƒ½/æˆæœ¬</li>
</ul>
</li>
<li>è¿è¡Œä¼°ç®—æµç¨‹: <code>pm-&gt;run(gop);</code></li>
</ul>
<ol start="5">
<li>æ¯”è¾ƒå’Œé€‰æ‹©æœ€ä¼˜è§£: ä¼°ç®—å®Œæˆåï¼Œ<code>space-&gt;status</code> ä¼šè¢«æ›´æ–° (SSTATUS_OK è¡¨ç¤ºä¼°ç®—æˆåŠŸï¼ŒSSTATUS_SA_MemAlloc è¡¨ç¤ºå†…å­˜åˆ†é…å¤±è´¥) . å¦‚æœä¼°ç®—æˆåŠŸï¼Œå®ƒä¼šè·å–æˆæœ¬ tï¼Œå¹¶ä¸å·²çŸ¥çš„ bestCost è¿›è¡Œæ¯”è¾ƒã€‚å¦‚æœå½“å‰ç­–ç•¥æ›´ä¼˜ï¼Œå°±æ›´æ–° bestCost å’Œ bestStrategyã€‚</li>
</ol>
<p>åº”ç”¨æœ€ä¼˜ç­–ç•¥ (Applying the Best Strategy)</p>
<ol>
<li>åº”ç”¨ç­–ç•¥: <code>sliceHelp.strategy = space-&gt;strategy;</code> å’Œåç»­çš„ <code>compileOption_-&gt;IRHelp.ops[gop] = space-&gt;stageOps;</code> ç­‰èµ‹å€¼æ“ä½œï¼Œå°±æ˜¯å°†æœç´¢åˆ°çš„æœ€ä¼˜ç­–ç•¥ç»“æœ (åŒ…æ‹¬æ¯ä¸ªæ“ä½œçš„åˆ‡åˆ†æ–¹å¼ã€å¾ªç¯ä¿¡æ¯ç­‰) ä¿å­˜åˆ° compileOption_ä¸­ï¼Œä¾›åç»­çš„ Pass ä½¿ç”¨ã€‚</li>
<li>å…·ä½“è®¡ç®—: <code>gop-&gt;walk(...)</code> å®ƒéå† GroupOp å†…éƒ¨çš„æ“ä½œ (å¦‚GemmOp) ï¼Œå¹¶æ ¹æ®ç­–ç•¥ (lSharding, rSharding) è®¡ç®—å‡ºå…·ä½“çš„å¾ªç¯è¾¹ç•Œ (ls, rs) å’Œåˆ†ç‰‡é•¿åº¦ (pLen) ï¼Œè¿™äº›ä¿¡æ¯ä¼šè¢«å­˜å…¥ gls (<code>GroupLoopSpace</code>) å¯¹è±¡ä¸­ã€‚</li>
</ol>
<h3 id="datasplitnewpass">DataSplitNewPass<a hidden class="anchor" aria-hidden="true" href="#datasplitnewpass">#</a></h3>
<p>å…¶ä¸­ä¹ŸåŒ…æ‹¬å¥½å‡ ä¸ª pass
<code>DS_SpaceInitPass</code> ä½œç”¨æ˜¯åˆå§‹åŒ–åˆ†å¸ƒå¼ç­–ç•¥çš„æœç´¢ç©ºé—´ã€‚å¯¹ groupOp ä¸­çš„æ¯ä¸€ä¸ªç®—å­ï¼Œå®ƒä¼šè°ƒç”¨ <code>space_-&gt;shardinglevel.init</code> è¿™ä¸ªå‡½æ•°ä¼šæ ¹æ®ç®—å­è‡ªèº«çš„ç‰¹æ€§ã€å…¨å±€çº¦æŸ (å¦‚ max_sharding) ä»¥åŠç”¨æˆ·é…ç½® (å¦‚ opt_search) ï¼Œç”Ÿæˆè¯¥ç®—å­æ‰€æœ‰å¯èƒ½çš„åˆ‡åˆ†æ–¹å¼ã€‚</p>
<p><code>init</code> å‡½æ•°é¦–å…ˆè·å–äº†ç®—å­çš„ç»´åº¦ dim å’Œç›®æ ‡åˆ‡åˆ†è·¯æ•° maxShardingï¼Œç„¶åè°ƒç”¨ getShardings æ‰¾å‡ºä¸€ä¸ªå¼ é‡åœ¨æ‰€æœ‰ç»´åº¦ä¸Šè¿›è¡Œæ•´æ•°å€åˆ‡åˆ†ã€ä¸”æ€»åˆ‡åˆ†è·¯æ•°æ°å¥½ç­‰äº maxSharding çš„æ‰€æœ‰ç»„åˆæ¥å¡«å…… shardings åˆ—è¡¨ã€‚éšåï¼Œå°†è¿™äº›ç»„åˆ (å¹¶é¢å¤–åŠ ä¸Šäº†ä¸åˆ‡åˆ†çš„æ–¹æ¡ˆ) åŒ…è£…æˆå¸¦æœ‰æ€§èƒ½è¯„ä¼°å› å­çš„ ShardingSpace å¯¹è±¡ï¼Œå¹¶å­˜å…¥ä¸€ä¸ªæœ‰åºé›†åˆ <code>std::set&lt;ShardingSpace&gt; spaces</code> ä¸­ã€‚ShardingSpace é‡è½½äº†å°äºæ“ä½œç¬¦ç”¨äºå¯¹åˆ‡åˆ†ç­–ç•¥æ’åºã€‚</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">ShardingSpace</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">ShardingInfo</span><span class="o">&gt;</span> <span class="n">shardings</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// é¢„ä¼°çš„æ€§èƒ½å‚æ•°ï¼Œå³ç©ºé—´ä¸Šèƒ½ç”¨åˆ°pow(2,x)ä¸ªtile
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint8_t</span> <span class="n">factor</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// å…³é”®ç‚¹ï¼šé‡è½½å°äºæ“ä½œç¬¦ï¼Œå®šä¹‰æ’åºè§„åˆ™
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">ShardingSpace</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// æ€§èƒ½é«˜çš„åœ¨å‰é¢
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">factor</span> <span class="o">&gt;</span> <span class="n">other</span><span class="p">.</span><span class="n">factor</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">ShardingSpace</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">factor</span> <span class="o">==</span> <span class="n">other</span><span class="p">.</span><span class="n">factor</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">ShardingLevel</span><span class="o">::</span><span class="n">init</span><span class="p">(</span><span class="n">mlir</span><span class="o">::</span><span class="n">Operation</span><span class="o">*</span> <span class="n">op</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">maxSharding</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">nFirst</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">opt_search</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ... æ¸…ç†å’Œå‡†å¤‡å·¥ä½œ ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  
</span></span><span class="line"><span class="cl">  <span class="c1">// 1. è·å–ç®—å­è¾“å‡ºTensorçš„ç»´åº¦æ•°é‡ (Rank) 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int32_t</span> <span class="n">dim</span> <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">getResult</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">getType</span><span class="p">().</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">ShapedType</span><span class="o">&gt;</span><span class="p">().</span><span class="n">getRank</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 2. å‡†å¤‡å®¹å™¨
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int32_t</span><span class="o">&gt;&gt;</span> <span class="n">shardings</span><span class="p">;</span> <span class="c1">// ç”¨äºæ¥æ”¶æ‰€æœ‰åˆæ³•çš„shardingæ–¹æ¡ˆ
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int32_t</span><span class="o">&gt;</span> <span class="n">tempSharding</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>   <span class="c1">// ä¸€ä¸ªä¸´æ—¶çš„ã€å¤§å°ä¸ºdimçš„å‘é‡ï¼Œç”¨äºé€’å½’
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 3. è°ƒç”¨æ ¸å¿ƒé€’å½’å‡½æ•°ï¼Œå¯åŠ¨æœç´¢
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//    - curDim=0: ä»ç¬¬0ç»´å¼€å§‹æœç´¢
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//    - allDim=dim: æ€»å…±æœ‰dimä¸ªç»´åº¦
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//    - curSharded=1: å½“å‰å·²ç´¯ä¹˜çš„åˆ‡åˆ†ç³»æ•°ä¸º1 (ä¹˜æ³•å•ä½å…ƒ) 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//    - maxSharding: æœ€å¤§åˆ‡åˆ†æ•°ç›®ï¼Œå³ä¸ºæ¯ä¸ª chip çš„ tile æ•°ç›® (16)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">getShardings</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">maxSharding</span><span class="p">,</span> <span class="n">shardings</span><span class="p">,</span> <span class="n">tempSharding</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 4. æ‰‹åŠ¨æ·»åŠ â€œä¸åˆ‡åˆ†â€çš„æ–¹æ¡ˆ
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//    é€’å½’å‡½æ•°åªä¼šå¯»æ‰¾ä¹˜ç§¯ç­‰äºmaxShardingçš„ç»„åˆï¼Œä½†[1, 1, ..., 1] (ä¸åˆ‡åˆ†)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//    æ˜¯ä¸€ä¸ªéå¸¸é‡è¦çš„åŸºç¡€æ–¹æ¡ˆï¼Œè¿™é‡Œæ‰‹åŠ¨æ·»åŠ è¿›å»ã€‚
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">shardings</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="c1">// ... åç»­å¤„ç† ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">sharding</span> <span class="p">:</span> <span class="n">shardings</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ShardingSpace</span> <span class="n">newShardingSpace</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">isValid</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 1. ä¸ºæ¯ä¸ªshardingæ–¹æ¡ˆè®¡ç®—æ€§èƒ½å› å­
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">newShardingSpace</span><span class="p">.</span><span class="n">factor</span> <span class="o">=</span> <span class="n">getFactor</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">sharding</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ... (çœç•¥éƒ¨åˆ†é€»è¾‘) ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// 2. å°†åŒ…å«factorçš„ShardingSpaceå¯¹è±¡æ’å…¥setä¸­
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">spaces</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">newShardingSpace</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>getShardings</code> å‡½æ•°é‡‡ç”¨çš„æ˜¯é€’å½’ç®—æ³•ï¼Œç›®æ ‡æ˜¯æ‰¾åˆ°æ‰€æœ‰æ•´æ•°å‘é‡ <code>s = {s_0, s_1, ..., s_{dim-1}}</code>ï¼Œä½¿å¾— <code>s_0 * s_1 * ... * s_{dim-1} == maxSharding</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">ShardingLevel</span><span class="o">::</span><span class="n">getShardings</span><span class="p">(</span><span class="kt">int32_t</span> <span class="n">curDim</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">allDim</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">curSharded</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">maxSharding</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int32_t</span><span class="o">&gt;&gt;&amp;</span> <span class="n">shardings</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int32_t</span><span class="o">&gt;&amp;</span> <span class="n">sharding</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 1. é€’å½’ç»ˆæ­¢æ¡ä»¶ (Base Case) 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">curDim</span> <span class="o">==</span> <span class="n">allDim</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// å·²ç»å¤„ç†å®Œæ‰€æœ‰ç»´åº¦
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">curSharded</span> <span class="o">==</span> <span class="n">maxSharding</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// å¹¶ä¸”ç´¯ä¹˜ç»“æœæ­£å¥½ç­‰äºç›®æ ‡
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// // succeeded
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">shardings</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">sharding</span><span class="p">);</span> <span class="c1">// æ‰¾åˆ°äº†ä¸€ä¸ªåˆæ³•è§£ï¼Œå­˜å…¥ç»“æœåˆ—è¡¨
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">;</span> <span class="c1">// å›æº¯
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 2. é€’å½’ä¸»ä½“ï¼šéå†å½“å‰ç»´åº¦çš„æ‰€æœ‰å¯èƒ½åˆ‡åˆ†ç³»æ•°
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="kt">int32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">maxSharding</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// å°è¯•å°†å½“å‰ç»´åº¦(curDim)çš„åˆ‡åˆ†ç³»æ•°è®¾ä¸º i
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">sharding</span><span class="p">[</span><span class="n">curDim</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// æ›´æ–°å·²ç´¯ä¹˜çš„åˆ‡åˆ†ç³»æ•°
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">curSharded</span> <span class="o">*=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 3. å‰ªæä¼˜åŒ– (Pruning) ï¼šè¿™æ˜¯ç®—æ³•æ•ˆç‡çš„å…³é”®ï¼
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// å¦‚æœå½“å‰ç´¯ä¹˜çš„ç»“æœå·²ç»è¶…è¿‡äº†ç›®æ ‡ï¼Œé‚£ä¹ˆæ— è®ºåç»­ç»´åº¦å¦‚ä½•å–å€¼ï¼Œ
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// æœ€ç»ˆç»“æœå¿…ç„¶å¤§äº maxShardingï¼Œæ‰€ä»¥æ²¡æœ‰å¿…è¦ç»§ç»­é€’å½’ä¸‹å»äº†ã€‚
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">curSharded</span> <span class="o">&lt;=</span> <span class="n">maxSharding</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// å¦‚æœè¿˜æœ‰å¸Œæœ›ï¼Œåˆ™å¯¹ä¸‹ä¸€ä¸ªç»´åº¦è¿›è¡Œé€’å½’æœç´¢
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">getShardings</span><span class="p">(</span><span class="n">curDim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">allDim</span><span class="p">,</span> <span class="n">curSharded</span><span class="p">,</span> <span class="n">maxSharding</span><span class="p">,</span> <span class="n">shardings</span><span class="p">,</span> <span class="n">sharding</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 4. å›æº¯ (Backtracking) 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// æ— è®ºä¸Šé¢çš„é€’å½’æ˜¯å¦æˆåŠŸï¼Œå½“å®ƒè¿”å›åï¼Œæˆ‘ä»¬éœ€è¦â€œæ’¤é”€â€å½“å‰çš„é€‰æ‹©ï¼Œ
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// ä»¥ä¾¿åœ¨ for å¾ªç¯çš„ä¸‹ä¸€æ¬¡è¿­ä»£ä¸­å°è¯•æ–°çš„å€¼ã€‚
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">curSharded</span> <span class="o">/=</span> <span class="n">i</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>getFactor</code> éå†æ¯ä¸ªç»´åº¦ï¼ŒåŸºäºå†…å­˜å¯¹é½ç­‰ç¡¬ä»¶é™åˆ¶ï¼Œè®¡ç®—å‡ºè¯¥ç»´åº¦ä¸Šæœ€å¤§åˆç†çš„åˆ‡åˆ†æ•°é‡ maxShardingDim.
å°†ç”¨æˆ·æè®®çš„åˆ‡åˆ†æ•°é‡ <code>sharding[i]</code> ä¸ maxShardingDim å–æœ€å°å€¼ï¼Œå¾—åˆ°è¯¥ç»´åº¦ä¸Šçš„æœ‰æ•ˆåˆ‡åˆ†æ•°é‡ã€‚å°†æ‰€æœ‰ç»´åº¦ä¸Šçš„æœ‰æ•ˆåˆ‡åˆ†æ•°é‡ç›¸ä¹˜ï¼Œå¾—åˆ°æ€»çš„æœ‰æ•ˆå¹¶è¡Œåº¦ tileNum. å¯¹ tileNum å–ä»¥2ä¸ºåº•çš„å¯¹æ•°å¹¶å‘ä¸Šå–æ•´åè¿”å›ã€‚</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">uint8_t</span> <span class="n">ShadingLevel</span><span class="o">::</span><span class="n">getFactor</span><span class="p">(</span><span class="n">mlir</span><span class="o">::</span><span class="n">Operation</span><span class="o">*</span> <span class="n">op</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="n">sharding</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">tileNum</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">rank</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// a. åˆ¤æ–­æ˜¯å¦éœ€è¦å¯¹é½ï¼šè¿™é‡Œåªå¯¹æœ€åä¸€ä¸ªç»´åº¦ç‰¹æ®Šå¤„ç†
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">bool</span> <span class="n">align</span> <span class="o">=</span> <span class="n">i</span> <span class="o">==</span> <span class="n">rank</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// b. è·å–å¯¹é½åŸºæ•° (alignBase)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//    å¦‚æœéœ€è¦å¯¹é½ï¼Œåˆ™è°ƒç”¨ GetAlignBase è·å–ä¸€ä¸ªå¯¹é½å€¼ï¼Œå¦åˆ™ä¸º1 (ç›¸å½“äºä¸å¯¹é½) ã€‚
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//    è¿™ä¸ª alignBase å¾ˆå¯èƒ½ä»£è¡¨ç¡¬ä»¶ä¸€æ¬¡æœ€ä¼˜å¤„ç†çš„æœ€å°æ•°æ®å—å¤§å°ã€‚
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">uint32_t</span> <span class="n">alignBase</span> <span class="o">=</span> <span class="n">align</span> <span class="o">?</span> <span class="n">GetAlignBase</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dtype</span><span class="p">)</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// c. è®¡ç®—å½“å‰ç»´åº¦çš„æœ€å¤§åˆç†åˆ‡åˆ†è·¯æ•° (maxShardingDim)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//    ä¸€ä¸ªç»´åº¦èƒ½è¢«åˆ‡æˆå¤šå°‘ä»½ï¼Œä¸ä»…å–å†³äºå®ƒçš„æ€»å¤§å°ï¼Œè¿˜å–å†³äºå¯¹é½è¦æ±‚ã€‚
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//    ä¾‹å¦‚ï¼Œä¸€ä¸ªç»´åº¦å¤§å°ä¸º100ï¼Œä½†ç¡¬ä»¶è¦æ±‚å¿…é¡»æŒ‰16å¯¹é½å¤„ç†ï¼Œé‚£ä¹ˆæœ€å¤šåªèƒ½åˆ‡æˆ ceil(100/16) = 7 ä»½ã€‚
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">auto</span> <span class="n">maxShardingDim</span> <span class="o">=</span> <span class="n">CEIL</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">alignBase</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// d. è®¡ç®—â€œæœ‰æ•ˆâ€çš„åˆ‡åˆ†è·¯æ•°å¹¶ç´¯ä¹˜
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//    è¿™æ˜¯å…³é”®ï¼å®ƒåœ¨â€œæè®®çš„åˆ‡åˆ†è·¯æ•°(sharding[i])â€å’Œâ€œæœ€å¤§åˆç†åˆ‡åˆ†è·¯æ•°(maxShardingDim)â€ä¹‹é—´å–æœ€å°å€¼ã€‚
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//    è¿™æ„å‘³ç€ï¼Œå³ä½¿ä½ æè®®å°†ä¸€ä¸ªç»´åº¦åˆ‡16ä»½ï¼Œä½†å¦‚æœç¡¬ä»¶é™åˆ¶æœ€å¤šåªèƒ½åˆ‡7ä»½ï¼Œé‚£ä¹Ÿåªèƒ½ç®—7ä»½çš„è´¡çŒ®ã€‚
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//    è¿™å¯ä»¥é˜²æ­¢å¯¹ä¸€ä¸ªç»´åº¦è¿›è¡Œâ€œæ— æ•ˆçš„è¿‡åº¦åˆ‡åˆ†â€ã€‚
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">tileNum</span> <span class="o">*=</span> <span class="n">MIN</span><span class="p">(</span><span class="n">maxShardingDim</span><span class="p">,</span> <span class="n">sharding</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ceil</span><span class="p">(</span><span class="n">log2</span><span class="p">(</span><span class="n">tileNum</span><span class="p">)));</span> <span class="c1">// å‘ä¸Šå–æ•´
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>ä¸€ä¸ªä¾‹å­å¦‚ä¸‹</p>
<pre tabindex="0"><code>storeOp outShape[3, 4, 128, 4096]
level0: [1, 1, 1, 16], [1, 1, 2, 8], [1, 1, 4, 4]...   factor=16
level1:[1, 8, 1, 2], [1, 8, 2, 1]....                  factor=8
level2:[1, 16, 1, 1]                                   factor=4 
level3:[16, 1, 1, 1]                                   factor=2
</code></pre><p><code>DS_TileShardingPass</code> æŒ‰é¡ºåºéå† groupOp ä¸­çš„ç®—å­ï¼Œå¹¶åƒä¸€ä¸ªçŠ¶æ€æœºä¸€æ ·æ£€æŸ¥å’Œæ›´æ–°å„ç®—å­çš„åˆ†å¸ƒå¼ç­–ç•¥çŠ¶æ€ã€‚å…¶åœ¨æ¯æ¬¡æ‰§è¡Œæ—¶ï¼Œä»…ä¸ºå½“å‰çš„å¾…å®šç®—å­ï¼Œä»å…¶é¢„å…ˆç”Ÿæˆå¹¶æ’å¥½åºçš„å€™é€‰ç­–ç•¥åˆ—è¡¨ä¸­ï¼Œé€‰å‡ºä¸‹ä¸€ä¸ªæœ€ä¼˜çš„åˆ‡åˆ†æ–¹æ¡ˆå¹¶è¿›è¡Œæ›´æ–°ï¼Œç„¶åç«‹å³ç»ˆæ­¢å½“æ¬¡è¿è¡Œã€‚æ•´ä¸ªå›¾çš„æœ€ç»ˆåˆ‡åˆ†æ–¹æ¡ˆæ˜¯é€šè¿‡åå¤æ‰§è¡Œæ­¤ Passï¼Œå°†å†³ç­–ä»å›¾çš„å…¥å£é€æ­¥ä¼ æ’­åˆ°å‡ºå£è€Œæœ€ç»ˆç¡®å®šçš„ã€‚</p>
<p>
<figure class="post-figure">
    <a href="https://share.note.youdao.com/yws/api/personal/file/WEBda0206ff3ade37b3cb94b73f3a564489?method=download&amp;shareKey=bd6f962093568ee599a982e7b7b1a300" target="_blank" rel="noopener">
        <img loading="lazy" src="https://share.note.youdao.com/yws/api/personal/file/WEBda0206ff3ade37b3cb94b73f3a564489?method=download&amp;shareKey=bd6f962093568ee599a982e7b7b1a300" alt="An Example of Sharding">
    </a><figcaption>An Example of Sharding</figcaption></figure></p>
<p><code>DS_TileSplitPass</code> é¦–å…ˆæ£€æŸ¥ç®—å­æ˜¯å¦éœ€è¦ <code>reduceSplit</code> (ä¾‹å¦‚ GeMM åˆ‡åˆ† k ç»´åº¦). å¦‚æœ reduce ç»´åº¦åˆ‡åˆ†çŠ¶æ€ä¸º <code>s.srfinish = true</code> æ‰ä¼šè¿›è¡Œåç»­çš„ split æ–¹æ¡ˆã€‚</p>
<ol>
<li>ä»åå‘å‰ (æˆ–æ ¹æ® nFirst æ ‡å¿—å†³å®šæ–¹å‘) æ£€æŸ¥ç®—å­çš„å„ä¸ªç»´åº¦ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªâ€œè¿˜å¯ä»¥å†åˆ‡åˆ†â€çš„ç»´åº¦ã€‚åˆ¤æ–­ä¾æ®æ˜¯è¯¥ç»´åº¦åˆ‡åˆ†åçš„å¤§å°æ˜¯å¦å·²è¾¾åˆ°ç³»ç»Ÿè®¾å®šçš„æœ€å°å€¼ (s.sliceShapeMin) .</li>
<li>ä¸€æ—¦æ‰¾åˆ°ç›®æ ‡ç»´åº¦ updateDimï¼Œå®ƒä¼šè°ƒç”¨ä¸€ä¸ªåä¸º <code>getNextSplit</code> çš„å‡½æ•°ã€‚å®ƒä¼šæ ¹æ®å½“å‰ç»´åº¦çš„åˆ‡åˆ†å€¼ <code>s.splitTry[updateDim]</code> è®¡ç®—å‡ºä¸‹ä¸€ä¸ªå¯èƒ½çš„åˆ‡åˆ†å€¼ã€‚ä¾‹å¦‚ï¼Œå¦‚æœå½“å‰æ˜¯ 2ï¼ŒgetNextSplit å¯èƒ½ä¼šè¿”å› 4.</li>
<li>æ›´æ–°ä¸è®°å½•ï¼šå®ƒå°†è¿™ä¸ªæ–°çš„åˆ‡åˆ†å€¼æ›´æ–°åˆ°å°è¯•æ€§æ–¹æ¡ˆ <code>s.splitTry</code> ä¸­ï¼Œå¹¶è®°å½•ä¸‹è¿™æ¬¡æ›´æ–°<code>space_-&gt;splitRecord.update(...)</code>.</li>
<li>åœ¨å¯¹å½“å‰ç®—å­çš„å¾ªç¯ç»“æŸæ—¶ï¼Œå®ƒä¼šå°†æ¢ç´¢å‡ºçš„ <code>s.splitTry</code> èµ‹å€¼ç»™æœ€ç»ˆæ–¹æ¡ˆ <code>s.split</code>.</li>
</ol>
<p>
<figure class="post-figure">
    <a href="https://share.note.youdao.com/yws/api/personal/file/WEBab1aedb258273670b60e2b54295f1f6c?method=download&amp;shareKey=afd6b38561485627a11fd118670b8431" target="_blank" rel="noopener">
        <img loading="lazy" src="https://share.note.youdao.com/yws/api/personal/file/WEBab1aedb258273670b60e2b54295f1f6c?method=download&amp;shareKey=afd6b38561485627a11fd118670b8431" alt="An Example of Split try of above Sharding">
    </a><figcaption>An Example of Split try of above Sharding</figcaption></figure></p>
<p><code>DS_SlicePropagatePass</code> ååºéå† (å³ä» groupOp çš„è¾“å‡ºåˆ°è¾“å…¥) çš„æ–¹å¼åå‘ä¼ æ’­åˆ‡åˆ†å†³ç­–ï¼Œå…¶é€»è¾‘æ˜¯ï¼šå¯¹äºæ¯ä¸€ä¸ªç®—å­ (æ¶ˆè´¹è€…)ï¼Œå®ƒä¼šè°ƒç”¨è¯¥ç®—å­å®ç°çš„ <code>ShardingInterface</code> æ¥å£ä¸­çš„ <code>tileShardingSplit</code> æ–¹æ³•ï¼Œæ¥ç²¾ç¡®è®¡ç®—å‡ºå…¶ä¸Šæ¸¸ç®—å­ (ç”Ÿäº§è€…) åº”è¯¥å¦‚ä½•åˆ‡åˆ†æ•°æ®ä»¥æ»¡è¶³æ¶ˆè´¹è€…çš„éœ€æ±‚ã€‚è¿™å¦‚æœè‡ªåŠ¨æ¥å£æ¨å¯¼å¤±è´¥ï¼Œå®ƒä¼šå›é€€å»è¯»å–ç®—å­ä¸Šé¢„è®¾çš„ <code>tile_parallel</code> å±æ€§ä½œä¸ºäººå·¥æŒ‡ä»¤ã€‚</p>
<p>
<figure class="post-figure">
    <a href="https://share.note.youdao.com/yws/api/personal/file/WEBb14ede2d32d997490222f36c1f0acc21?method=download&amp;shareKey=a244cf2ec9b5f31b5f3ef0ff2aa370a0" target="_blank" rel="noopener">
        <img loading="lazy" src="https://share.note.youdao.com/yws/api/personal/file/WEBb14ede2d32d997490222f36c1f0acc21?method=download&amp;shareKey=a244cf2ec9b5f31b5f3ef0ff2aa370a0" alt="An Example of Propagation">
    </a><figcaption>An Example of Propagation</figcaption></figure></p>
<p><code>DS_UpdateSliceIRPass</code> æ ¸å¿ƒç­–ç•¥æ˜¯é€šè¿‡åˆ†æå›¾ä¸­ reduceOp æ¥åå‘æ¨æ–­å’Œåˆ’åˆ†æµæ°´çº¿é˜¶æ®µã€‚é€šè¿‡æ£€æŸ¥æ¯ä¸ª reduceOp è‡ªèº«çš„å¹¶è¡Œå¤æ‚åº¦ (ä¾‹å¦‚ï¼ŒtpSplit &gt; 1) æ¥åˆ¤æ–­å…¶ä¸Šæ¸¸çš„è®¡ç®—ç±»å‹ï¼Œä»è€Œä¸ºä¸åŒçš„æµæ°´çº¿æ‰“ä¸Šè¯¸å¦‚ STAGEIC2OC (æ¨¡å‹å¹¶è¡Œè§„çº¦æ®µ) æˆ– STAGEOC2NH (æ¨¡å¼åˆ‡æ¢æ®µ) çš„æ ‡ç­¾ã€‚åœ¨å®Œæˆå¯¹æ‰€æœ‰ç®—å­çš„é˜¶æ®µåˆ’åˆ†åï¼Œå®ƒä¼šæœ€ç»ˆè®¡ç®—æ¯ä¸ªé˜¶æ®µçš„æµæ°´çº¿æ·±åº¦ï¼Œå¹¶æ•´ç†è¾“å‡ºä¸€ä»½åŒ…å«å¹¶è¡Œå¾ªç¯ç±»å‹ã€ç®—å­åˆ†ç»„å’Œæµæ°´çº¿é˜¶æ®µä¿¡æ¯çš„å®Œæ•´æ‰§è¡Œã€‚</p>
<ol>
<li>
<p>é¦–å…ˆä» reduceOps æ ˆä¸­å–å‡ºä¸€ä¸ªå…³å¡ç®—å­ã€‚ç„¶åï¼Œå®ƒåˆ©ç”¨ <code>getNEOPTPSlice</code> ç­‰è¾…åŠ©å‡½æ•°ï¼Œåˆ†æè¿™ä¸ªç®—å­è‡ªèº«çš„åˆ‡åˆ†ç­–ç•¥ï¼Œåˆ¤æ–­å®ƒå…·ä½“é‡‡ç”¨äº†å“ªç§å¼ é‡å¹¶è¡Œæ–¹å¼ã€‚</p>
</li>
<li>
<p>ç¡®å®šè¿æ¥åˆ°å½“å‰è¿™ä¸ª reduceOp çš„ä¸Šä¸€æ®µæµæ°´çº¿æ˜¯ä»€ä¹ˆç±»å‹</p>
</li>
</ol>
<ul>
<li><code>if (tpSplit &gt; 1)</code>: å¦‚æœè¿™ä¸ªå…³å¡ç®—å­æœ¬èº«æ˜¯ä¸€ä¸ªå¼ é‡å¹¶è¡Œåº¦å¤§äº 1 çš„ç®—å­ï¼Œä»£ç å°±åˆ¤æ–­å‡ºï¼šé€šå¾€è¿™ä¸ªç®—å­çš„è·¯å¾„ï¼Œæ˜¯ä¸€æ®µéœ€è¦æœ€ç»ˆè¿›è¡Œé›†åˆé€šä¿¡ (C) çš„è·¯å¾„ã€‚å› æ­¤ï¼Œå®ƒå°†è¿™æ®µè·¯å¾„çš„ç±»å‹æ ‡è®°ä¸º <code>STAGEIC2OC</code>.</li>
<li><code>else if (s.reduceSplit &gt; 1)</code>ï¼šå¦‚æœä¸æ˜¯ä¸Šé¢é‚£ç§æƒ…å†µï¼Œä»£ç ä¼šæ£€æŸ¥å¦ä¸€ç§æ¨¡å‹å¹¶è¡Œæ¨¡å¼ã€‚å¦‚æœä¸€ä¸ªç®—å­çš„è§„çº¦ç»´åº¦è¢«åˆ‡åˆ†äº†ï¼ŒåŒæ ·æ„å‘³ç€åç»­éœ€è¦ä¸€ä¸ª AllReduce é›†åˆé€šä¿¡ã€‚å› æ­¤ï¼Œå®ƒæŠŠè¿™æ®µè·¯å¾„æ ‡è®°ä¸º <code>STAGEIC2IC</code>.</li>
<li>å¦‚æœä¸¤ä¸ªæ¡ä»¶éƒ½ä¸æ»¡è¶³ï¼Œæ„å‘³ç€è¿™å¯èƒ½æ˜¯ä¸€ä¸ªä¸åŒå¹¶è¡Œæ¨¡å¼ä¹‹é—´çš„åˆ‡æ¢ï¼Œä¾‹å¦‚ä»æ¨¡å‹å¹¶è¡Œåˆ‡æ¢å›æ•°æ®å¹¶è¡Œï¼Œæ­¤æ—¶ä¼šä½¿ç”¨é»˜è®¤çš„ <code>STAGEOC2NH</code> æ ‡è®°.</li>
</ul>
<ol start="3">
<li>é€šè¿‡ <code>updateLoopStage</code> å‡½æ•°ï¼Œå°†ä¸¤ä¸ª reduceOp ç®—å­ä¹‹é—´çš„æ‰€æœ‰æ™®é€šç®—å­ï¼Œéƒ½å½’ç±»åˆ°åˆšåˆšåœ¨ç¬¬ 2 æ­¥ä¸­å†³ç­–å‡ºçš„ lastRuduceLoopStage.</li>
<li>å¤„ç†å®Œæ‰€æœ‰çš„ reduceOp åéå†æ‰€æœ‰ç®—å­ï¼Œæ ¹æ® LoopStageMap_ ä¸­çš„è®°å½•ï¼Œå°†ç®—å­æ”¾å…¥å¯¹åº”çš„â€œç¯®å­â€é‡Œã€‚</li>
</ol>
<p>
<figure class="post-figure">
    <a href="https://share.note.youdao.com/yws/api/personal/file/WEBa90c52245265edade98cd9f5b15d59bb?method=download&amp;shareKey=ccf9d74acc3642b1eac881133e98c6b9" target="_blank" rel="noopener">
        <img loading="lazy" src="https://share.note.youdao.com/yws/api/personal/file/WEBa90c52245265edade98cd9f5b15d59bb?method=download&amp;shareKey=ccf9d74acc3642b1eac881133e98c6b9" alt="DS_UpdateSliceIRPass">
    </a><figcaption>DS_UpdateSliceIRPass</figcaption></figure></p>
<h3 id="ts_swpipelinepass">TS_SwPipelinePass<a hidden class="anchor" aria-hidden="true" href="#ts_swpipelinepass">#</a></h3>
<p>TS_SwPipelinePass æ ¸å¿ƒæ˜¯è°ƒç”¨ getPipeline å‡½æ•°ã€‚å…¶å†…éƒ¨é€šè¿‡é¡ºåºæ‰§è¡Œä»¥ä¸‹ä¸‰ä¸ªå…³é”®æ­¥éª¤ï¼Œã€‚</p>
<p><code>getInitPipelineOps</code></p>
<ol>
<li>ä¸ºæ¯ä¸ªæµæ°´çº¿é˜¶æ®µ (å¦‚ STAGENH2OC, STAGEOC2ICç­‰) åˆ›å»ºä¸€ä¸ªç‹¬ç«‹çš„ pipeline åˆ—è¡¨ã€‚</li>
<li>æŒ‰ IC -&gt; OC -&gt; NH é¡ºåºæ¥æ‹¼æ¥è¿™äº›åˆ—è¡¨ã€‚åœ¨æ‹¼æ¥æ—¶ï¼Œå®ƒä¼šæ£€æŸ¥æ¯ä¸ªé˜¶æ®µçš„å¾ªç¯æ¬¡æ•°ã€‚å¦‚æœå¾ªç¯æ¬¡æ•°å¤§äº1ï¼šå®ƒå¹¶ä¸ä¼šç®€å•åœ°å°†æ“ä½œåˆ—è¡¨å¤åˆ¶å¤šæ¬¡ï¼Œè€Œæ˜¯åˆ›å»ºä¸€ä¸ªç‰¹æ®Šçš„ã€ç±»å‹ä¸º PipelineOpsBase çš„ <strong>Repeat èŠ‚ç‚¹</strong>ã€‚è¿™ä¸ªèŠ‚ç‚¹å†…éƒ¨åŒ…å«éœ€è¦é‡å¤çš„å­æµæ°´çº¿ (<code>repeatBase.repeat</code>) å’Œé‡å¤æ¬¡æ•° (<code>repeatBase.repeatTimes</code>) . ç„¶åï¼Œå®ƒå°†è¿™ä¸ªRepeat èŠ‚ç‚¹ä½œä¸ºä¸€ä¸ªå•ä¸€çš„ã€åŸå­æ€§çš„å…ƒç´ ï¼Œæ’å…¥åˆ°ä¸‹ä¸€ä¸ªé˜¶æ®µçš„æµæ°´çº¿ä¸­ã€‚è¿™æ˜¯ä¸€ç§é«˜æ•ˆè¡¨ç¤ºåµŒå¥—å¾ªç¯çš„æ–¹æ³•ã€‚
å¦‚æœå¾ªç¯æ¬¡æ•°ä¸ä¸º 1ï¼šå®ƒå°±ç›´æ¥ä½¿ç”¨ splice æ“ä½œï¼Œå°†å½“å‰é˜¶æ®µçš„ç®—å­åˆ—è¡¨å®Œæ•´åœ°ç§»åŠ¨å¹¶æ‹¼æ¥åˆ°ä¸‹ä¸€ä¸ªé˜¶æ®µçš„å°¾éƒ¨ã€‚</li>
</ol>
<p>ç»è¿‡å±‚å±‚æ‹¼æ¥å’ŒåµŒå¥—ï¼Œè¯¥å‡½æ•°æœ€ç»ˆè¿”å›ä¸€ä¸ªåä¸º groupPipeline çš„ std::listã€‚è¿™ä¸ªåˆ—è¡¨å°±æ˜¯ä¸€ä»½å®Œæ•´çš„ã€çº¿æ€§çš„é€»è¾‘æ‰§è¡Œå‰§æœ¬ï¼Œå…¶ä¸­æ‰€æœ‰çš„åµŒå¥—å¾ªç¯éƒ½è¢«æŠ½è±¡æˆäº† Repeat èŠ‚ç‚¹ã€‚</p>
<p>
<figure class="post-figure">
    <a href="https://share.note.youdao.com/yws/api/personal/file/WEB58fc5fb9b7b1fb4880eb020bce68afd5?method=download&amp;shareKey=f4ae610fb730689a22fe38a7226ee6e5" target="_blank" rel="noopener">
        <img loading="lazy" src="https://share.note.youdao.com/yws/api/personal/file/WEB58fc5fb9b7b1fb4880eb020bce68afd5?method=download&amp;shareKey=f4ae610fb730689a22fe38a7226ee6e5" alt="getInitPipelineOps">
    </a><figcaption>getInitPipelineOps</figcaption></figure></p>
<p><code>pipeline </code></p>
<p>ä¸»è¦å·¥ä½œæ˜¯å¤„ç†ä¸Šä¸€é˜¶æ®µç”Ÿæˆçš„ Repeat èŠ‚ç‚¹ï¼Œå¹¶å¯¹æµæ°´çº¿çš„è¡”æ¥å¤„è¿›è¡Œæ·±åº¦ä¼˜åŒ–ï¼Œä»¥å‡å°‘æ°”æ³¡ (ç¡¬ä»¶ç©ºé—²å‘¨æœŸ) ã€‚</p>
<ol>
<li>
<p>å½“å®ƒåœ¨æµæ°´çº¿ä¸­é‡åˆ°ä¸€ä¸ª Repeat èŠ‚ç‚¹æ—¶ï¼Œå®ƒä¼šå¯¹è¯¥èŠ‚ç‚¹å†…éƒ¨çš„å­æµæ°´çº¿å†æ¬¡è°ƒç”¨pipelineå‡½æ•° (<code>auto inner = pipeline((it).repeat, ...)</code>). é€šè¿‡è¿™ç§æ–¹å¼å±•å¼€ä»»æ„å±‚çº§çš„åµŒå¥—å¾ªç¯ã€‚</p>
</li>
<li>
<p>åœ¨å¤„ç†å¾ªç¯çš„è¾¹ç•Œæ—¶ï¼Œå®ƒè°ƒç”¨ getRetract å’Œ doRetract è¿™å¯¹å¤æ‚çš„ä¼˜åŒ–å·¥å…·ã€‚</p>
</li>
</ol>
<ul>
<li><code>getRetract</code>: åœ¨è¿æ¥ä¸¤ä¸ªå¾ªç¯è¿­ä»£ (æˆ–ä¸åŒçš„æµæ°´çº¿æ®µ) æ—¶ï¼Œé€šè¿‡ canParallel å‡½æ•°æ£€æŸ¥åä¸€ä¸ªè¿­ä»£çš„â€œå¤´éƒ¨æŒ‡ä»¤â€æ˜¯å¦å¯ä»¥å’Œå‰ä¸€ä¸ªè¿­ä»£çš„â€œå°¾éƒ¨æŒ‡ä»¤â€å¹¶è¡Œæ‰§è¡Œï¼Œä»è€Œè®¡ç®—å‡ºæœ€å¤§å¯ä»¥â€œå›ç¼©â€ (å³æå‰æ‰§è¡Œ) çš„æŒ‡ä»¤æ•°é‡ã€‚</li>
<li><code>doRetract</code>: åœ¨ getRetract æ¢æ˜äº†å¯å›ç¼©çš„æ•°é‡åï¼ŒdoRetract è´Ÿè´£ç‰©ç†åœ°ä¿®æ”¹æµæ°´çº¿ã€‚å®ƒé€šè¿‡ splice æ“ä½œï¼Œå°†åä¸€ä¸ªè¿­ä»£å¤´éƒ¨çš„æŒ‡ä»¤ï¼Œåˆå¹¶åˆ°å‰ä¸€ä¸ªè¿­ä»£å°¾éƒ¨çš„æŒ‡ä»¤åˆ—è¡¨ä¸­ï¼Œä»è€Œå¡«è¡¥äº†æ½œåœ¨çš„æ‰§è¡Œç©ºéš™ã€‚</li>
</ul>
<p><code>getEnginsPipeline</code> å°†ä¼˜åŒ–åçš„æ“ä½œåºåˆ—ï¼Œç¿»è¯‘æˆå…·ä½“çš„ã€åˆ†é…åˆ°ä¸åŒç¡¬ä»¶å¼•æ“çš„æŒ‡ä»¤ã€‚</p>
<ol>
<li>
<p>å‡½æ•°éå†è¾“å…¥çš„ pipelineOps åˆ—è¡¨ã€‚åˆ—è¡¨ä¸­çš„æ¯ä¸ªå…ƒç´  opsBase ä»£è¡¨ä¸€ä¸ªæµæ°´çº¿å‘¨æœŸ (ä¸€â€œå¸§â€) å†…éœ€è¦å…±åŒæ‰§è¡Œçš„ä¸€ç»„MLIRæ“ä½œã€‚</p>
</li>
<li>
<p>å¯¹äºæ¯ä¸ªå‘¨æœŸï¼Œå®ƒåˆ›å»ºä¸€ä¸ª enginsBase å¯¹è±¡ã€‚è¿™ä¸ªå¯¹è±¡æ˜¯ä¸€ä¸ªç»“æ„ä½“ï¼ŒåŒ…å«äº†åˆ†åˆ«å¯¹åº”ä¸åŒç¡¬ä»¶å¼•æ“ (å¦‚ <code>ld</code> for Load, <code>st</code> for Store, <code>ne</code> for Neural Engine, <code>tdma</code> for DMA) çš„æˆå‘˜å˜é‡ã€‚</p>
</li>
<li>
<p>éå†å½“å‰å‘¨æœŸçš„æ‰€æœ‰ opï¼Œé€šè¿‡æŸ¥è¯¢æ¯ä¸ª op çš„ engine å±æ€§ <code>queryOpAttr().engine</code>ï¼Œå¾—çŸ¥è¿™ä¸ªæ“ä½œé¢„å®šç”±å“ªä¸ªç¡¬ä»¶å¼•æ“æ¥æ‰§è¡Œã€‚æ¥ç€ï¼Œå®ƒå°†è¿™ä¸ª op çš„æŒ‡é’ˆå­˜æ”¾åˆ° enginsBase å¯¹è±¡ä¸­å¯¹åº”çš„å¼•æ“ slot é‡Œã€‚ä¾‹å¦‚ï¼Œä¸€ä¸ª <code>NPU_ENGINE_LOAD</code> ç±»å‹çš„æ“ä½œä¼šè¢«æ”¾å…¥ <code>enginsBase.ld</code> åˆ—è¡¨ã€‚</p>
</li>
</ol>
<p>å‡½æ•°æœ€ç»ˆè¿”å›ä¸€ä¸ª <code>std::list&lt;PipelineBase&gt;</code> æè¿°äº†åœ¨åŒä¸€ä¸ªæ—¶é’Ÿå‘¨æœŸå†…ï¼ŒåŠ è½½ã€å­˜å‚¨ã€è®¡ç®—ç­‰å¤šä¸ªç¡¬ä»¶å•å…ƒåº”è¯¥åŒæ—¶æ‰§è¡Œ**å“ªäº›ä¸åŒçš„æ“ä½œã€‚</p>
<h3 id="spmallocpass">SPMAllocPass<a hidden class="anchor" aria-hidden="true" href="#spmallocpass">#</a></h3>
<p>SPMAllocPass åŒ…æ‹¬ä¸‰ä¸ª passï¼Œä¸‹é¢ä¾æ¬¡ä»‹ç»ï¼Œé¦–å…ˆä»‹ç»ç”¨åˆ°çš„æ•°æ®ç»“æ„</p>
<p><code>BufferLabel</code> ä½œä¸ºç¼“å†²åŒºçš„å”¯ä¸€æ ‡è¯†ç¬¦ï¼Œå°†å…¶é“¾æ¥åˆ°ç¨‹åºä¸­çš„ç‰¹å®š <code>mlir::Value</code> ï¼Œå¹¶æ³¨æ„å®ƒæ˜¯å¦ä¸º Imm.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @struct BufferLabel
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief A unique identifier for a memory buffer.
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * This struct links a buffer to a specific MLIR Value and tracks whether it&#39;s
</span></span></span><span class="line"><span class="cl"><span class="cm"> * a special &#34;immediate&#34; buffer. It&#39;s used as a key in maps to associate
</span></span></span><span class="line"><span class="cl"><span class="cm"> * MLIR Values with their buffer metadata.
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">BufferLabel</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// The MLIR Value that this buffer represents, typically a tensor produced
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// by an operation.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">mlir</span><span class="o">::</span><span class="n">Value</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// A flag indicating if this buffer holds a special &#34;immediate&#34; value.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Immediate values might be treated differently during allocation (e.g.,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// small constants or internal scratchpads for an op).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">bool</span> <span class="n">isImm</span><span class="p">{</span><span class="nb">false</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @brief Equality operator to compare two labels.
</span></span></span><span class="line"><span class="cl"><span class="cm">     *
</span></span></span><span class="line"><span class="cl"><span class="cm">     * Two labels are considered equal if they refer to the same MLIR Value
</span></span></span><span class="line"><span class="cl"><span class="cm">     * and have the same &#39;isImm&#39; status. This is necessary for using
</span></span></span><span class="line"><span class="cl"><span class="cm">     * BufferLabel as a key in std::map or std::unordered_map.
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">BufferLabel</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">other</span><span class="p">.</span><span class="n">v</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">isImm</span> <span class="o">==</span> <span class="n">other</span><span class="p">.</span><span class="n">isImm</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p><code>ValueBuffer</code> åŒ…å«å•ä¸ªç¼“å†²åŒºæ‰€éœ€çš„æ‰€æœ‰å…ƒæ•°æ®ï¼ŒåŒ…æ‹¬å…¶æ ‡è¯†ã€ç”Ÿå­˜æœŸã€å¤§å°å’Œæœ€ç»ˆå†…å­˜ä½ç½®ã€‚</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @struct ValueBuffer
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief Represents the metadata for a single memory buffer, including its
</span></span></span><span class="line"><span class="cl"><span class="cm"> * lifetime, size, and allocation information.
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">ValueBuffer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// The unique identifier for this buffer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">BufferLabel</span> <span class="n">label</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Represents the starting point of the buffer&#39;s lifetime (inclusive),
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// measured in pipeline cycles. After memory allocation, this field may be
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// repurposed to store the starting memory address.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int64_t</span> <span class="n">start</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Represents the ending point of the buffer&#39;s lifetime (inclusive),
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// measured in pipeline cycles. After memory allocation, this field may be
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// repurposed to store the ending memory address.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int64_t</span> <span class="n">end</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// The total size of this buffer in bytes, as required by its tensor shape.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int64_t</span> <span class="n">allSize</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Size of an intermediate/temporary buffer that an operator might need
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// internally. This is often allocated contiguously with the main output
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// buffer. For example, the final output address would be &#39;offset + immSize&#39;.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int64_t</span> <span class="n">immSize</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// The final memory offset assigned to this buffer in the scratchpad memory.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// This value is determined by the final memory allocation pass.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int64_t</span> <span class="n">offset</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @brief Less-than operator, used for sorting ValueBuffer objects.
</span></span></span><span class="line"><span class="cl"><span class="cm">     *
</span></span></span><span class="line"><span class="cl"><span class="cm">     * The active implementation sorts buffers primarily by their lifetime start
</span></span></span><span class="line"><span class="cl"><span class="cm">     * time. This is a common strategy for greedy &#34;first fit&#34; style memory
</span></span></span><span class="line"><span class="cl"><span class="cm">     * allocation algorithms. The commented-out code shows an alternative
</span></span></span><span class="line"><span class="cl"><span class="cm">     * strategy of sorting by buffer size.
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">ValueBuffer</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// return this-&gt;allSize &lt; other.allSize; // Alternative sorting by size
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">&lt;=</span> <span class="n">other</span><span class="p">.</span><span class="n">start</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p><code>SA_BufferLifePass</code>çš„æ ¸å¿ƒåŠŸèƒ½æ˜¯åˆ†æå¹¶ç¡®å®šæ¯ä¸€ä¸ªéœ€è¦å­˜æ”¾åœ¨ ScratchPad Memory ä¸­çš„æ•°æ®å— (Bufferï¼Œå³mlir::Valueå¯¹åº”çš„å¼ é‡) çš„ç”Ÿå‘½å‘¨æœŸã€‚</p>
<ol>
<li>æ„å»ºâ€œå®šä¹‰-ä½¿ç”¨â€æ—¶é—´è¡¨ã€‚Pass çš„è¾“å…¥æ˜¯ <code>TS_SwPipelinePass</code> ç”Ÿæˆçš„æœ€ç»ˆæµæ°´çº¿æ‰§è¡Œåºåˆ— pipelineReal. è¿™ä¸ªåºåˆ—çš„æ¯ä¸€é¡¹éƒ½ä»£è¡¨ä¸€ä¸ªæµæ°´çº¿å‘¨æœŸï¼Œä»¥åŠè¯¥å‘¨æœŸå†…å„ä¸ªç¡¬ä»¶å¼•æ“æ‰§è¡Œçš„æ“ä½œã€‚ä»£ç éå†è¿™ä¸ªæµæ°´çº¿åºåˆ—ï¼Œé€ä¸ªå‘¨æœŸ (ç”±timeStepNumè®¡æ•°) åœ°åˆ†æã€‚å®ƒä¼šæ„å»ºä¸¤ä¸ªæ ¸å¿ƒçš„æ˜ å°„è¡¨ï¼š</li>
</ol>
<ul>
<li><code>opIsTemp</code>: è®°å½•åœ¨å“ªä¸€ä¸ªæ—¶é—´æ­¥ (timeStepNum) ï¼Œæœ‰å“ªäº›å€¼ (mlir::Value) è¢«å®šä¹‰æˆ–äº§å‡ºã€‚ä¾‹å¦‚ï¼Œld (åŠ è½½) å’Œ ne (è®¡ç®—) æ“ä½œçš„è¾“å‡ºéƒ½ä¼šè¢«è®°å½•ã€‚</li>
<li><code>consumerOps</code>: è®°å½•åœ¨å“ªä¸€ä¸ªæ—¶é—´æ­¥ï¼Œæœ‰å“ªäº›å€¼è¢«ä½œä¸ºè¾“å…¥æ¶ˆè´¹æ‰äº†ã€‚</li>
</ul>
<p>äº§å‡ºï¼šè¿™ä¸ªæ­¥éª¤å®Œæˆåï¼ŒPasså°±æ‹¥æœ‰äº†ä¸€ä»½å®Œæ•´çš„ã€æŒ‰æ—¶é—´æ­¥ç´¢å¼•çš„â€œè°åœ¨ä½•æ—¶è¢«åˆ›å»ºâ€å’Œâ€œè°åœ¨ä½•æ—¶è¢«ä½¿ç”¨â€çš„æ¸…å•ã€‚</p>
<ol start="2">
<li>ç¡®å®šæ¯ä¸ªBufferçš„ç”Ÿå‘½å‘¨æœŸã€‚Passä¼šéå†æ‰€æœ‰ç®—å­å’Œå®ƒä»¬çš„è¾“å…¥ (operands) ï¼Œä¸ºæ¯ä¸€ä¸ªä½œä¸ºè¾“å…¥çš„ Value (å³inValue) è®¡ç®—å…¶ç”Ÿå‘½å‘¨æœŸã€‚</li>
</ol>
<ul>
<li>ç¡®å®šç”Ÿå‘½å‘¨æœŸç»ˆç‚¹ (end)ï¼šä¸€ä¸ª Value çš„ç”Ÿå‘½å‘¨æœŸï¼Œåœ¨å…¶è¢«ä½œä¸ºè¾“å…¥ (è¢«æ¶ˆè´¹) æ—¶è¾¾åˆ°ä¸€ä¸ªç»ˆç‚¹ã€‚å› æ­¤ï¼Œå½“ä»£ç åœ¨æ—¶é—´æ­¥ curTs å¤„ç†ä¸€ä¸ªæ¶ˆè´¹è€…ç®—å­æ—¶ï¼Œå…¶è¾“å…¥ inValue çš„ <code>buf.end</code> å°±è¢«è®¾ç½®ä¸º curTs.</li>
<li>ç¡®å®šç”Ÿå‘½å‘¨æœŸèµ·ç‚¹ (start)ï¼šä¸ºäº†æ‰¾åˆ°inValueä½•æ—¶è¢«åˆ›å»ºï¼Œä»£ç ä¼šè°ƒç”¨ä¸€ä¸ª <code>getNearestProducer</code> çš„å‡½æ•°ã€‚è¿™ä¸ªå‡½æ•°ä¼šæ‹¿ç€å½“å‰çš„æ¶ˆè´¹æ—¶é—´ curTs å’Œ inValueï¼Œå»ç¬¬ä¸€æ­¥ç”Ÿæˆçš„ opIsTemp (å®šä¹‰æ—¶é—´è¡¨) ä¸­åå‘æŸ¥æ‰¾ï¼Œæ‰¾åˆ°ç¦» curTs æœ€è¿‘çš„ã€inValue è¢«å®šä¹‰çš„é‚£ä¸ªæ—¶é—´æ­¥ <code>buf.start</code>.</li>
</ul>
<p>è®¡ç®—å‡ºçš„ start å’Œ endï¼Œè¿åŒ Value çš„æ ‡è¯† (BufferLabel) ï¼Œè¢«å°è£…åœ¨ ValueBuffer ç»“æ„ä½“ä¸­ï¼Œå¹¶å­˜å…¥ä¸€ä¸ªå…¨å±€çš„æ•°æ®ç»“æ„ <code>space_-&gt;vBuffer</code> é‡Œã€‚</p>
<ol start="3">
<li>ç‰¹æ®Šæƒ…å†µå¤„ç†</li>
</ol>
<ul>
<li><code>In-place</code>: å¯¹äºè¾“å…¥å’Œè¾“å‡ºå¤ç”¨åŒä¸€å—å†…å­˜çš„ in-place æ“ä½œï¼Œå…¶ç”Ÿå‘½å‘¨æœŸè®¡ç®—å¿…é¡»è¿½æº¯åˆ°æœ€åˆæä¾›è¿™å—å†…å­˜çš„é‚£ä¸ªéin-placeç®—å­ã€‚ä»£ç é€šè¿‡ <code>getInplaceIndex</code> é€’å½’åœ°å›æº¯in-placeé“¾ï¼Œä»¥ç¡®ä¿ç”Ÿå‘½å‘¨æœŸçš„ start æ—¶é—´æ˜¯æ­£ç¡®çš„ã€æœ€å¼€å§‹çš„é‚£ä¸ªå®šä¹‰æ—¶é—´ã€‚</li>
<li>ä¸­é—´å€¼ (imm) ä¸ç´¯åŠ å€¼ (Psum): ä»£ç ä¼šè¯†åˆ«ä¸€äº›ç‰¹æ®Šçš„ã€å¯èƒ½åœ¨å¤šä¸ªæ—¶é—´æ­¥ä¸­å­˜åœ¨çš„ä¸­é—´å€¼æˆ–ç´¯åŠ å€¼ (ç”±getImmSize æˆ– isPsumValue è¯†åˆ«) . å¯¹äºè¿™äº›å€¼ï¼Œå®ƒä»¬å¯èƒ½ä¼šæœ‰å¤šä¸ªç¦»æ•£çš„ç”Ÿå­˜åŒºé—´ã€‚Pass ä¸­å¯èƒ½åŒ…å«ä¸€äº›åå¤„ç†é€»è¾‘ï¼Œå°†è¿™äº›ç¦»æ•£çš„åŒºé—´åˆå¹¶æˆä¸€ä¸ªä»â€œæœ€æ—©çš„startâ€åˆ°â€œæœ€æ™šçš„endâ€çš„è¿ç»­å¤§åŒºé—´ï¼Œä»¥ç®€åŒ–åç»­çš„å†…å­˜åˆ†é…ã€‚</li>
</ul>
<p><code>SA_BufferMergePass</code> çš„ä»»åŠ¡å°±æ˜¯æ¸…ç†è¿™äº›å†—ä½™æˆ–å¤æ‚çš„ç”Ÿå‘½å‘¨æœŸè®°å½•ï¼Œå…·ä½“æ¥è¯´ï¼Œå°±æ˜¯åˆå¹¶é‚£äº›å­˜åœ¨æ—¶é—´ä¸Šé‡å æˆ–åŒ…å«å…³ç³»çš„ç”Ÿå‘½å‘¨æœŸåŒºé—´ï¼Œä¸ºåç»­çš„å†…å­˜åˆ†é…å™¨æä¾›ä¸€ä¸ªæœ€ç°¡æ´ã€æ— å†—ä½™çš„åŒºé—´åˆ—è¡¨ã€‚</p>
<p>éå†ç”±ä¸Šä¸€ä¸ª Pass ç”Ÿæˆçš„ space_-&gt;vBuffer è¿™ä¸ªmap. å…¶ä¸­çš„æ¯ä¸€é¡¹ï¼Œkey æ˜¯ç¼“å†²åŒºçš„å”¯ä¸€æ ‡è¯† BufferLabelï¼Œvalueæ˜¯è¯¥ç¼“å†²åŒºæ‰€æœ‰ç”Ÿå‘½å‘¨æœŸåŒºé—´çš„åˆ—è¡¨ <code>std::vector&lt;ValueBuffer&gt;</code>. å¯¹äºæ¯ä¸€ä¸ªvalueçš„ç”Ÿå‘½å‘¨æœŸåˆ—è¡¨ï¼Œå®ƒéƒ½è°ƒç”¨ <code>mergeOverlap</code> æ¥è¿›è¡Œå¤„ç†ã€‚æœ€åï¼Œå®ƒç”¨å‡½æ•°è¿”å›çš„ã€ç»è¿‡æ¸…ç†å’Œåˆå¹¶çš„æ–°çš„åˆ—è¡¨ï¼Œæ¥æ›¿æ¢æ‰ map ä¸­æ—§çš„åˆ—è¡¨ã€‚è¯¥å‡½æ•°æµç¨‹å¦‚ä¸‹</p>
<ol>
<li>æ ¹æ® ValueBuffer é‡è½½çš„ <code>operator&lt;</code> (å³æŒ‰ start æ—¶é—´å‡åº) ï¼Œå°†æ‰€æœ‰ç”Ÿå‘½å‘¨æœŸåŒºé—´è¿›è¡Œæ’åºã€‚</li>
<li>éå†å·²æ’åºçš„åˆ—è¡¨ï¼Œå°† start æ—¶é—´ç›¸åŒçš„è¿ç»­åŒºé—´æ”¶é›†åˆ°ä¸€ä¸ªä¸´æ—¶çš„ buf å‘é‡ä¸­ã€‚é‡åˆ°ä¸€ä¸ªä¸åŒ start æ—¶é—´çš„åŒºé—´æ—¶ï¼Œå®ƒä¼šæŒ‰ç…§ç»“æŸæ—¶é—´ end æ’åºä¹‹å‰æ”¶é›†çš„ bufï¼Œç„¶åå°†å¤„ç†åçš„ç»“æœ (é™¤äº†æœ€åä¸€ä¸ªå…ƒç´ ) é‡æ–°æ”¾å› valueBuf.</li>
<li>åˆå¹¶è¢«å®Œå…¨åŒ…å«çš„å­åŒºé—´ã€‚å®ƒç»´æŠ¤ç€å½“å‰æœ€å¤§çš„ç”Ÿå‘½å‘¨æœŸåŒºé—´ (<code>[usedTSStart, usedTSEnd]</code>). éå†åˆ—è¡¨ä¸­çš„æ¯ä¸€ä¸ªåŒºé—´ <code>*it</code>. æ ¹æ® <code>bool isSub = ((*it).start &gt;= usedTSStart) &amp;&amp; ((*it).end &lt;= usedTSEnd);</code> åˆ¤æ–­åŒºé—´æ˜¯å¦åœ¨æ—¶é—´ä¸Šè¢«ä¸Šä¸€ä¸ªâ€œæ¿€æ´»â€çš„åŒºé—´å®Œå…¨è¦†ç›–ã€‚</li>
</ol>
<ul>
<li>å¦‚æœ isSub ä¸º trueï¼Œæ„å‘³ç€ *it æ˜¯ä¸€ä¸ªå†—ä½™çš„å­åŒºé—´ã€‚å› ä¸ºåªè¦ä¸ºé‚£ä¸ªæ›´å¤§çš„æ¿€æ´»åŒºé—´åˆ†é…äº†å†…å­˜ï¼Œè¿™ä¸ªå­åŒºé—´çš„å†…å­˜éœ€æ±‚è‡ªç„¶ä¹Ÿå°±æ»¡è¶³äº†ã€‚å› æ­¤ï¼Œä»£ç é€šè¿‡ valueBuf.erase(it); å°†è¿™ä¸ªå†—ä½™çš„å­åŒºé—´ç›´æ¥åˆ é™¤ã€‚</li>
<li>å¦‚æœ isSub ä¸º falseï¼Œè¯´æ˜é‡åˆ°äº†ä¸€ä¸ªæ–°çš„ã€æ²¡æœ‰è¢«è¦†ç›–çš„ç”Ÿå‘½å‘¨æœŸï¼Œäºæ˜¯å®ƒå°†æˆä¸ºæ–°çš„â€œæ¿€æ´»â€åŒºé—´ï¼Œç”¨äºå’Œåç»­çš„åŒºé—´è¿›è¡Œæ¯”è¾ƒã€‚</li>
</ul>
<h1 id="compile-option-1-opt_barrier">Compile Option 1: opt_barrier<a hidden class="anchor" aria-hidden="true" href="#compile-option-1-opt_barrier">#</a></h1>
<p>ç”± <code>groupDAGPass</code> å®ç°ã€‚é€šè¿‡ group é—´çš„ä¾èµ–å…³ç³»æ¥ç»™ group å®šå±‚çº§ï¼ŒåŒä¸€å±‚çº§çš„ group åªæœ‰æœ€åä¸€ä¸ª group éœ€è¦ barrier.</p>
<ol>
<li>
<p>åˆå§‹åŒ–æ‰€æœ‰ group çš„ need_barrier å±æ€§ä¸º falseã€‚</p>
</li>
<li>
<p>ä»åå¾€å‰éå† groupï¼Œè‹¥ group çš„ç»“æœæ—  user æˆ–è¦ returnï¼Œè®¾ç½® layerNum ä¸º 0ï¼Œå¦åˆ™è®¾ç½®ä¸º userOp çš„ layerNum + 1. åŒæ—¶ç»´æŠ¤ä¸¤ä¸ª vector: firstOpInLayers å’ŒlastOpInLayers æ¥è®°å½•æ¯ä¸€å±‚çº§çš„ç¬¬ä¸€ä¸ª op å’Œæœ€åä¸€ä¸ª op. éå†ç»“æŸæŠŠ lastOpInLayersä¸­çš„ group çš„ need_barrier å±æ€§è®¾ä¸º true.</p>
</li>
</ol>
<p>
<figure class="post-figure">
    <a href="https://share.note.youdao.com/yws/api/personal/file/WEB8e3541f411fb9039713f3992b450f4b9?method=download&amp;shareKey=4f5dfad0d8b5a4bd8cf49ce94d5ad7c9" target="_blank" rel="noopener">
        <img loading="lazy" src="https://share.note.youdao.com/yws/api/personal/file/WEB8e3541f411fb9039713f3992b450f4b9?method=download&amp;shareKey=4f5dfad0d8b5a4bd8cf49ce94d5ad7c9" alt="opt_barrier">
    </a><figcaption>opt_barrier</figcaption></figure></p>
<h1 id="compile-option-1-opt_ddr">Compile Option 1: opt_ddr<a hidden class="anchor" aria-hidden="true" href="#compile-option-1-opt_ddr">#</a></h1>
<p>ç”± <code>ddrConstReorderPass</code> å’Œ <code>ddrVarReorderPass</code> å®ç°ã€‚é€šè¿‡æ”¹å˜ const å’Œ var åœ¨ ddr ä¸­çš„æ’å¸ƒï¼Œä½¿å…¶å¯¹é½ DDR_BANK(4096Bytes)ï¼Œå®ç°åŠ é€Ÿè¯»å–ã€‚</p>
<p>
<figure class="post-figure">
    <a href="https://share.note.youdao.com/yws/api/personal/file/WEBd3b8e4e14ab8e2c23f22a625b1d03ddd?method=download&amp;shareKey=948a94db71e0adcddb5f6107ad94a6d0" target="_blank" rel="noopener">
        <img loading="lazy" src="https://share.note.youdao.com/yws/api/personal/file/WEBd3b8e4e14ab8e2c23f22a625b1d03ddd?method=download&amp;shareKey=948a94db71e0adcddb5f6107ad94a6d0" alt="opt_ddr">
    </a><figcaption>opt_ddr</figcaption></figure></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/tx8/">Tx8</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/blogs/leetcode/03_binarysearch/">
    <span class="title">Â« Prev</span>
    <br>
    <span>03 BinarySearch</span>
  </a>
  <a class="next" href="http://localhost:1313/blogs/leetcode/02_slidingwindow/">
    <span class="title">Next Â»</span>
    <br>
    <span>02 Sliding Window</span>
  </a>
</nav>

  </footer><script src="https://giscus.app/client.js"
        data-repo="jamesnulliu/jamesnulliu.github.io"
        data-repo-id="R_kgDOMPCQIw"
        data-category="Announcements"
        data-category-id="DIC_kwDOMPCQI84Cgb2t"
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="bottom"
        data-theme="preferred_color_scheme"
        data-lang="en"
        crossorigin="anonymous"
        async>
</script>
</article>
    </main>
    
<footer class="footer">
        <span>Â© 2024-2025 WITHER</span> Â· 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
