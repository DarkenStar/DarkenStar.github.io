<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Blogs on WITHER</title>
    <link>http://localhost:1313/blogs/</link>
    <description>Recent content in Blogs on WITHER</description>
    <generator>Hugo -- 0.147.7</generator>
    <language>en</language>
    <copyright>2024-2025 WITHER</copyright>
    <lastBuildDate>Sat, 07 Jun 2025 16:05:12 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/blogs/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Functional Test of Hugo</title>
      <link>http://localhost:1313/blogs/functiontest/</link>
      <pubDate>Sat, 07 Jun 2025 16:05:12 +0800</pubDate>
      <guid>http://localhost:1313/blogs/functiontest/</guid>
      <description>function test</description>
      <content:encoded><![CDATA[<h1 id="github-card">Github Card</h1>
<div class="github">
    <div class="github_bar">
        <svg xmlns="http://www.w3.org/2000/svg" width="50" height="50" viewBox="0 0 50 50"><path d="M17.791,46.836C18.502,46.53,19,45.823,19,45v-5.4c0-0.197,0.016-0.402,0.041-0.61C19.027,38.994,19.014,38.997,19,39 c0,0-3,0-3.6,0c-1.5,0-2.8-0.6-3.4-1.8c-0.7-1.3-1-3.5-2.8-4.7C8.9,32.3,9.1,32,9.7,32c0.6,0.1,1.9,0.9,2.7,2c0.9,1.1,1.8,2,3.4,2 c2.487,0,3.82-0.125,4.622-0.555C21.356,34.056,22.649,33,24,33v-0.025c-5.668-0.182-9.289-2.066-10.975-4.975 c-3.665,0.042-6.856,0.405-8.677,0.707c-0.058-0.327-0.108-0.656-0.151-0.987c1.797-0.296,4.843-0.647,8.345-0.714 c-0.112-0.276-0.209-0.559-0.291-0.849c-3.511-0.178-6.541-0.039-8.187,0.097c-0.02-0.332-0.047-0.663-0.051-0.999 c1.649-0.135,4.597-0.27,8.018-0.111c-0.079-0.5-0.13-1.011-0.13-1.543c0-1.7,0.6-3.5,1.7-5c-0.5-1.7-1.2-5.3,0.2-6.6 c2.7,0,4.6,1.3,5.5,2.1C21,13.4,22.9,13,25,13s4,0.4,5.6,1.1c0.9-0.8,2.8-2.1,5.5-2.1c1.5,1.4,0.7,5,0.2,6.6c1.1,1.5,1.7,3.2,1.6,5 c0,0.484-0.045,0.951-0.11,1.409c3.499-0.172,6.527-0.034,8.204,0.102c-0.002,0.337-0.033,0.666-0.051,0.999 c-1.671-0.138-4.775-0.28-8.359-0.089c-0.089,0.336-0.197,0.663-0.325,0.98c3.546,0.046,6.665,0.389,8.548,0.689 c-0.043,0.332-0.093,0.661-0.151,0.987c-1.912-0.306-5.171-0.664-8.879-0.682C35.112,30.873,31.557,32.75,26,32.969V33 c2.6,0,5,3.9,5,6.6V45c0,0.823,0.498,1.53,1.209,1.836C41.37,43.804,48,35.164,48,25C48,12.318,37.683,2,25,2S2,12.318,2,25 C2,35.164,8.63,43.804,17.791,46.836z"></path></svg>
        <a class="github_name" href="" target="_blank"></a>
    </div>
    <div class="github_description">this is a github card</div>
    <div class="github_language">
        
    </div>
</div>

<h1 id="big-quote">Big Quote</h1>
<blockquote class="quote"><p>Basically, I’m not interested in doing research and I never have been… I’m interested in understanding, which is quite a different thing. And often to understand something you have to work it out yourself because no one else has done it. — David Blackwell</p></blockquote>
<h1 id="margin-note">Margin Note</h1>
<p>这是一段正常的文本，我们正在讨论一个非常重要的概念。<span class="sidenote-number"><small class="sidenote">这就是<a href="https://www.bilibili.com/">bilibili</a>对那个重要概念的解释和补充说明。你甚至可以在这里使用 <strong>Markdown</strong> 语法！</small></span>
 这个概念源于古希腊，对后世影响深远。</p>
<p>继续你的文章&hellip; 另一处需要注解的地方。<span class="sidenote-number"><small class="sidenote">这是第二个旁注，它会自动对齐，不会和第一个重叠。</small></span>
</p>
<h1 id="various-notice">Various Notice</h1>
<p>关于以下notice 请参考 <span class="sidenote-number"><small class="sidenote"><a href="https://github.com/martignoni/hugo-notice?tab=readme-ov-file">hugo_notice</a></small></span>

<style type="text/css">
     
    .notice {
        --title-color: #fff;
        --title-background-color: #6be;
        --content-color: #444;
        --content-background-color: #e7f2fa;
    }

    .notice.info {
        --title-background-color: #fb7;
        --content-background-color: #fec;
    }

    .notice.tip {
        --title-background-color: #5a5;
        --content-background-color: #efe;
    }

    .notice.warning {
        --title-background-color: #c33;
        --content-background-color: #fee;
    }

     
    @media (prefers-color-scheme:dark) {
        .notice {
            --title-color: #fff;
            --title-background-color: #069;
            --content-color: #ddd;
            --content-background-color: #023;
        }

        .notice.info {
            --title-background-color: #a50;
            --content-background-color: #420;
        }

        .notice.tip {
            --title-background-color: #363;
            --content-background-color: #121;
        }

        .notice.warning {
            --title-background-color: #800;
            --content-background-color: #400;
        }
    }

    body.dark .notice {
        --title-color: #fff;
        --title-background-color: #069;
        --content-color: #ddd;
        --content-background-color: #023;
    }

    body.dark .notice.info {
        --title-background-color: #a50;
        --content-background-color: #420;
    }

    body.dark .notice.tip {
        --title-background-color: #363;
        --content-background-color: #121;
    }

    body.dark .notice.warning {
        --title-background-color: #800;
        --content-background-color: #400;
    }

     
    .notice {
        padding: 18px;
        line-height: 24px;
        margin-bottom: 24px;
        border-radius: 4px;
        color: var(--content-color);
        background: var(--content-background-color);
    }

    .notice p:last-child {
        margin-bottom: 0
    }

     
    .notice-title {
        margin: -18px -18px 12px;
        padding: 4px 18px;
        border-radius: 4px 4px 0 0;
        font-weight: 700;
        color: var(--title-color);
        background: var(--title-background-color);
    }

     
    .icon-notice {
        display: inline-flex;
        align-self: center;
        margin-right: 8px;
    }

    .icon-notice img,
    .icon-notice svg {
        height: 1em;
        width: 1em;
        fill: currentColor;
    }

    .icon-notice img,
    .icon-notice.baseline svg {
        top: .125em;
        position: relative;
    }
</style><div class="notice warning" >
    <p class="notice-title">
        <span class="icon-notice baseline">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="126 76.5 300 300">
  <path d="M297.431 324.397v-34.255c0-3.245-2.344-5.95-5.358-5.95h-32.146c-3.014 0-5.358 2.705-5.358 5.95v34.255c0 3.245 2.344 5.95 5.358 5.95h32.146c3.014 0 5.358-2.705 5.358-5.95Zm-.335-67.428 3.014-82.753c0-1.081-.502-2.524-1.674-3.425-1.005-.902-2.512-1.983-4.019-1.983h-36.834c-1.507 0-3.014 1.081-4.019 1.983-1.172.901-1.674 2.704-1.674 3.786l2.846 82.392c0 2.344 2.512 4.146 5.693 4.146h30.975c3.013 0 5.525-1.803 5.692-4.146Zm-2.344-168.39L423.34 342.425c3.683 7.032 3.516 15.686-.335 22.717-3.85 7.031-10.883 11.358-18.417 11.358H147.413c-7.534 0-14.566-4.327-18.417-11.358-3.85-7.031-4.018-15.685-.335-22.716L257.248 88.578C260.93 81.188 268.13 76.5 276 76.5c7.87 0 15.069 4.688 18.752 12.08Z"/>
</svg>

        </span>Warning</p><p>This is a warning notice. Be warned!</p></div>
</p>
<div class="notice tip" >
    <p class="notice-title">
        <span class="icon-notice baseline">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="300.5 134 300 300">
  <path d="M551.281 252.36c0-3.32-1.172-6.641-3.515-8.985l-17.774-17.578c-2.344-2.344-5.469-3.711-8.789-3.711-3.32 0-6.445 1.367-8.789 3.71l-79.687 79.493-44.141-44.14c-2.344-2.344-5.469-3.712-8.79-3.712-3.32 0-6.444 1.368-8.788 3.711l-17.774 17.579c-2.343 2.343-3.515 5.664-3.515 8.984 0 3.32 1.172 6.445 3.515 8.789l70.704 70.703c2.343 2.344 5.664 3.711 8.789 3.711 3.32 0 6.64-1.367 8.984-3.71l106.055-106.056c2.343-2.343 3.515-5.468 3.515-8.789ZM600.5 284c0 82.813-67.188 150-150 150-82.813 0-150-67.188-150-150 0-82.813 67.188-150 150-150 82.813 0 150 67.188 150 150Z"/>
</svg>

        </span>Tip</p><p>This is a very good tip.</p></div>

<div class="notice info" >
    <p class="notice-title">
        <span class="icon-notice baseline">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="92 59.5 300 300">
  <path d="M292 303.25V272c0-3.516-2.734-6.25-6.25-6.25H267v-100c0-3.516-2.734-6.25-6.25-6.25h-62.5c-3.516 0-6.25 2.734-6.25 6.25V197c0 3.516 2.734 6.25 6.25 6.25H217v62.5h-18.75c-3.516 0-6.25 2.734-6.25 6.25v31.25c0 3.516 2.734 6.25 6.25 6.25h87.5c3.516 0 6.25-2.734 6.25-6.25Zm-25-175V97c0-3.516-2.734-6.25-6.25-6.25h-37.5c-3.516 0-6.25 2.734-6.25 6.25v31.25c0 3.516 2.734 6.25 6.25 6.25h37.5c3.516 0 6.25-2.734 6.25-6.25Zm125 81.25c0 82.813-67.188 150-150 150-82.813 0-150-67.188-150-150 0-82.813 67.188-150 150-150 82.813 0 150 67.188 150 150Z"/>
</svg>

        </span>Info</p><p>This is a use info.</p></div>

<div class="notice note" >
    <p class="notice-title">
        <span class="icon-notice baseline">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 128 300 300">
  <path d="M150 128c82.813 0 150 67.188 150 150 0 82.813-67.188 150-150 150C67.187 428 0 360.812 0 278c0-82.813 67.188-150 150-150Zm25 243.555v-37.11c0-3.515-2.734-6.445-6.055-6.445h-37.5c-3.515 0-6.445 2.93-6.445 6.445v37.11c0 3.515 2.93 6.445 6.445 6.445h37.5c3.32 0 6.055-2.93 6.055-6.445Zm-.39-67.188 3.515-121.289c0-1.367-.586-2.734-1.953-3.516-1.172-.976-2.93-1.562-4.688-1.562h-42.968c-1.758 0-3.516.586-4.688 1.563-1.367.78-1.953 2.148-1.953 3.515l3.32 121.29c0 2.734 2.93 4.882 6.64 4.882h36.134c3.515 0 6.445-2.148 6.64-4.883Z"/>
</svg>

        </span>Note</p><p>This is a note.</p></div>

]]></content:encoded>
    </item>
    <item>
      <title>A Simple Cmake Example</title>
      <link>http://localhost:1313/blogs/simple_cmake/</link>
      <pubDate>Fri, 06 Jun 2025 18:32:00 +0800</pubDate>
      <guid>http://localhost:1313/blogs/simple_cmake/</guid>
      <description>A Simple Cmake Example</description>
      <content:encoded><![CDATA[<p>CMake 入门教程：从项目结构到链接库</p>
<ol>
<li>核心理念：源码外构建 (Out-of-Source Builds)</li>
</ol>
<p>在开始之前，最重要的一点是理解 CMake 的核心哲学：源码外构建。这意味着所有由构建过程产生的文件（例如 Makefiles、Visual Studio 项目文件、目标文件 .o、可执行文件 .exe、库文件 .a 或 .so）都应该与你的源代码完全分离开。这样做最大的好处是能保持你的源码目录永远干净整洁。我们将创建一个 build 目录来存放所有这些生成的文件。</p>
<ol start="2">
<li>推荐的项目目录结构 📂</li>
</ol>
<p>一个良好组织的 C++ 项目结构不仅清晰，也让 CMake 的配置工作事半功倍。这是一个推荐的、可扩展的目录结构：my_project/</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-plaintext" data-lang="plaintext"><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── build/                  # 构建目录 (初始为空，所有生成文件都在此)
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── include/                # 存放项目全局头文件
</span></span><span class="line"><span class="cl">│   └── my_app/
</span></span><span class="line"><span class="cl">│       └── my_lib.h
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── src/                    # 存放所有源文件 (.cpp)
</span></span><span class="line"><span class="cl">│   │
</span></span><span class="line"><span class="cl">│   ├── main.cpp            # 主程序入口
</span></span><span class="line"><span class="cl">│   │
</span></span><span class="line"><span class="cl">│   └── my_lib/             # 一个独立的库模块
</span></span><span class="line"><span class="cl">│       ├── CMakeLists.txt  # 这个库自己的 CMake 配置文件
</span></span><span class="line"><span class="cl">│       └── my_lib.cpp
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">└── CMakeLists.txt          # 整个项目的顶层 CMake 配置文件
</span></span></code></pre></div><ul>
<li>build/: 这个目录用于执行所有构建命令，源码不会被污染。include/: 存放可以被项目内其他部分（或被其他项目）引用的头文件。按模块组织可以避免头文件名冲突。src/: 存放所有 .cpp 源文件。</li>
<li>src/my_lib/: 将项目按功能模块化是一种好习惯。每个模块（比如一个库）可以有自己的 CMakeLists.txt 文件，负责管理自身的编译。</li>
<li>CMakeLists.txt (顶层): 这是整个项目的入口，负责设置全局配置、找到并构建所有子模块，最后生成主程序。</li>
</ul>
<ol start="3">
<li>编写各层级的 CMakeLists.txt 📝我们将采用“自下而上”的方式来编写配置文件，先从底层的库开始，再到顶层的项目。
第 1 步: 库的 CMakeLists.txt (src/my_lib/CMakeLists.txt</li>
</ol>
<p>)这个文件只负责一件事：将 my_lib.cpp 和相关的头文件编译成一个库。# 文件位置: src/my_lib/CMakeLists.txt</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cmake" data-lang="cmake"><span class="line"><span class="cl"><span class="c"># 使用 add_library 命令创建一个库。
</span></span></span><span class="line"><span class="cl"><span class="c"># 语法: add_library(&lt;库名称&gt; [STATIC | SHARED] &lt;源文件...&gt;)
</span></span></span><span class="line"><span class="cl"><span class="c">#
</span></span></span><span class="line"><span class="cl"><span class="c"># &lt;库名称&gt;: 我们称之为 my_lib，这是其他部分链接此库时使用的名字。
</span></span></span><span class="line"><span class="cl"><span class="c"># STATIC:   生成静态链接库 (.a, .lib)。
</span></span></span><span class="line"><span class="cl"><span class="c"># SHARED:   生成动态/共享链接库 (.so, .dll)。
</span></span></span><span class="line"><span class="cl"><span class="c">#           如果不指定，默认是 STATIC。
</span></span></span><span class="line"><span class="cl"><span class="c"># &lt;源文件&gt;:  用于编译这个库的源文件列表。
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">add_library</span><span class="p">(</span><span class="s">my_lib</span> <span class="s">STATIC</span> <span class="s">my_lib.cpp</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 为这个库目标指定它需要包含的头文件目录。
</span></span></span><span class="line"><span class="cl"><span class="c"># 语法: target_include_directories(&lt;目标&gt; &lt;PUBLIC|PRIVATE|INTERFACE&gt; &lt;路径...&gt;)
</span></span></span><span class="line"><span class="cl"><span class="c">#
</span></span></span><span class="line"><span class="cl"><span class="c"># &lt;目标&gt;:    就是我们上面用 add_library 创建的 my_lib。
</span></span></span><span class="line"><span class="cl"><span class="c"># PUBLIC:   表示此头文件路径不仅 my_lib 自己需要，任何链接了 my_lib 的目标也需要。
</span></span></span><span class="line"><span class="cl"><span class="c">#           这是最关键的设置，它实现了依赖的自动传递。
</span></span></span><span class="line"><span class="cl"><span class="c"># PRIVATE:  表示此头文件路径只有 my_lib 内部编译时需要，不会传递给链接它的目标。
</span></span></span><span class="line"><span class="cl"><span class="c"># INTERFACE:表示此头文件路径只有链接它的目标需要，my_lib 自己编译时不需要。
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">target_include_directories</span><span class="p">(</span><span class="s">my_lib</span>
</span></span><span class="line"><span class="cl">  <span class="s">PUBLIC</span>
</span></span><span class="line"><span class="cl">    <span class="c"># ${PROJECT_SOURCE_DIR} 是一个非常有用的内置变量，指向顶层 CMakeLists.txt 所在的目录。
</span></span></span><span class="line"><span class="cl"><span class="c"></span>    <span class="c"># 我们将项目的全局 include 目录暴露出去。
</span></span></span><span class="line"><span class="cl"><span class="c"></span>    <span class="o">${</span><span class="nv">PROJECT_SOURCE_DIR</span><span class="o">}</span><span class="s">/include</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span></code></pre></div><ul>
<li><code>add_library()</code> 定义了一个编译目标——一个库。</li>
<li><code>target_include_directories()</code> 为这个目标指定了头文件搜索路径。使用 <code>PUBLIC </code>关键字至关重要使得任何链接到 <code>my_lib</code> 的程序都能自动找到 my_lib.h，无需在链接方再次手动添加头文件路径。</li>
</ul>
<p>第 2 步: 顶层的 CMakeLists.txt 这个文件是整个项目的总指挥，负责设置全局配置、调用子模块，并生成最终的可执行文件。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cmake" data-lang="cmake"><span class="line"><span class="cl"><span class="c"># 文件位置: my_project/CMakeLists.txt
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 1. 指定 CMake 的最低版本要求。这是每个顶层文件都应该有的第一行。
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.10</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 2. 定义项目信息。
</span></span></span><span class="line"><span class="cl"><span class="c"># 语法: project(&lt;项目名称&gt; VERSION &lt;版本号&gt; LANGUAGES &lt;语言&gt;)
</span></span></span><span class="line"><span class="cl"><span class="c"># 这会创建一些有用的变量，比如 PROJECT_NAME, PROJECT_SOURCE_DIR。
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">project</span><span class="p">(</span><span class="s">MyApp</span> <span class="s">VERSION</span> <span class="s">1.0</span> <span class="s">LANGUAGES</span> <span class="s">CXX</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 3. 设置 C++ 标准 (这是现代 CMake 推荐的方式)。
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_CXX_STANDARD</span> <span class="s">17</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_CXX_STANDARD_REQUIRED</span> <span class="s">ON</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_CXX_EXTENSIONS</span> <span class="s">OFF</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 4. 打印一条消息，方便调试时查看变量值 (可选)。
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;Project source directory is: ${PROJECT_SOURCE_DIR}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 5. 添加子目录。
</span></span></span><span class="line"><span class="cl"><span class="c"># 这个命令会告诉 CMake 去处理 src/my_lib 目录下的 CMakeLists.txt 文件。
</span></span></span><span class="line"><span class="cl"><span class="c"># 当执行到这里时，上面定义的 my_lib 库目标就会被创建出来。
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">add_subdirectory</span><span class="p">(</span><span class="s">src/my_lib</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 6. 添加可执行文件。
</span></span></span><span class="line"><span class="cl"><span class="c"># 语法: add_executable(&lt;可执行文件名&gt; &lt;源文件...&gt;)
</span></span></span><span class="line"><span class="cl"><span class="c"># 我们将主程序命名为 app，它由 src/main.cpp 编译而来。
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">add_executable</span><span class="p">(</span><span class="s">app</span> <span class="s">src/main.cpp</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 7. 链接库！这是将所有部分组合在一起的关键步骤。
</span></span></span><span class="line"><span class="cl"><span class="c"># 语法: target_link_libraries(&lt;目标&gt; &lt;PUBLIC|PRIVATE|INTERFACE&gt; &lt;要链接的库...&gt;)
</span></span></span><span class="line"><span class="cl"><span class="c">#
</span></span></span><span class="line"><span class="cl"><span class="c"># &lt;目标&gt;: 我们要链接的目标，即 app。
</span></span></span><span class="line"><span class="cl"><span class="c"># PRIVATE: 表示 app 的编译需要 my_lib，但这个依赖关系不会继续传递。
</span></span></span><span class="line"><span class="cl"><span class="c">#          对于可执行文件，通常使用 PRIVATE。
</span></span></span><span class="line"><span class="cl"><span class="c"># &lt;要链接的库&gt;: 我们在子目录中定义的库目标 my_lib。
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">target_link_libraries</span><span class="p">(</span><span class="s">app</span> <span class="s">PRIVATE</span> <span class="s">my_lib</span><span class="p">)</span><span class="err">
</span></span></span></code></pre></div><ul>
<li>add_subdirectory() 使得顶层文件保持简洁，只负责“指挥”，具体实现则交给各个子模块。</li>
<li>target_link_libraries() 负责将不同的编译目标（库和可执行文件）链接在一起，形成依赖关系。</li>
</ul>
<ol start="4">
<li>如何构建项目 🚀
现在已经写好了所有的 CMakeLists.txt 文件，可以开始构建了。整个过程都在终端中完成。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># 1. 确保你位于项目的根目录 (my_project)</span>
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> path/to/my_project
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 2. 创建并进入我们规划好的 build 目录</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">mkdir build
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> build
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 3. 运行 CMake 来生成构建系统。</span>
</span></span><span class="line"><span class="cl"><span class="c1"># &#39;..&#39; 指向上一级目录，也就是 my_project/ 根目录，CMake 会在那里寻找顶层的 CMakeLists.txt。</span>
</span></span><span class="line"><span class="cl"><span class="c1"># -DCMAKE_BUILD_TYPE=Debug 指定了构建类型为 Debug，会包含调试信息。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">cmake -DCMAKE_BUILD_TYPE<span class="o">=</span>Debug ..
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># CMake 会扫描你的系统，找到 C++ 编译器，然后根据 CMakeLists.txt 的内容</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 生成特定平台的构建文件（在 Linux/macOS 上是 Makefile，在 Windows 上是 Visual Studio sln 文件）。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 4. 编译项目</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 这个命令会调用底层的构建工具（如 make 或 msbuild）来执行真正的编译和链接工作。</span>
</span></span><span class="line"><span class="cl"><span class="c1"># &#39;--build .&#39; 是一个平台无关的命令，告诉 CMake 在当前目录执行构建。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">cmake --build .
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 或者在 Linux/macOS 上，你可以直接运行:</span>
</span></span><span class="line"><span class="cl"><span class="c1"># make</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 编译完成后，你会在 build 目录（或其子目录）下找到你的可执行文件 `app` 和库文件 `libmy_lib.a`。</span>
</span></span></code></pre></div>]]></content:encoded>
    </item>
    <item>
      <title>How to Use git rebase</title>
      <link>http://localhost:1313/blogs/git-rebase-flow/</link>
      <pubDate>Fri, 06 Jun 2025 17:38:00 +0800</pubDate>
      <guid>http://localhost:1313/blogs/git-rebase-flow/</guid>
      <description>Use of git rebase</description>
      <content:encoded><![CDATA[<h1 id="what-can-git-rebase-do">What Can git rebase Do</h1>
<p><code>rebase</code> 的字面意思是“变基”——也就是改变一个分支的“基础”提交点。它的主要目标是：将一系列的提交以更整洁、线性的方式应用到另一个分支上，从而创造一个干净、没有多余合并记录的项目历史。</p>
<p>假设你的项目历史是这样的：你在 main 分支上切出了一个 feature 分支，之后 main 分支和你自己的 feature 分支都有了新的 commits.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-plaintext" data-lang="plaintext"><span class="line"><span class="cl">      A---B---C   &lt;-- feature
</span></span><span class="line"><span class="cl">     /
</span></span><span class="line"><span class="cl">D---E---F---G   &lt;-- main
</span></span></code></pre></div><p>如果你在 feature 分支上运行 git rebase main，Git 会做一件非常神奇的事：</p>
<ol>
<li>Git 会暂时“收起” feature 分支上的所有提交 (A, B, C).</li>
<li>将 feature 分支的起点移动到 main 分支的最新提交 G 上。</li>
<li>把刚才收起的提交 (A, B, C) 依次重新应用到新的起点上，形成新的提交 A&rsquo;, B&rsquo;, C'</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-plaintext" data-lang="plaintext"><span class="line"><span class="cl">              A&#39;--B&#39;--C&#39;  &lt;-- feature
</span></span><span class="line"><span class="cl">             /
</span></span><span class="line"><span class="cl">D---E---F---G   &lt;-- main
</span></span></code></pre></div><p><strong>A&rsquo; 和 A 的内容虽然一样，但它们的 Commit ID 是不同的，因为它们的父提交变了。rebase 相当于重写了历史。</strong></p>
<p>现在，再切换回 main 分支，执行 <code>git merge feature</code>，由于 main 分支的所有历史现在是 feature 分支历史的子集，Git 只会进行一次 Fast-forward 合并，不会产生新的合并提交。最终结果如下</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-plaintext" data-lang="plaintext"><span class="line"><span class="cl">D---E---F---G---A&#39;--B&#39;--C&#39;  &lt;-- main, feature
</span></span></code></pre></div><p>最终的项目历史是一条完美的直线，非常清晰，就像所有开发都是按顺序发生的一样。rebase 重写了历史，抹去了分支开发的“并行”痕迹。</p>
<h1 id="compared-to-merge">Compared to merge</h1>
<p>要理解 rebase，最好的方法就是和 merge 对比。如果在 main 分支上运行 <code>git merge feature</code>，结果会是这样</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-plaintext" data-lang="plaintext"><span class="line"><span class="cl">      A---B---C
</span></span><span class="line"><span class="cl">     /         \
</span></span><span class="line"><span class="cl">D---E---F---G---H   &lt;-- main (H 是一个合并提交)
</span></span></code></pre></div><p><code>merge</code> 做的事情是：</p>
<ol>
<li>找到两个分支的共同祖先 E.</li>
<li>将两个分支的修改整合起来，创建一个全新的 Merge Commit，也就是 H. 该提交有两个父提交点 C 和 G.</li>
</ol>
<p>merge 完全全保留了历史的真实性。它清楚地记录了“在某个时间点，我们把一个分支合并了进来”。但如果项目频繁合并，历史记录会充满大量的合并提交，形成一个复杂的“菱形”或“意大利面条”式的网状结构，难以阅读。</p>
<h1 id="how-to-use-rebase">How to use rebase</h1>
<p>假设你正在 feature-login 分支上开发，同时主分支 main 也有了新的更新。</p>
<ol>
<li>确保 main 分支处于最新的状态</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">git checkout main
</span></span><span class="line"><span class="cl">git pull origin main
</span></span></code></pre></div><ol start="2">
<li>切换到你正在开发的分支 <code>git checkout feature-login</code></li>
<li>把 main 分支上的最新修改 rebase 到你当前的 feature-login 分支上 <code>git rebase main</code></li>
<li>解决冲突 (如果有的话). 因为 rebase 是逐个应用提交，所以可能会在某个提交应用时发生冲突。此时，rebase 会暂停。
<ul>
<li>打开冲突文件，手动解决冲突（和 merge 冲突一样）。</li>
<li>解决后，使用 <code>git add &lt;filename&gt;</code> 将文件标记为已解决。</li>
<li>然后，继续 rebase 过程 <code>git rebase --continue</code></li>
<li>如果中途想放弃，可以回到 rebase 开始前的状态 <code>git rebase --abort</code></li>
</ul>
</li>
<li>合并到主分支
rebase 成功后，你的 feature-login 分支就已经包含了 main 的所有更新，并且<strong>你的提交都在最前面</strong>。现在可以进行一次干净的快进合并。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">git checkout main
</span></span><span class="line"><span class="cl">git merge feature-login
</span></span></code></pre></div><h1 id="when-not-to-use-rebase">When NOT to Use rebase</h1>
<p>**永远不要对一个已经推送到 remote，并且可能被团队其他人使用的公共分支 (如 main, develop)进行 rebase！**因为 rebase 会重写历史。如果你 rebase 了一个公共分支并强制推送 (<code>git push --force</code>)，那么所有团队成员的本地历史记录都将与远程的“新历史”产生严重分歧。</p>
<p>正确用法是只在你自己的、还未与他人分享的本地分支上使用 rebase，用来整理你自己的提交记录，以便在合并到公共分支前有一个干净的历史。</p>
<h1 id="advanced-use-git-rebase--i">Advanced Use git rebase -i</h1>
<p><code>git rebase -i</code> 允许你在 rebase 的过程中，对你的提交进行编辑、合并、拆分或删除。这常用于在合并到 main 分支前，将自己本地凌乱的提交（如 &ldquo;修复拼写错误&rdquo;, &ldquo;临时提交&rdquo;, &ldquo;又改了一点&rdquo;）整理成几个有意义的提交。</p>
<p>假设你的 feature-login 分支有 3 个凌乱的提交，你想把它们合并成一个。</p>
<ol>
<li>启动交互式 rebase <code>git rebase -i HEAD~3</code>. 其中 <code>HEAD~3</code> 表示从当前提交 (HEAD) 往前数 3 个提交。</li>
<li>编辑 Rebase 脚本
Git 会打开一个文本编辑器，列出这 3 个提交：</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-plaintext" data-lang="plaintext"><span class="line"><span class="cl">pick a31ab34 complete login UI
</span></span><span class="line"><span class="cl">pick 58c34bb fix a button bug
</span></span><span class="line"><span class="cl">pick 948f2cb add backend verify logic
</span></span></code></pre></div><p>在文件下方会有指令说明。你可以修改每一行前面的 pick 命令。比如，我们想把后两个提交合并到第一个里面：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-plaintext" data-lang="plaintext"><span class="line"><span class="cl">pick a31ab34 complete login UI
</span></span><span class="line"><span class="cl">squash 58c34bb fix a button bug
</span></span><span class="line"><span class="cl">squash 948f2cb add backend verify logic
</span></span></code></pre></div><ol start="3">
<li>保存并退出编辑器
Git 会开始合并提交，并弹出另一个编辑器，让你为这个合并后的新提交编写一个新的 commit message. 整理好后保存退出。现在再用 <code>git log</code> 查看，你会发现原来 3 个凌乱的提交已经变成了一个干净、完整的提交。</li>
</ol>
]]></content:encoded>
    </item>
  </channel>
</rss>
