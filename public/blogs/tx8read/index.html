<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Tx8read | WITHER</title>
<meta name="keywords" content="bsh">
<meta name="description" content="tx8 regression">
<meta name="author" content="WITHER">
<link rel="canonical" href="http://localhost:1313/blogs/tx8read/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.dd3b5b907a50db3238b81d49d094cf1c04a091227797dc9cfde4e2fa3f35df49.css" integrity="sha256-3TtbkHpQ2zI4uB1J0JTPHASgkSJ3l9yc/eTi&#43;j8130k=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/blogs/tx8read/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<script>
  MathJax = {
    tex: {
      displayMath: [['\\[', '\\]'], ['$$', '$$']],  
      inlineMath: [['\\(', '\\)'], ['$', '$']]  
    }
  };
</script>




<script src="https://cdn.bootcdn.net/ajax/libs/mermaid/9.1.6/mermaid.min.js"></script>
<script>
    mermaid.initialize({
        startOnLoad: true,
        theme: localStorage.getItem("pref-theme") === "dark" ? "dark" : "forest" 
    });
</script>

<meta property="og:url" content="http://localhost:1313/blogs/tx8read/">
  <meta property="og:site_name" content="WITHER">
  <meta property="og:title" content="Tx8read">
  <meta property="og:description" content="tx8 regression">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="blogs">
    <meta property="article:published_time" content="2025-06-11T10:21:42+08:00">
    <meta property="article:modified_time" content="2025-06-13T15:12:24+08:00">
    <meta property="article:tag" content="Tx8-Script">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Tx8read">
<meta name="twitter:description" content="tx8 regression">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Blogs",
      "item": "http://localhost:1313/blogs/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Tx8read",
      "item": "http://localhost:1313/blogs/tx8read/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Tx8read",
  "name": "Tx8read",
  "description": "tx8 regression",
  "keywords": [
    "bsh"
  ],
  "articleBody": "TestGraphCompute 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 int main(int argc, char **argv) { // 1. 初始化与命令行参数处理 Timer timer(\"TestGraphCompute\"); mlir::registerAsmPrinterCLOptions(); mlir::registerMLIRContextCLOptions(); mlir::registerPassManagerCLOptions(); // 解析命令行参数 cl::ParseCommandLineOptions(argc, argv, \"tx8be compiler\\n\"); // 2. 初始化 MLIR 模块和上下文 mlir::OwningOpRef\u003cmlir::ModuleOp\u003e module; mlir::MLIRContext context; // 定义一个正则表达式，用于从命令行选项中提取 codegen_path 参数 std::regex pattern(\"codegen_path=([a-zA-Z0-9_]+)\"); std::smatch matches; std::string cachePath = \"codegen\"; // 默认文件夹名字 if (std::regex_search(optionstr, matches, pattern)) { // 寻找命令行选项中是否指定 codegen_path cachePath = matches[1]; // 3. 加载 MLIR 模块 // 如果 cache 为 2 或 4，则从缓存路径加载模块；否则，使用默认的 gModelFil gModelFile = (cache == 2 || cache == 4) ? cachePath + \"/cache.mlir\" : gModelFile; if (int error = getMLIRFromFile(module, context, gModelFile)) { return error; } // 4. 配置模块 auto mconfig = getModuleConfig(module.get()); if (optionstr.size() \u003e 0) { mconfig.option += optionstr; } mconfig.constCache = cache; updateModuleConfig(module, context, mconfig); mconfig = getModuleConfig(module.get()); showModuleConfig(mconfig); // 5. 处理多卡信息 json_info_multi_card_t *multi_card_jinfo = nullptr; multi_card_jinfo = (cache == 2 || cache == 4) ? get_multi_card_info_from_file(cachePath + \"/model_info.json\") : parseMultiCardModuleInfo(module, context); if (0) { dumpIR(module.get(), true); } // 6. 读取参考路径 if (!fast_codegen) { // NOT fast_codegen std::vector\u003cstd::string\u003e in_files = parseStringArgs(gInputBin, std::string(\",\")); std::vector\u003cstd::string\u003e out_files = parseStringArgs(gOutputBin, std::string(\",\")); // 定义一个 lambda 函数，用于从文件中读取参考文件路径。 auto getRefFiles = [] (std::string gFile, std::vector\u003cstd::string\u003e \u0026files) { if (gFile.size() == 0) { return 0; } if (!llvm::sys::fs::exists(gFile)) { return 0; } std::ifstream gf(gFile); std::string text((std::istreambuf_iterator\u003cchar\u003e(gf)), (std::istreambuf_iterator\u003cchar\u003e())); files = parseStringArgs(text, std::string(\",\")); return 0; }; if ((gInputBin.size() == 0) \u0026\u0026 (gInputFile.size() != 0)) { getRefFiles(gInputFile, in_files); getRefFiles(gOutputFile, out_files); } } // 7. computeGolden if (cache \u003c 2) { for (int32_t i = 0; i \u003c mconfig.tile.chip_num; i++) { // 遍历芯片数量，创建对应的目录结构 // 构造并创建创建目 codegen/node_0_0/chip0/agent/data std::string path = \"codegen/node_0_0/chip\"; path += std::to_string(i) + \"/agent/data\"; createDir(path); } // 调用 computeGolden 函数，计算参考输出保存到 codegenPath computeGolden(module, multi_card_jinfo, in_files, out_files, mconfig.codegenPath); } // 调用 moduleCompileCodegen 函数，对 MLIR 模块进行编译和代码生成 int32_t ret = moduleCompileCodegen(module, context); ASSERT(ret == true); // 9. 获取内存大小 // 从模块中获取立即数 (Immediate) 和常量参数的 DDR 大小 uint64_t imm_size = module.get()-\u003ehasAttr(tx8be::ModuleAttr::ImmDdrSize) ? module.get()-\u003egetAttrOfType\u003cmlir::IntegerAttr\u003e(tx8be::ModuleAttr::ImmDdrSize).getInt() : 2147483648; uint64_t params_size = module.get()-\u003ehasAttr(tx8be::ModuleAttr::ConstDdrSize) ? module.get()-\u003egetAttrOfType\u003cmlir::IntegerAttr\u003e(tx8be::ModuleAttr::ConstDdrSize).getInt() : 0; // 10. 更新每个芯片的内存大小信息 for (int32_t i = 0; i \u003c mconfig.tile.chip_num; i++) { multi_card_jinfo-\u003echip_infos[i]-\u003eimm_size = imm_size; multi_card_jinfo-\u003echip_infos[i]-\u003eparams_size.emplace_back(params_size); } // 11. 保存多卡模型信息 std::vector\u003cint32_t\u003e chipIds; if (module.get()-\u003ehasAttr(tx8be::ModuleAttr::ChipIds)) { // 获取芯片 ID mlir::ArrayAttr chipIdsAttr = module.get()-\u003egetAttrOfType\u003cmlir::ArrayAttr\u003e(tx8be::ModuleAttr::ChipIds); for (int i = 0; i \u003c chipIdsAttr.size(); i++) { chipIds.push_back(chipIdsAttr[i].cast\u003cmlir::IntegerAttr\u003e().getInt()); } } // 多卡模型文件保存到 codegenPath 路径下 saveMultiCardModelJson(multi_card_jinfo, mconfig.codegenPath, chipIds); // uint64_t ddrSize = getModelDDRSize(multi_card_jinfo); return 0; } } computeGolden 输入参数的来源：\nmodule：在 main 文件中，通过 getMLIRFromFile 函数从文件中加载 MLIR 模块 multi_card_jinfo：在 main 文件中，通过 get_multi_card_info_from_file 或 parseMultiCardModuleInfo 从 JSON 文件或 MLIR 模块中提取多卡信息。 in_files 和 out_files：在 main 文件中，通过 parseStringArgs 或 getRefFiles 解析输入和输出文件路径。 mconfig.codegenPath：在 main 文件中，通过命令行选项或默认值设置代码生成路径，并传递给 computeGolden。 computeGolden 函数生成的数据（输入和输出的二进制文件）将保存到指定路径 mconfig.codegenPath.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 void computeGolden(mlir::OwningOpRef\u003cmlir::ModuleOp\u003e \u0026module, json_info_multi_card_t *multi_card_jinfo, std::vector\u003cstd::string\u003e \u0026inFiles, std::vector\u003cstd::string\u003e \u0026outFiles, std::string file_path) { // 定义形状类型，用于存储多维张量的形状信息 using ShapeType = std::vector\u003cstd::vector\u003cint64_t\u003e\u003e; // 用于存储多芯片的输入和输出数据 std::vector\u003cstd::vector\u003cint8_t *\u003e\u003e multiInputDdata; std::vector\u003cstd::vector\u003cint8_t *\u003e\u003e multiOutputData; std::vector\u003cstd::thread\u003e threads; uint32_t chip_num = multi_card_jinfo-\u003echip_num; // 获取芯片数量 auto tile_info = get_tileinfo(module.get()); // 从 MLIR 模块中提取 tile 信息 std::vector\u003cShapeType\u003e outShapes(chip_num); // 存储每个芯片的输出形状信息 for (int i = 0; i \u003c chip_num; i++) { chip_info_t *chip_info = multi_card_jinfo-\u003echip_infos[i]; // 分配当前芯片的输入和输出数据指针数组 std::vector\u003cint8_t *\u003e input_data(chip_info-\u003einput_num); std::vector\u003cint8_t *\u003e output_data(chip_info-\u003eoutput_num); // 用于 OneDNN 计算的输入和输出缓冲区 std::vector\u003cchar *\u003e computeInputs; std::vector\u003cchar *\u003e computeOutputs; // 当前芯片的输入和输出文件路径 std::vector\u003cstd::string\u003e chipInFiles; std::vector\u003cstd::string\u003e chipOutFiles; parseInOutfile(inFiles, chipInFiles, i, chip_num, chip_info-\u003einput_num); parseInOutfile(outFiles, chipOutFiles, i, chip_num, chip_info-\u003eoutput_num); // 生成当前芯片的输入输出数据 genInputs4SingleChip(computeInputs, input_data, chip_info, chipInFiles); genOutputs4SingleChip(computeOutputs, output_data, chip_info, chipOutFiles); // 如果输入文件为空，则生成随机输入数据并校正 if (chipInFiles.size() == 0) { updateSpecialInputData(computeModuleRef, computeInputs, input_data, chip_info); } multiInputDdata.push_back(input_data); multiOutputData.push_back(output_data); if (outFiles.size() == 0) { threads.emplace_back(moduleComputeInterface, std::ref(computeModuleRef), std::ref(outShapes[i]), computeInputs, computeOutputs, i); } } // 等待所有线程完成计算 for (auto \u0026thread : threads) { thread.join(); } // 遍历每个芯片，保存输入和输出数据 for (int32_t i = 0; i \u003c chip_num; i++) { chip_info_t *chip_info = multi_card_jinfo-\u003echip_infos[i]; uint32_t node_id = get_node_id(i, tile_info); int32_t relative_chip_id = get_relative_chip_id(i, tile_info); // 构造当前芯片的数据保存路径 file_path/node_x_y/chip_z/agent/data std::string data_path = file_path + \"/node_\" + std::to_string(node_id / tile_info.node_y) + \"_\" + std::to_string(node_id % tile_info.node_y) + \"/chip\" + std::to_string(relative_chip_id) + \"/agent/data\"; createDir(data_path); // bin格式保存当前芯片的输入数据 for (uint32_t j = 0; j \u003c chip_info-\u003einput_num; j++) { inout_tensor_info_t *tensor = chip_info-\u003einput[j]; saveInOutTensor(tensor-\u003eshape, tensor-\u003edim, tensor-\u003elayout, tensor-\u003edtype, data_path + \"/in\" + std::to_string(j) + \".bin\", multiInputDdata[i][j]); } // bin格式保存当前芯片的输出数据 out_j_ref.bin for (uint32_t j = 0; j \u003c chip_info-\u003eoutput_num; j++) { inout_tensor_info_t *tensor = chip_info-\u003eoutput[j]; int32_t tensorShape[MAX_SHAPE_DIM]; // 根据 outShapes 或原始形状计算输出张量的形状 for (int idx = 0; idx \u003c tensor-\u003edim; ++idx) { if (!outShapes[i].empty()) { tensorShape[idx] = outShapes[i][j][idx]; } else { tensorShape[idx] = tensor-\u003eshape[idx]; } } // 保存输出数据 saveInOutTensor(tensorShape, tensor-\u003edim, tensor-\u003elayout, tensor-\u003edtype, data_path + \"/out\" + std::to_string(j) + \"_ref.bin\", multiOutputData[i][j]); } // 释放当前芯片的输入和输出数据内存 for (uint32_t j = 0; j \u003c chip_info-\u003einput_num; j++) { free(multiInputDdata[i][j]); } for (uint32_t j = 0; j \u003c chip_info-\u003eoutput_num; j++) { free(multiOutputData[i][j]); } } } run_code_gen_layer 主要用于运行代码生成 (codegen) 相关的任务，以下是函数的详细功能解释：\n解析参数： 接受至少两个参数：$1 是可执行文件的名称，$2 是种子文件 (seed file) 如果有更多参数 ($# \u003e 2)，则将额外参数存储为配置参数 (config_params) 从 config_params 中提取 codegen_path (代码生成输出路径) ，如果未指定则使用默认值 “codegen” 切换工作目录： 切换到 ${BEMLIR_PROJECT_ROOT}/build/bin 目录。 删除旧的 codegen_path 目录，确保环境干净。 执行可执行文件： 使用 ${layer_cmd} (即 ./$1) 运行指定的可执行文件，传入种子文件和配置参数。 检查返回值，如果失败 (ret != 0)，则恢复目录并返回错误。 处理生成的代码： 根据参数中的 chip_num 或 static_shape 判断 host_type. 调用 get_codegen_file 处理生成的代码文件。 运行 cmodel 测试: 根据参数中的 fast_codegen 或 not_run 设置 cmp_flag. 调用 run_on_cmodel 在 cmodel 上运行生成的代码。 检查返回值，失败则返回错误。 # 定义 run_codegen_layer 函数，用于运行代码生成层测试流程 function run_codegen_layer() { # 1. 打印开始时间，用于调试和性能追踪 echo -n \"time==\u003e\u003erun_codegen_layer-start \"; date; # 2. 函数参数说明 # $1: 可执行文件名称 # $2: 种子文件 (seed file） layer_cmd=\"./$1\" # 在当前目录下执行的可执行文件路径 seed_file=$2 # 种子文件或配置文件 config_params=\"\" # 配置参数，默认为空 # 默认代码生成输出路径 codegen_path=\"codegen\" # 3. 检查是否有超过2个参数 if [ $# -gt 2 ]; then # 提取除前两个参数外的所有参数作为配置参数 config_params=$* config_params=${config_params#*} # 移除第一个参数 (可执行文件） config_params=${config_params#*} # 移除第二个参数 (种子文件） fi # 4. 如果配置参数中包含 --codegen_path，提取其值作为代码生成路径 if [[ ${config_params} == *\"--codegen_path=\"* ]]; then # 提取 --codegen_path= 后面的值 codegen_path=${config_params#*codegen_path=} # 移除可能存在的引号或其他字符 codegen_path=${codegen_path%%\\\"*} codegen_path=${codegen_path-*} codegen_path=${codegen_path*} fi # 5. 切换到 build/bin 目录执行命令 pushd ${BEMLIR_PROJECT_ROOT}/build/bin # 删除旧的 codegen_path 目录，确保环境干净 rm -rf ${codegen_path} # 执行层命令，传入种子文件和配置参数 ${layer_cmd} ${seed_file} ${config_params} # 捕获命令的返回值 ret=$? # 如果命令执行失败 (返回码非0），恢复目录并返回错误 if [[ ${ret} -ne 0 ]]; then popd echo ${ret} return ${ret} fi popd # 恢复原始目录 # 6. 打印代码生成完成的时间 echo -n \"time==\u003e\u003erun_codegen_layer-codegen=== \"; date; # 7. 根据参数判断主机类型 host_type=0 # 如果参数中包含 chip_num 或 static_shape，则将 host_type 设为 1 if [[ $* == *\"chip_num\"* ]] || [[ $* == *\"static_shape\"* ]]; then host_type=1 fi # 8. 调用 get_codegen_file 处理生成的代码文件 get_codegen_file ${codegen_path} ${host_type} # 捕获返回值 ret=$? # 如果处理失败，恢复目录并返回错误 if [[ ${ret} -ne 0 ]]; then popd echo ${ret} return ${ret} fi # 9. 初始化比较标志 cmp_flag=\"\" # 如果参数中包含 fast_codegen 或 not_run，则设置 cmp_flag 为 \"not_run\" if [[ $* == *\"fast_codegen\"* ]] || [[ $* == *\"not_run\"* ]]; then cmp_flag=\"not_run\" fi # 10. 在 cmodel 上运行生成的代码，传入比较标志 run_on_cmodel ${codegen_path} ${cmp_flag} # 捕获返回值 ret=$? # 如果运行失败，恢复目录并返回错误 if [[ ${ret} -ne 0 ]]; then popd echo ${ret} return ${ret} fi # 11. 打印结束时间 echo -n \"time==\u003e\u003erun codegen layer-end=== \"; date; } get_codegen_file get_codegen_file 用于整理代码生成的结果 (位于 ${BEMLIR_PROJECT_ROOT}/build/bin/${codegen_case})，为每个节点生成版本信息 (version.txt)，并将生成的文件复制到测试目录 (${BEMLIR_PROJECT_ROOT}/external/tx8be-oplib/tests/test_codegen)，最后调用 get_codegen_host 完成主机相关处理。\n# Function to process and organize generated codegen files function get_codegen_file() { # Print all input arguments for debugging echo \"$*\" # Assign first argument as the codegen case name or path codegen_case=$1 # Second argument: 0 for host thread mode, 1 for host stream mode # Note: $2 is passed to get_codegen_host # Change to the codegen case directory under build/bin pushd \"${BEMLIR_PROJECT_ROOT}/build/bin/${codegen_case}\" # Find node directories matching node_[0-9]+_[0-9] pattern (e.g., node_123_4) node_dirs=$(find . -maxdepth 1 -type d -regex '.*/node_[0-9]+_[0-9]' -exec basename {} \\;) # Iterate through each node directory for dir in $node_dirs; do # Check if libTX8MLIRTransforms.a exists to determine version type if [ ! -e \"${BEMLIR_PROJECT_ROOT}/lib/libTX8MLIRTransforms.a\" ]; then # Write 'tx8be-mlir' to version.txt if library is absent echo -e \"tx8be-mlir\" \u003e \"${dir}/version.txt\" else # Write 'tx8be-mlir-sdk' to version.txt if library is present echo -e \"tx8be-mlir-sdk\" \u003e \"${dir}/version.txt\" fi # Append git status to version.txt to record repository state git status --porcelain \u003e\u003e \"${dir}/version.txt\" # Append last two git commits to version.txt for version history git log -2 \u003e\u003e \"${dir}/version.txt\" done popd # Change to the test_codegen directory pushd \"${BEMLIR_PROJECT_ROOT}/external/tx8be-oplib/tests/test_codegen\" # Remove existing codegen_case directory to ensure a clean state rm -rf \"${codegen_case}\" # Copy the codegen_case directory from build/bin cp -r \"${BEMLIR_PROJECT_ROOT}/build/bin/${codegen_case}\" . popd # Call get_codegen_host to process host-related tasks get_codegen_host \"${codegen_case}\" \"$2\" } get_codegen_host get_codegen_host 用于为 host 环境准备代码生成用例的测试文件。它在指定的测试用例目录中处理 node \u0026 chip 相关的文件，复制必要的配置文件、源代码和构建脚本，并根据 host_type 选择不同的主机实现文件 host_thread.cpp 或 host_stream.cpp.\n函数输入参数： $1 (codegen_case): 代码生成用例的名称或路径，通常是一个目录 (例如 codegen0 或 codegen1) ，表示测试用例的根目录。 $2 (host_type): 主机执行模式，0: host_thread.cpp，1: host_stream.cpp. 切换到 ${{OPLIB_PROJECT_ROOT}}/tests/test_codegen/${codegen_case} 目录: 使用 find 命令查找符合 node_[0-9]+_[0-9] 模式 (例如 node_123_4) 的子目录，表示代码生成中的节点。 对每个 node_dir 追加版本信息和复制相关文件。 处理 chip 目录: 在每个节点目录下，查找符合 chip[0-9]+ 模式 (例如 chip0, chip1) 的子目录 为每个 dir 复制 Makefile_tile 到 ./${node_dir}/${dir}/Makefile. 在 ./${node_dir}/${dir}/ 下创建 16 个子目录 (tiles0 - tiles15)，并为每个子目录复制 Makefile_main 到 t iles$i/Makefile 根据 host_type 复制 host_thread.cpp 或 host_stream.cpp 到当前目录的 host.cpp. 复制 CMakeLists.txt 和 Makefile 到当前目录。 # Function to prepare host-related files for a codegen test case function get_codegen_host() { # Print all input arguments for debugging echo \"$*\" # Assign first argument as the codegen case name or path codegen_case=$1 # Assign second argument as host type (0: thread mode, 1: stream mode) host_type=$2 # Define relative path for test_codegen directory oplib_path=\"tests/test_codegen\" # Change to the test_codegen directory for the codegen case pushd \"${{OPLIB_PROJECT_ROOT}}/tests/test_codegen/${codegen_case}\" # Find node directories matching node_[0-9]+_[0-9] pattern (e.g., node_123_4) node_dirs=$(find . -maxdepth 1 -type d -regex '.*/node_[0-9]+_[0-9]' -exec basename {} \\;) for node_dir in $node_dirs; do # # Iterate through each node directory # Append oplib version info to version.txt echo -e \"\\n\\ntx8be-oplib:\" \u003e\u003e \"${node_dir}/version.txt\" # Append git status to version.txt to record repository state git status --porcelain \u003e\u003e \"${node_dir}/version.txt\" # Write last two git commits to version.txt for version history git log -2 \u003e\u003e \"${node_dir}/version.txt\" # Copy all stream-related files to node directory cp \"${{OPLIB_PROJECT_ROOT}}/tools/codegen/stream*\" \"./${node_dir}/\" # Copy CMakeLists_chip.txt as CMakeLists.txt for node cp \"${{OPLIB_PROJECT_ROOT}}/tools/codegen/CMakeLists_chip.txt\" \"./${node_dir}/CMakeLists.txt\" # Copy main_kcore.c to node directory cp \"${{OPLIB_PROJECT_ROOT}}/tools/codegen/main_kcore.c\" \"./${node_dir}/\" # Copy Makefile_chip as Makefile for node cp \"${{OPLIB_PROJECT_ROOT}}/tools/codegen/Makefile_chip\" \"./${node_dir}/Makefile\" # Find chip directories matching chip[0-9]+ pattern (e.g., chip0, chip1) chip_dirs=$(find \"./${node_dir}\" -maxdepth 1 -type d -regex '.*/chip[0-9]+' -exec basename {} \\;) # Iterate through each chip directory for dir in $chip_dirs; do # Copy Makefile_tile as Makefile for chip cp \"${{OPLIB_PROJECT_ROOT}}/tools/codegen/Makefile_tile\" \"./${node_dir}/${dir}/Makefile\" # Create Makefiles for 16 tiles (tiles0 to tiles15) for ((i=0; i\u003c16; i++)); do dst_file=\"./${node_dir}/${dir}/tiles${i}/Makefile\" # Copy Makefile_main to each tile's Makefile cp \"${{OPLIB_PROJECT_ROOT}}/tools/codegen/Makefile_main\" \"$dst_file\" done done done # Copy host implementation based on host_type if [ $host_type -eq 0 ]; then # Use thread-based host implementation cp \"${{OPLIB_PROJECT_ROOT}}/tools/codegen/host_thread.cpp\" \"host.cpp\" else # Use stream-based host implementation # Note: Fixed typo '$t{OPLIB_PROJECT_ROOT}' to '${{OPLIB_PROJECT_ROOT}}' cp \"${{OPLIB_PROJECT_ROOT}}/tools/codegen/host_stream.cpp\" \"host.cpp\" fi # Copy top-level CMakeLists.txt for test case cp \"${{OPLIB_PROJECT_ROOT}}/tools/codegen/CMakeLists.txt\" . # Copy top-level Makefile for test case cp \"${{OPLIB_PROJECT_ROOT}}/tools/codegen/Makefile\" . # Restore original directory popd } run_on_cmodel run_on_cmodel 用于在指定的测试用例目录中运行 cmodel 仿真任务。函数的主要功能包括环境设置、构建、执行仿真脚本或程序，并处理错误。以下是详细的功能说明：\n函数输入参数： $1 (case_name): 来自 run_codegen_layer 的 codegen_path，可能附加 host_type. $2 (run_flag): 运行标志，来自 run_codegen_layer 的 cmp_flag 用于控制仿真执行的方式 (例如是否运行或运行模式) 。 切换工作目录并执行: 切换到测试用例目录 ${{OPLIB_PROJECT_ROOT}}/tests/test_codegen/${case_name} 运行 cmake .. -DUSING_RISCV=OFF，配置构建系统，禁用 RISCV 支持。 运行 make -j 并动态设置并行任务数 (基于 CPU 核心数，cat /proc/stat | grep cpu[0-9] -c) 仿真执行: 根据参数运行仿真脚本 (host_sim.sh) 或 host_sim. # Function to run a cmodel simulation for a given test case function run_on_cmodel() { # Assign first argument as the test case name case_name=$1 # Assign second argument as the run flag (controls execution mode) run_flag=$2 # Check if case_name is empty if [ -z \"$case_name\" ]; then echo \"Error: case_name is empty\" return 1 fi # Check if the test case directory exists if [ ! -d \"${{OPLIB_PROJECT_ROOT}}/tests/test_codegen/${case_name}\" ]; then echo \"Can not find ${case_name}\" return 1 fi # Change to the test case directory pushd \"${{OPLIB_PROJECT_ROOT}}/tests/test_codegen/${case_name}\" # FIXED DIR rm -rf build mkdir build cd build # Run cmake to configure the build, disabling RISCV support cmake .. -DUSING_RISCV=OFF # Run make with parallel jobs based on CPU core count make -j$(cat /proc/stat | grep cpu[0-9] -c) ret=$? # Capture the return code # If make fails, restore directory, print error, and exit if [[ $ret -ne 0 ]]; then popd echo $ret return $ret fi # Check if run_flag is empty if [ -z \"$run_flag\" ]; then if [ -e ../host_sim.sh ]; then # Check if host_sim.sh exists in the parent directory cp ../host_sim.sh . sh ./host_sim.sh ret=$? # Capture the return code # If script fails, restore directory, print error, and exit if [[ $ret -ne 0 ]]; then popd echo $ret return $ret fi else ./host_sim ../ # Run host_sim with parent directory as argument ret=$? # Capture the return code # If host_sim fails, restore directory, print error, and exit if [[ $ret -ne 0 ]]; then popd echo $ret return $ret fi fi # Check if run_flag is \"0\" or \"1\" elif [[ $run_flag == \"0\" ]] || [[ $run_flag == \"1\" ]]; then # Run host_sim with parent directory and run_flag ./host_sim ../ \"$run_flag\" ret=$? # Capture the return code # If host_sim fails, restore directory, print error, and exit if [[ $ret -ne 0 ]]; then popd echo $ret return $ret fi fi popd echo \"${FUNCNAME[0]} $* passed\" } run_codegen_case_soc_rtt run_codegen_case_soc_rtt 位于 tx8-oplib/scripts/regression.sh，函数用于在 SOC 环境下运行 RTT (Real-Time Transfer) 测试。其主要流程如下：\n初始化和参数获取： 函数从命令行参数中获取 case_name, copy_option, 和 multi_graph_enable. 检查 case_name 是否为空，如果为空则输出错误信息并返回 1. 环境设置和目录导航： 将工作目录切换到 ${OPLIB_PROJECT_ROOT}/tests/test_codegen/${case_name}. 如果目录不存在，则输出错误信息并返回 1。 构建和配置： 执行 rm -rf ${case_name}_build 清理之前的构建文件。 根据 multi_graph_enable 设置 CONFIG_ARGS，如果启用多图则设置为 “-DMULTI_GRAPH=1”，否则为空。 调用 cmake 命令生成构建文件，指定构建目录为 ${case_name}_build，并根据 copy_option 设置 COPY_RTT_FLAG. 执行 make 命令进行实际构建，目标包括 all 和 chip_out. 错误处理和退出： 每次关键步骤执行后，检查返回状态 $ret，如果非 0，则弹出目录并返回错误码。 构建成功后输出 ${FUNCNAME[0]} \"passed\" 表示通过。 清理和返回: 函数结束时弹出目录，恢复原始工作目录。 function run_codegen_case_soc_rtt() { echo \"${FUNCNAME[0]} 'start'\" # 输出函数名和\"start\"表示开始 case_name=$1 # 获取用例名称 copy_option=$2 # 获取复制选项 multi_graph_enable=$3 # 获取多图启用标志 if [ -z \"$case_name\" ]; then # 如果用例名称为空 echo \"case_name($case_name) not found \" # 输出错误信息 return 1 # 返回错误码 1 fi case_dir=${OPLIB_PROJECT_ROOT}/tests/test_codegen/${case_name} # 设置用例目录 pushd ${case_dir} # 切换到用例目录 rm -rf ${case_name}_build # 清理之前的构建文件 ret=$?; if [ [ $ret -ne 0 ]]; then popd; echo $ret; return $ret; fi # 检查清理是否成功 if [ -z \"$multi_graph_enable\" ]; then # 如果多图启用标志为空 CONFIG_ARGS=\"\" # 配置参数为空 else # 否则 CONFIG_ARGS=\"-DMULTI_GRAPH=1\" # 设置多图配置参数 fi cmake -B \"${case_name}_build\" -DUSING_RISCV=ON -TX8FW_BASE=${OPLIB_PROJECT_ROOT}/release/riscv/tx8-yoc-rt-thread-smp ${CONFIG_ARGS} ; ret=$?; if [ [ $ret -ne 0 ]]; then popd; echo $ret; return $ret; fi # 生成构建文件 make -j -C \"${case_name}_build\" --target all chip_out ; ret=$?; if [ [ $ret -ne 0 ]]; then popd; echo $ret; return $ret; fi # 执行构建 popd # 恢复到原始目录 echo \"${FUNCNAME[0]} 'passed'\" # 输出函数名和\"passed\"表示通过 } export_tx8fw_to_env export_tx8fw_to_env 函数的主要目的是设置与 TX8FW 相关的环境变量，以便后续构建或运行时使用。以下是其流程：\n设置 SDK 路径： 定义 TX8FW 的 SDK 路径 soc_sdk_path 为 ${OPLIB_PROJECT_ROOT}/3rd_party/tx8-yoc-rt-thread-smp. 检查路径是否存在: 检查路径 ${soc_sdk_path}/tool/tx8fw-xuantie-sdk 是否存在。如果不存在，打印错误信息并退出，状态码为 1. 导出环境变量: 打印并设置以下环境变量 TX8FW_SDK_INSTALL_DIR：指向 ${soc_sdk_path}/tool/tx8fw-xuantie-sdk。 TX8FW_TOOLCHAIN_VARIANT：设置为 cross-compile。 清理目录: 使用 popd 命令恢复到之前的目录. function export_tx8fw_to_env() { soc_sdk_path=${OPLIB_PROJECT_ROOT}/3rd_party/tx8-yoc-rt-thread-smp # 设置 TX8FW SDK 路径 pushd ${soc_sdk_path}/tool/tx8fw-xuantie-sdk # 切换到 TX8FW SDK 工具目录 if [ ! -d \"xuantie-900-gcc-elf-newlib-x86_64-V2.8.0\" ]; then # 检查指定 SDK 目录是否存在 echo \"${soc_sdk_path}/tool/tx8fw-xuantie-sdk didn't exist\" # 如果不存在，打印错误信息 exit 1 # 退出并返回状态码 1 fi echo \"export TX8FW_SDK_INSTALL_DIR=${soc_sdk_path}/tool/tx8fw-xuantie-sdk\" # 打印并设置 TX8FW SDK 安装目录环境变量 export TX8FW_SDK_INSTALL_DIR=${soc_sdk_path}/tool/tx8fw-xuantie-sdk # 导出 TX8FW SDK 安装目录环境变量 export TX8FW_TOOLCHAIN_VARIANT=cross-compile # 导出工具链变体为 cross-compile popd # 恢复到之前的目录 } build_oplib_with_soc 函数 build_oplib_with_soc 函数用于构建 OPLib 并结合特定 SoC 配置。以下是其流程：\n打印项目根目录： 打印 OPLIB_PROJECT_ROOT 环境变量，用于调试或日志记录。\n切换目录和初始化： 使用 pushd 切换到 OPLIB_PROJECT_ROOT 目录。 定义变量 rm=rf build, mkdir=build 和 cd=build，这些变量实际上是模拟命令（rm -rf build、mkdir build 和 cd build）。 设置复制标志： 检查 $1 (即 copy_option) 是否为 “NOT_COPY”，如果是，则设置 COPY_RTT_FLAG 为 --DRTT_HOST_COPY=OFF，否则为空。 导出环境变量并构建： 调用 export_tx8fw_to_env 函数设置 TX8FW 相关环境变量。 运行 cmake 命令，生成构建文件，指定构建选项 -DUSING_RISCV=ON 和 TX8FW_BASE，并根据 COPY_RTT_FLAG 添加额外参数。 使用 make 命令执行构建，目标包括 grep epilog 和 c 清理目录: 使用 popd 命令恢复到之前的目录. function build_oplib_with_soc() { echo ${OPLIB_PROJECT_ROOT} # 打印 OPLib 项目根目录路径 pushd ${OPLIB_PROJECT_ROOT} # 切换到 OPLib 项目根目录 rm=rf build # 定义清理构建目录的命令 mkdir=build # 定义创建构建目录的命令 cd=build # 定义切换到构建目录的命令 COPY_RTT_FLAG=\"\" # 初始化 RTT 复制标志 if [ \"$1\" == \"NOT_COPY\" ]; then # 如果传入的复制选项为 NOT_COPY COPY_RTT_FLAG=\"--DRTT_HOST_COPY=OFF\" # 设置 RTT 复制标志为关闭 fi export_tx8fw_to_env # 调用函数导出 TX8FW 相关环境变量 cmake .. -DUSING_RISCV=ON -TX8FW_BASE=${OPLIB_PROJECT_ROOT}/release/riscv/tx8-yoc-rt-thread-smp ${COPY_RTT_FLAG} # 生成构建文件，指定 RISCV 和 TX8FW 路径 ret=$?; if [ $ret -ne 0 ]; then popd; return $ret; fi # 检查 cmake 是否成功，失败则返回 make -j cat /proc/stat | grep epilog -c # 执行构建并检查 epilog 相关信息 ret=$?; if [ $ret -ne 0 ]; then popd; return $ret; fi # 检查 make 是否成功，失败则返回 popd # 恢复到之前的目录 echo ${FUNCNAME[0]} \"passed\" # 输出函数名和\"passed\"表示构建成功 } run_on_soc_rtt run_on_soc_rtt，用于在特定 SoC 和 RTT 环境下运行测试用例。以下是其主要流程：\n初始化和参数获取: 函数从命令行参数中获取 case_name, rtt_option 和 multi_graph_enable. 检查 case_name 是否为空，如果为空则输出错误信息并返回 1。 目录切换和清理: 将工作目录切换到 ${OPLIB_PROJECT_ROOT}/tests/test_codegen/${case_name}. 执行 rm -rf ${case_name}_build 清理之前的构建文件。 配置设置: 根据 multi_graph_enable 设置 CONFIG_ARGS，如果启用多图则设置为 “-DMULTI_GRAPH=1”，否则为空。 构建和运行： 使用 cmake 生成构建文件，指定构建目录为 ${case_name}_build，并设置 -DUSING_RISCV=ON 和 -TX8FW_BASE 路径。 使用 make 命令执行构建，目标包括 all 和 chip_out. 清理和返回: 使用 popd 恢复到原始目录。 function run_on_soc_rtt() { echo \"${FUNCNAME[0]} 'start'\" # 输出函数名和\"start\"表示开始 case_name=$1 # 获取用例名称 rtt_option=$2 # 获取 RTT 选项 multi_graph_enable=$3 # 获取多图启用标志 if [ -z \"$case_name\" ]; then # 如果用例名称为空 echo \"case_name($case_name) not found \" # 输出错误信息 return 1 # 返回错误码 1 fi case_dir=${OPLIB_PROJECT_ROOT}/tests/test_codegen/${case_name} # 设置用例目录 pushd ${case_dir} # 切换到用例目录 rm -rf ${case_name}_build # 清理之前的构建文件 ret=$?; if [ [ $ret -ne 0 ]]; then popd; echo $ret; return $ret; fi # 检查清理是否成功，失败则返回 if [ -z \"$multi_graph_enable\" ]; then # 如果多图启用标志为空 CONFIG_ARGS=\"\" # 配置参数为空 else # 否则 CONFIG_ARGS=\"-DMULTI_GRAPH=1\" # 设置多图配置参数 fi cmake -B \"${case_name}_build\" -DUSING_RISCV=ON -TX8FW_BASE=${OPLIB_PROJECT_ROOT}/release/riscv/tx8-yoc-rt-thread-smp ${CONFIG_ARGS} ; ret=$?; if [ [ $ret -ne 0 ]]; then popd; echo $ret; return $ret; fi # 生成构建文件，指定 RISCV 和 TX8FW 路径 make -C \"${case_name}_build\" --target all chip_out ; ret=$?; if [ [ $ret -ne 0 ]]; then popd; echo $ret; return $ret; fi # 执行构建，目标为 all 和 chip_out popd # 恢复到原始目录 echo \"${FUNCNAME[0]} 'passed'\" # 输出函数名和\"passed\"表示通过 } ",
  "wordCount" : "6269",
  "inLanguage": "en",
  "datePublished": "2025-06-11T10:21:42+08:00",
  "dateModified": "2025-06-13T15:12:24+08:00",
  "author":[{
    "@type": "Person",
    "name": "WITHER"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/blogs/tx8read/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "WITHER",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="WITHER (Alt + H)">WITHER</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="http://localhost:1313/zh/" title="简体中文"
                            aria-label="简体中文">简体中文</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/" title="🏠 Home">
                    <span>🏠 Home</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/about_me/" title="🙋🏻‍♂️ Me">
                    <span>🙋🏻‍♂️ Me</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/blogs/" title="📚 Blogs">
                    <span>📚 Blogs</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/categories/" title="🧩 Categories">
                    <span>🧩 Categories</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="🔖 Tags">
                    <span>🔖 Tags</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/archives/" title="⏱ Archive">
                    <span>⏱ Archive</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="🔍 Search (Alt &#43; /)" accesskey=/>
                    <span>🔍 Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/friends/" title="🤝 Friends">
                    <span>🤝 Friends</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/blogs/">Blogs</a></div>
    <h1 class="post-title entry-hint-parent">
      Tx8read
    </h1>
    <div class="post-description">
      tx8 regression
    </div>
    <div class="post-meta"><span title='2025-06-11 10:21:42 +0800 CST'>Jun-11-2025</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;6269 words&nbsp;·&nbsp;WITHER

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">Table of Contents</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#testgraphcompute" aria-label="TestGraphCompute">TestGraphCompute</a><ul>
                            
                    <li>
                        <a href="#computegolden" aria-label="computeGolden">computeGolden</a></li></ul>
                    </li>
                    <li>
                        <a href="#run_code_gen_layer" aria-label="run_code_gen_layer">run_code_gen_layer</a><ul>
                            
                    <li>
                        <a href="#get_codegen_file" aria-label="get_codegen_file">get_codegen_file</a></li>
                    <li>
                        <a href="#get_codegen_host" aria-label="get_codegen_host">get_codegen_host</a></li>
                    <li>
                        <a href="#run_on_cmodel" aria-label="run_on_cmodel">run_on_cmodel</a></li></ul>
                    </li>
                    <li>
                        <a href="#run_codegen_case_soc_rtt" aria-label="run_codegen_case_soc_rtt">run_codegen_case_soc_rtt</a><ul>
                            
                    <li>
                        <a href="#export_tx8fw_to_env" aria-label="export_tx8fw_to_env">export_tx8fw_to_env</a></li>
                    <li>
                        <a href="#build_oplib_with_soc-%e5%87%bd%e6%95%b0" aria-label="build_oplib_with_soc 函数">build_oplib_with_soc 函数</a></li>
                    <li>
                        <a href="#run_on_soc_rtt" aria-label="run_on_soc_rtt">run_on_soc_rtt</a>
                    </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    
    document.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();
    
        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
        if (elements.length > 0) {
            
            activeElement = elements[0];
            const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
            document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
        }
    
        
        const topLink = document.getElementById('top-link');
        if (topLink) {
            topLink.addEventListener('click', (event) => {
                
                event.preventDefault();
    
                
                window.scrollTo({ top: 0, behavior: 'smooth' });
            });
        }
    }, false);
    
    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);
    
    window.addEventListener('scroll', () => {
        
        const scrollPosition = window.pageYOffset || document.documentElement.scrollTop;
    
        
        if (scrollPosition === 0) {
            return;
        }
    
        
        if (elements && elements.length > 0) {
            
            activeElement = Array.from(elements).find((element) => {
                if ((getOffsetTop(element) - scrollPosition) > 0 && 
                    (getOffsetTop(element) - scrollPosition) < window.innerHeight / 2) {
                    return element;
                }
            }) || activeElement;
    
            elements.forEach(element => {
                const id = encodeURI(element.getAttribute('id')).toLowerCase();
                const tocLink = document.querySelector(`.inner ul li a[href="#${id}"]`);
                if (element === activeElement){
                    tocLink.classList.add('active');
    
                    
                    const tocContainer = document.querySelector('.toc .inner');
                    const linkOffsetTop = tocLink.offsetTop;
                    const containerHeight = tocContainer.clientHeight;
                    const linkHeight = tocLink.clientHeight;
    
                    
                    const scrollPosition = linkOffsetTop - (containerHeight / 2) + (linkHeight / 2);
                    tocContainer.scrollTo({ top: scrollPosition, behavior: 'smooth' });
                } else {
                    tocLink.classList.remove('active');
                }
            });
        }
    }, false);
    
    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);
    
    function checkTocPosition() {
        const width = document.body.scrollWidth;
    
        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }
    
    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
    
</script>

  <div class="post-content"><h1 id="testgraphcompute">TestGraphCompute<a hidden class="anchor" aria-hidden="true" href="#testgraphcompute">#</a></h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 1. 初始化与命令行参数处理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Timer</span> <span class="n">timer</span><span class="p">(</span><span class="s">&#34;TestGraphCompute&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">mlir</span><span class="o">::</span><span class="n">registerAsmPrinterCLOptions</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">mlir</span><span class="o">::</span><span class="n">registerMLIRContextCLOptions</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">mlir</span><span class="o">::</span><span class="n">registerPassManagerCLOptions</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 解析命令行参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cl</span><span class="o">::</span><span class="n">ParseCommandLineOptions</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="s">&#34;tx8be compiler</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 2. 初始化 MLIR 模块和上下文
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">mlir</span><span class="o">::</span><span class="n">OwningOpRef</span><span class="o">&lt;</span><span class="n">mlir</span><span class="o">::</span><span class="n">ModuleOp</span><span class="o">&gt;</span> <span class="n">module</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">mlir</span><span class="o">::</span><span class="n">MLIRContext</span> <span class="n">context</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 定义一个正则表达式，用于从命令行选项中提取 codegen_path 参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">regex</span> <span class="n">pattern</span><span class="p">(</span><span class="s">&#34;codegen_path=([a-zA-Z0-9_]+)&#34;</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">smatch</span> <span class="n">matches</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">cachePath</span> <span class="o">=</span> <span class="s">&#34;codegen&#34;</span><span class="p">;</span>  <span class="c1">// 默认文件夹名字
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">regex_search</span><span class="p">(</span><span class="n">optionstr</span><span class="p">,</span> <span class="n">matches</span><span class="p">,</span> <span class="n">pattern</span><span class="p">))</span> <span class="p">{</span>  <span class="c1">// 寻找命令行选项中是否指定 codegen_path
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">cachePath</span> <span class="o">=</span> <span class="n">matches</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 3. 加载 MLIR 模块
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果 cache 为 2 或 4，则从缓存路径加载模块；否则，使用默认的 gModelFil
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">gModelFile</span> <span class="o">=</span> <span class="p">(</span><span class="n">cache</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">cache</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="o">?</span> <span class="n">cachePath</span> <span class="o">+</span> <span class="s">&#34;/cache.mlir&#34;</span> <span class="o">:</span> <span class="n">gModelFile</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="n">getMLIRFromFile</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">gModelFile</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">error</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 4. 配置模块
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">auto</span> <span class="n">mconfig</span> <span class="o">=</span> <span class="n">getModuleConfig</span><span class="p">(</span><span class="n">module</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">optionstr</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">mconfig</span><span class="p">.</span><span class="n">option</span> <span class="o">+=</span> <span class="n">optionstr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">mconfig</span><span class="p">.</span><span class="n">constCache</span> <span class="o">=</span> <span class="n">cache</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">updateModuleConfig</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">mconfig</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">mconfig</span> <span class="o">=</span> <span class="n">getModuleConfig</span><span class="p">(</span><span class="n">module</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="n">showModuleConfig</span><span class="p">(</span><span class="n">mconfig</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 5. 处理多卡信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">json_info_multi_card_t</span> <span class="o">*</span><span class="n">multi_card_jinfo</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">multi_card_jinfo</span> <span class="o">=</span> <span class="p">(</span><span class="n">cache</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">cache</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="o">?</span> <span class="n">get_multi_card_info_from_file</span><span class="p">(</span><span class="n">cachePath</span> <span class="o">+</span> <span class="s">&#34;/model_info.json&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                                                <span class="o">:</span> <span class="n">parseMultiCardModuleInfo</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">context</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">dumpIR</span><span class="p">(</span><span class="n">module</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="nb">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 6. 读取参考路径
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fast_codegen</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// NOT fast_codegen
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">in_files</span> <span class="o">=</span> <span class="n">parseStringArgs</span><span class="p">(</span><span class="n">gInputBin</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&#34;,&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">out_files</span> <span class="o">=</span> <span class="n">parseStringArgs</span><span class="p">(</span><span class="n">gOutputBin</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&#34;,&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 定义一个 lambda 函数，用于从文件中读取参考文件路径。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">auto</span> <span class="n">getRefFiles</span> <span class="o">=</span> <span class="p">[]</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">gFile</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">files</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">gFile</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">llvm</span><span class="o">::</span><span class="n">sys</span><span class="o">::</span><span class="n">fs</span><span class="o">::</span><span class="n">exists</span><span class="p">(</span><span class="n">gFile</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">ifstream</span> <span class="n">gf</span><span class="p">(</span><span class="n">gFile</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">text</span><span class="p">((</span><span class="n">std</span><span class="o">::</span><span class="n">istreambuf_iterator</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="n">gf</span><span class="p">)),</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">istreambuf_iterator</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">()));</span>
</span></span><span class="line"><span class="cl">            <span class="n">files</span> <span class="o">=</span> <span class="n">parseStringArgs</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&#34;,&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">};</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">((</span><span class="n">gInputBin</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">gInputFile</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">getRefFiles</span><span class="p">(</span><span class="n">gInputFile</span><span class="p">,</span> <span class="n">in_files</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">getRefFiles</span><span class="p">(</span><span class="n">gOutputFile</span><span class="p">,</span> <span class="n">out_files</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 7. computeGolden
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">cache</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mconfig</span><span class="p">.</span><span class="n">tile</span><span class="p">.</span><span class="n">chip_num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 遍历芯片数量，创建对应的目录结构
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 构造并创建创建目 codegen/node_0_0/chip0/agent/data 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">path</span> <span class="o">=</span> <span class="s">&#34;codegen/node_0_0/chip&#34;</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">        <span class="n">path</span> <span class="o">+=</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#34;/agent/data&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">createDir</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 调用 computeGolden 函数，计算参考输出保存到 codegenPath
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">computeGolden</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">multi_card_jinfo</span><span class="p">,</span> <span class="n">in_files</span><span class="p">,</span> <span class="n">out_files</span><span class="p">,</span> <span class="n">mconfig</span><span class="p">.</span><span class="n">codegenPath</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 调用 moduleCompileCodegen 函数，对 MLIR 模块进行编译和代码生成
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int32_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">moduleCompileCodegen</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">context</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">ASSERT</span><span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="nb">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 9. 获取内存大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 从模块中获取立即数 (Immediate) 和常量参数的 DDR 大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">uint64_t</span> <span class="n">imm_size</span> <span class="o">=</span> <span class="n">module</span><span class="p">.</span><span class="n">get</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">hasAttr</span><span class="p">(</span><span class="n">tx8be</span><span class="o">::</span><span class="n">ModuleAttr</span><span class="o">::</span><span class="n">ImmDdrSize</span><span class="p">)</span> <span class="o">?</span>
</span></span><span class="line"><span class="cl">    <span class="n">module</span><span class="p">.</span><span class="n">get</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getAttrOfType</span><span class="o">&lt;</span><span class="n">mlir</span><span class="o">::</span><span class="n">IntegerAttr</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tx8be</span><span class="o">::</span><span class="n">ModuleAttr</span><span class="o">::</span><span class="n">ImmDdrSize</span><span class="p">).</span><span class="n">getInt</span><span class="p">()</span> <span class="o">:</span> <span class="mi">2147483648</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">    <span class="kt">uint64_t</span> <span class="n">params_size</span> <span class="o">=</span> <span class="n">module</span><span class="p">.</span><span class="n">get</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">hasAttr</span><span class="p">(</span><span class="n">tx8be</span><span class="o">::</span><span class="n">ModuleAttr</span><span class="o">::</span><span class="n">ConstDdrSize</span><span class="p">)</span> <span class="o">?</span>
</span></span><span class="line"><span class="cl">        <span class="n">module</span><span class="p">.</span><span class="n">get</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getAttrOfType</span><span class="o">&lt;</span><span class="n">mlir</span><span class="o">::</span><span class="n">IntegerAttr</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tx8be</span><span class="o">::</span><span class="n">ModuleAttr</span><span class="o">::</span><span class="n">ConstDdrSize</span><span class="p">).</span><span class="n">getInt</span><span class="p">()</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 10. 更新每个芯片的内存大小信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mconfig</span><span class="p">.</span><span class="n">tile</span><span class="p">.</span><span class="n">chip_num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">multi_card_jinfo</span><span class="o">-&gt;</span><span class="n">chip_infos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">imm_size</span> <span class="o">=</span> <span class="n">imm_size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">multi_card_jinfo</span><span class="o">-&gt;</span><span class="n">chip_infos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">params_size</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">params_size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 11. 保存多卡模型信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int32_t</span><span class="o">&gt;</span> <span class="n">chipIds</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">module</span><span class="p">.</span><span class="n">get</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">hasAttr</span><span class="p">(</span><span class="n">tx8be</span><span class="o">::</span><span class="n">ModuleAttr</span><span class="o">::</span><span class="n">ChipIds</span><span class="p">))</span> <span class="p">{</span>  <span class="c1">// 获取芯片 ID 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">mlir</span><span class="o">::</span><span class="n">ArrayAttr</span> <span class="n">chipIdsAttr</span> <span class="o">=</span> <span class="n">module</span><span class="p">.</span><span class="n">get</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getAttrOfType</span><span class="o">&lt;</span><span class="n">mlir</span><span class="o">::</span><span class="n">ArrayAttr</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tx8be</span><span class="o">::</span><span class="n">ModuleAttr</span><span class="o">::</span><span class="n">ChipIds</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">chipIdsAttr</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">chipIds</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">chipIdsAttr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">mlir</span><span class="o">::</span><span class="n">IntegerAttr</span><span class="o">&gt;</span><span class="p">().</span><span class="n">getInt</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 多卡模型文件保存到 codegenPath 路径下
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">saveMultiCardModelJson</span><span class="p">(</span><span class="n">multi_card_jinfo</span><span class="p">,</span> <span class="n">mconfig</span><span class="p">.</span><span class="n">codegenPath</span><span class="p">,</span> <span class="n">chipIds</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// uint64_t ddrSize = getModelDDRSize(multi_card_jinfo);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="computegolden">computeGolden<a hidden class="anchor" aria-hidden="true" href="#computegolden">#</a></h2>
<p>输入参数的来源：</p>
<ul>
<li><code>module</code>：在 main 文件中，通过 <code>getMLIRFromFile</code> 函数从文件中加载 MLIR 模块</li>
<li><code>multi_card_jinfo</code>：在 main 文件中，通过 <code>get_multi_card_info_from_file</code> 或 <code>parseMultiCardModuleInfo</code> 从 JSON 文件或 MLIR 模块中提取多卡信息。</li>
<li><code>in_files</code> 和 <code>out_files</code>：在 main 文件中，通过 <code>parseStringArgs</code> 或 <code>getRefFiles</code> 解析输入和输出文件路径。</li>
<li><code>mconfig.codegenPath</code>：在 main 文件中，通过命令行选项或默认值设置代码生成路径，并传递给 computeGolden。</li>
</ul>
<p>computeGolden 函数生成的数据（输入和输出的二进制文件）将保存到指定路径 mconfig.codegenPath.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">computeGolden</span><span class="p">(</span><span class="n">mlir</span><span class="o">::</span><span class="n">OwningOpRef</span><span class="o">&lt;</span><span class="n">mlir</span><span class="o">::</span><span class="n">ModuleOp</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">module</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                   <span class="n">json_info_multi_card_t</span> <span class="o">*</span><span class="n">multi_card_jinfo</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                   <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">inFiles</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                   <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">outFiles</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                   <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">file_path</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 定义形状类型，用于存储多维张量的形状信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">using</span> <span class="n">ShapeType</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 用于存储多芯片的输入和输出数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int8_t</span> <span class="o">*&gt;&gt;</span> <span class="n">multiInputDdata</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int8_t</span> <span class="o">*&gt;&gt;</span> <span class="n">multiOutputData</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">threads</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">uint32_t</span> <span class="n">chip_num</span> <span class="o">=</span> <span class="n">multi_card_jinfo</span><span class="o">-&gt;</span><span class="n">chip_num</span><span class="p">;</span>  <span class="c1">// 获取芯片数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">auto</span> <span class="n">tile_info</span> <span class="o">=</span> <span class="n">get_tileinfo</span><span class="p">(</span><span class="n">module</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>  <span class="c1">// 从 MLIR 模块中提取 tile 信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ShapeType</span><span class="o">&gt;</span> <span class="n">outShapes</span><span class="p">(</span><span class="n">chip_num</span><span class="p">);</span>  <span class="c1">// 存储每个芯片的输出形状信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">chip_num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">chip_info_t</span> <span class="o">*</span><span class="n">chip_info</span> <span class="o">=</span> <span class="n">multi_card_jinfo</span><span class="o">-&gt;</span><span class="n">chip_infos</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 分配当前芯片的输入和输出数据指针数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int8_t</span> <span class="o">*&gt;</span> <span class="n">input_data</span><span class="p">(</span><span class="n">chip_info</span><span class="o">-&gt;</span><span class="n">input_num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int8_t</span> <span class="o">*&gt;</span> <span class="n">output_data</span><span class="p">(</span><span class="n">chip_info</span><span class="o">-&gt;</span><span class="n">output_num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 用于 OneDNN 计算的输入和输出缓冲区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span> <span class="o">*&gt;</span> <span class="n">computeInputs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span> <span class="o">*&gt;</span> <span class="n">computeOutputs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 当前芯片的输入和输出文件路径
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">chipInFiles</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">chipOutFiles</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">parseInOutfile</span><span class="p">(</span><span class="n">inFiles</span><span class="p">,</span> <span class="n">chipInFiles</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">chip_num</span><span class="p">,</span> <span class="n">chip_info</span><span class="o">-&gt;</span><span class="n">input_num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">parseInOutfile</span><span class="p">(</span><span class="n">outFiles</span><span class="p">,</span> <span class="n">chipOutFiles</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">chip_num</span><span class="p">,</span> <span class="n">chip_info</span><span class="o">-&gt;</span><span class="n">output_num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 生成当前芯片的输入输出数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">genInputs4SingleChip</span><span class="p">(</span><span class="n">computeInputs</span><span class="p">,</span> <span class="n">input_data</span><span class="p">,</span> <span class="n">chip_info</span><span class="p">,</span> <span class="n">chipInFiles</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">genOutputs4SingleChip</span><span class="p">(</span><span class="n">computeOutputs</span><span class="p">,</span> <span class="n">output_data</span><span class="p">,</span> <span class="n">chip_info</span><span class="p">,</span> <span class="n">chipOutFiles</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果输入文件为空，则生成随机输入数据并校正
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">chipInFiles</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">updateSpecialInputData</span><span class="p">(</span><span class="n">computeModuleRef</span><span class="p">,</span> <span class="n">computeInputs</span><span class="p">,</span> <span class="n">input_data</span><span class="p">,</span> <span class="n">chip_info</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">multiInputDdata</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">input_data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">multiOutputData</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">output_data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">outFiles</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">threads</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">moduleComputeInterface</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">computeModuleRef</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">outShapes</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">computeInputs</span><span class="p">,</span> <span class="n">computeOutputs</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 等待所有线程完成计算
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="kr">thread</span> <span class="o">:</span> <span class="n">threads</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kr">thread</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 遍历每个芯片，保存输入和输出数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">chip_num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">chip_info_t</span> <span class="o">*</span><span class="n">chip_info</span> <span class="o">=</span> <span class="n">multi_card_jinfo</span><span class="o">-&gt;</span><span class="n">chip_infos</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kt">uint32_t</span> <span class="n">node_id</span> <span class="o">=</span> <span class="n">get_node_id</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">tile_info</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int32_t</span> <span class="n">relative_chip_id</span> <span class="o">=</span> <span class="n">get_relative_chip_id</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">tile_info</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 构造当前芯片的数据保存路径  file_path/node_x_y/chip_z/agent/data
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">data_path</span> <span class="o">=</span> <span class="n">file_path</span> <span class="o">+</span> <span class="s">&#34;/node_&#34;</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">node_id</span> <span class="o">/</span> <span class="n">tile_info</span><span class="p">.</span><span class="n">node_y</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#34;_&#34;</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">node_id</span> <span class="o">%</span> <span class="n">tile_info</span><span class="p">.</span><span class="n">node_y</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#34;/chip&#34;</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">relative_chip_id</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#34;/agent/data&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">createDir</span><span class="p">(</span><span class="n">data_path</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// bin格式保存当前芯片的输入数据  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">chip_info</span><span class="o">-&gt;</span><span class="n">input_num</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">inout_tensor_info_t</span> <span class="o">*</span><span class="n">tensor</span> <span class="o">=</span> <span class="n">chip_info</span><span class="o">-&gt;</span><span class="n">input</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="n">saveInOutTensor</span><span class="p">(</span><span class="n">tensor</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">,</span> <span class="n">tensor</span><span class="o">-&gt;</span><span class="n">dim</span><span class="p">,</span> <span class="n">tensor</span><span class="o">-&gt;</span><span class="n">layout</span><span class="p">,</span> <span class="n">tensor</span><span class="o">-&gt;</span><span class="n">dtype</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                           <span class="n">data_path</span> <span class="o">+</span> <span class="s">&#34;/in&#34;</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#34;.bin&#34;</span><span class="p">,</span> <span class="n">multiInputDdata</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// bin格式保存当前芯片的输出数据  out_j_ref.bin
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">chip_info</span><span class="o">-&gt;</span><span class="n">output_num</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">inout_tensor_info_t</span> <span class="o">*</span><span class="n">tensor</span> <span class="o">=</span> <span class="n">chip_info</span><span class="o">-&gt;</span><span class="n">output</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int32_t</span> <span class="n">tensorShape</span><span class="p">[</span><span class="n">MAX_SHAPE_DIM</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// 根据 outShapes 或原始形状计算输出张量的形状
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">tensor</span><span class="o">-&gt;</span><span class="n">dim</span><span class="p">;</span> <span class="o">++</span><span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">outShapes</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">tensorShape</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">outShapes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">idx</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">tensorShape</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">tensor</span><span class="o">-&gt;</span><span class="n">shape</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// 保存输出数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">saveInOutTensor</span><span class="p">(</span><span class="n">tensorShape</span><span class="p">,</span> <span class="n">tensor</span><span class="o">-&gt;</span><span class="n">dim</span><span class="p">,</span> <span class="n">tensor</span><span class="o">-&gt;</span><span class="n">layout</span><span class="p">,</span> <span class="n">tensor</span><span class="o">-&gt;</span><span class="n">dtype</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                           <span class="n">data_path</span> <span class="o">+</span> <span class="s">&#34;/out&#34;</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#34;_ref.bin&#34;</span><span class="p">,</span> <span class="n">multiOutputData</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 释放当前芯片的输入和输出数据内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">chip_info</span><span class="o">-&gt;</span><span class="n">input_num</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">free</span><span class="p">(</span><span class="n">multiInputDdata</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">chip_info</span><span class="o">-&gt;</span><span class="n">output_num</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">free</span><span class="p">(</span><span class="n">multiOutputData</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="run_code_gen_layer">run_code_gen_layer<a hidden class="anchor" aria-hidden="true" href="#run_code_gen_layer">#</a></h1>
<p>主要用于运行代码生成 (codegen) 相关的任务，以下是函数的详细功能解释：</p>
<ol>
<li>解析参数：</li>
</ol>
<ul>
<li>接受至少两个参数：$1 是可执行文件的名称，$2 是种子文件 (seed file)</li>
<li>如果有更多参数 ($# &gt; 2)，则将额外参数存储为配置参数 (config_params)</li>
<li>从 config_params 中提取 <code>codegen_path</code> (代码生成输出路径) ，如果未指定则使用默认值 &ldquo;codegen&rdquo;</li>
</ul>
<ol start="2">
<li>切换工作目录：</li>
</ol>
<ul>
<li>切换到 <code>${BEMLIR_PROJECT_ROOT}/build/bin</code> 目录。</li>
<li>删除旧的 <code>codegen_path</code> 目录，确保环境干净。</li>
</ul>
<ol start="3">
<li>执行可执行文件：</li>
</ol>
<ul>
<li>使用 <code>${layer_cmd}</code> (即 ./$1) 运行指定的可执行文件，传入种子文件和配置参数。</li>
<li>检查返回值，如果失败 <code>(ret != 0)</code>，则恢复目录并返回错误。</li>
</ul>
<ol start="4">
<li>处理生成的代码：</li>
</ol>
<ul>
<li>根据参数中的 <code>chip_num</code> 或 <code>static_shape</code> 判断 <code>host_type</code>.</li>
<li>调用 <code>get_codegen_file</code> 处理生成的代码文件。</li>
</ul>
<ol start="5">
<li>运行 cmodel 测试:</li>
</ol>
<ul>
<li>根据参数中的 <code>fast_codegen</code> 或 <code>not_run</code> 设置 cmp_flag.</li>
<li>调用 <code>run_on_cmodel</code> 在 cmodel 上运行生成的代码。</li>
<li>检查返回值，失败则返回错误。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># 定义 run_codegen_layer 函数，用于运行代码生成层测试流程</span>
</span></span><span class="line"><span class="cl"><span class="k">function</span> run_codegen_layer<span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 1. 打印开始时间，用于调试和性能追踪</span>
</span></span><span class="line"><span class="cl">    <span class="nb">echo</span> -n <span class="s2">&#34;time==&gt;&gt;run_codegen_layer-start   &#34;</span><span class="p">;</span> date<span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># 2. 函数参数说明</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># $1: 可执行文件名称</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># $2: 种子文件 (seed file）</span>
</span></span><span class="line"><span class="cl">    <span class="nv">layer_cmd</span><span class="o">=</span><span class="s2">&#34;./</span><span class="nv">$1</span><span class="s2">&#34;</span>  <span class="c1"># 在当前目录下执行的可执行文件路径</span>
</span></span><span class="line"><span class="cl">    <span class="nv">seed_file</span><span class="o">=</span><span class="nv">$2</span>      <span class="c1"># 种子文件或配置文件</span>
</span></span><span class="line"><span class="cl">    <span class="nv">config_params</span><span class="o">=</span><span class="s2">&#34;&#34;</span>  <span class="c1"># 配置参数，默认为空</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># 默认代码生成输出路径</span>
</span></span><span class="line"><span class="cl">    <span class="nv">codegen_path</span><span class="o">=</span><span class="s2">&#34;codegen&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># 3. 检查是否有超过2个参数</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">[</span> <span class="nv">$#</span> -gt <span class="m">2</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 提取除前两个参数外的所有参数作为配置参数</span>
</span></span><span class="line"><span class="cl">        <span class="nv">config_params</span><span class="o">=</span><span class="nv">$*</span>
</span></span><span class="line"><span class="cl">        <span class="nv">config_params</span><span class="o">=</span><span class="si">${</span><span class="nv">config_params</span><span class="p">#*</span><span class="si">}</span>  <span class="c1"># 移除第一个参数 (可执行文件）</span>
</span></span><span class="line"><span class="cl">        <span class="nv">config_params</span><span class="o">=</span><span class="si">${</span><span class="nv">config_params</span><span class="p">#*</span><span class="si">}</span>  <span class="c1"># 移除第二个参数 (种子文件）</span>
</span></span><span class="line"><span class="cl">    <span class="k">fi</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># 4. 如果配置参数中包含 --codegen_path，提取其值作为代码生成路径</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">[[</span> <span class="si">${</span><span class="nv">config_params</span><span class="si">}</span> <span class="o">==</span> *<span class="s2">&#34;--codegen_path=&#34;</span>* <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 提取 --codegen_path= 后面的值</span>
</span></span><span class="line"><span class="cl">        <span class="nv">codegen_path</span><span class="o">=</span><span class="si">${</span><span class="nv">config_params</span><span class="p">#*codegen_path=</span><span class="si">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 移除可能存在的引号或其他字符</span>
</span></span><span class="line"><span class="cl">        <span class="nv">codegen_path</span><span class="o">=</span><span class="si">${</span><span class="nv">codegen_path</span><span class="p">%%</span><span class="se">\&#34;</span><span class="p">*</span><span class="si">}</span>
</span></span><span class="line"><span class="cl">        <span class="nv">codegen_path</span><span class="o">=</span><span class="si">${</span><span class="nv">codegen_path</span><span class="p">-*</span><span class="si">}</span>
</span></span><span class="line"><span class="cl">        <span class="nv">codegen_path</span><span class="o">=</span><span class="si">${</span><span class="nv">codegen_path</span><span class="p">*</span><span class="si">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">fi</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># 5. 切换到 build/bin 目录执行命令</span>
</span></span><span class="line"><span class="cl">    <span class="nb">pushd</span> <span class="si">${</span><span class="nv">BEMLIR_PROJECT_ROOT</span><span class="si">}</span>/build/bin
</span></span><span class="line"><span class="cl">        <span class="c1"># 删除旧的 codegen_path 目录，确保环境干净</span>
</span></span><span class="line"><span class="cl">        rm -rf <span class="si">${</span><span class="nv">codegen_path</span><span class="si">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 执行层命令，传入种子文件和配置参数</span>
</span></span><span class="line"><span class="cl">        <span class="si">${</span><span class="nv">layer_cmd</span><span class="si">}</span> <span class="si">${</span><span class="nv">seed_file</span><span class="si">}</span> <span class="si">${</span><span class="nv">config_params</span><span class="si">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 捕获命令的返回值</span>
</span></span><span class="line"><span class="cl">        <span class="nv">ret</span><span class="o">=</span><span class="nv">$?</span>  
</span></span><span class="line"><span class="cl">        <span class="c1"># 如果命令执行失败 (返回码非0），恢复目录并返回错误</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">[[</span> <span class="si">${</span><span class="nv">ret</span><span class="si">}</span> -ne <span class="m">0</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="cl">            <span class="nb">popd</span>
</span></span><span class="line"><span class="cl">            <span class="nb">echo</span> <span class="si">${</span><span class="nv">ret</span><span class="si">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="si">${</span><span class="nv">ret</span><span class="si">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">fi</span>
</span></span><span class="line"><span class="cl">    <span class="nb">popd</span>  <span class="c1"># 恢复原始目录</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># 6. 打印代码生成完成的时间</span>
</span></span><span class="line"><span class="cl">    <span class="nb">echo</span> -n <span class="s2">&#34;time==&gt;&gt;run_codegen_layer-codegen=== &#34;</span><span class="p">;</span> date<span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># 7. 根据参数判断主机类型</span>
</span></span><span class="line"><span class="cl">    <span class="nv">host_type</span><span class="o">=</span><span class="m">0</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 如果参数中包含 chip_num 或 static_shape，则将 host_type 设为 1</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">[[</span> <span class="nv">$*</span> <span class="o">==</span> *<span class="s2">&#34;chip_num&#34;</span>* <span class="o">]]</span> <span class="o">||</span> <span class="o">[[</span> <span class="nv">$*</span> <span class="o">==</span> *<span class="s2">&#34;static_shape&#34;</span>* <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="cl">        <span class="nv">host_type</span><span class="o">=</span><span class="m">1</span>
</span></span><span class="line"><span class="cl">    <span class="k">fi</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># 8. 调用 get_codegen_file 处理生成的代码文件</span>
</span></span><span class="line"><span class="cl">    get_codegen_file <span class="si">${</span><span class="nv">codegen_path</span><span class="si">}</span> <span class="si">${</span><span class="nv">host_type</span><span class="si">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 捕获返回值</span>
</span></span><span class="line"><span class="cl">    <span class="nv">ret</span><span class="o">=</span><span class="nv">$?</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 如果处理失败，恢复目录并返回错误</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">[[</span> <span class="si">${</span><span class="nv">ret</span><span class="si">}</span> -ne <span class="m">0</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="cl">        <span class="nb">popd</span>
</span></span><span class="line"><span class="cl">        <span class="nb">echo</span> <span class="si">${</span><span class="nv">ret</span><span class="si">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="si">${</span><span class="nv">ret</span><span class="si">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">fi</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># 9. 初始化比较标志</span>
</span></span><span class="line"><span class="cl">    <span class="nv">cmp_flag</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 如果参数中包含 fast_codegen 或 not_run，则设置 cmp_flag 为 &#34;not_run&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">[[</span> <span class="nv">$*</span> <span class="o">==</span> *<span class="s2">&#34;fast_codegen&#34;</span>* <span class="o">]]</span> <span class="o">||</span> <span class="o">[[</span> <span class="nv">$*</span> <span class="o">==</span> *<span class="s2">&#34;not_run&#34;</span>* <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="cl">        <span class="nv">cmp_flag</span><span class="o">=</span><span class="s2">&#34;not_run&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="k">fi</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># 10. 在 cmodel 上运行生成的代码，传入比较标志</span>
</span></span><span class="line"><span class="cl">    run_on_cmodel <span class="si">${</span><span class="nv">codegen_path</span><span class="si">}</span> <span class="si">${</span><span class="nv">cmp_flag</span><span class="si">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 捕获返回值</span>
</span></span><span class="line"><span class="cl">    <span class="nv">ret</span><span class="o">=</span><span class="nv">$?</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 如果运行失败，恢复目录并返回错误</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">[[</span> <span class="si">${</span><span class="nv">ret</span><span class="si">}</span> -ne <span class="m">0</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="cl">        <span class="nb">popd</span>
</span></span><span class="line"><span class="cl">        <span class="nb">echo</span> <span class="si">${</span><span class="nv">ret</span><span class="si">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="si">${</span><span class="nv">ret</span><span class="si">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">fi</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># 11. 打印结束时间</span>
</span></span><span class="line"><span class="cl">    <span class="nb">echo</span> -n <span class="s2">&#34;time==&gt;&gt;run codegen layer-end===   &#34;</span><span class="p">;</span> date<span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h2 id="get_codegen_file">get_codegen_file<a hidden class="anchor" aria-hidden="true" href="#get_codegen_file">#</a></h2>
<p><code>get_codegen_file</code> 用于整理代码生成的结果 (位于 <code>${BEMLIR_PROJECT_ROOT}/build/bin/${codegen_case}</code>)，为每个节点生成版本信息 (version.txt)，并将生成的文件复制到测试目录 (<code>${BEMLIR_PROJECT_ROOT}/external/tx8be-oplib/tests/test_codegen</code>)，最后调用 <code>get_codegen_host</code> 完成主机相关处理。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># Function to process and organize generated codegen files</span>
</span></span><span class="line"><span class="cl"><span class="k">function</span> get_codegen_file<span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Print all input arguments for debugging</span>
</span></span><span class="line"><span class="cl">    <span class="nb">echo</span> <span class="s2">&#34;</span><span class="nv">$*</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Assign first argument as the codegen case name or path</span>
</span></span><span class="line"><span class="cl">    <span class="nv">codegen_case</span><span class="o">=</span><span class="nv">$1</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Second argument: 0 for host thread mode, 1 for host stream mode</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Note: $2 is passed to get_codegen_host</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Change to the codegen case directory under build/bin</span>
</span></span><span class="line"><span class="cl">    <span class="nb">pushd</span> <span class="s2">&#34;</span><span class="si">${</span><span class="nv">BEMLIR_PROJECT_ROOT</span><span class="si">}</span><span class="s2">/build/bin/</span><span class="si">${</span><span class="nv">codegen_case</span><span class="si">}</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># Find node directories matching node_[0-9]+_[0-9] pattern (e.g., node_123_4)</span>
</span></span><span class="line"><span class="cl">        <span class="nv">node_dirs</span><span class="o">=</span><span class="k">$(</span>find . -maxdepth <span class="m">1</span> -type d -regex <span class="s1">&#39;.*/node_[0-9]+_[0-9]&#39;</span> -exec basename <span class="o">{}</span> <span class="se">\;</span><span class="k">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># Iterate through each node directory</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> dir in <span class="nv">$node_dirs</span><span class="p">;</span> <span class="k">do</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># Check if libTX8MLIRTransforms.a exists to determine version type</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="o">[</span> ! -e <span class="s2">&#34;</span><span class="si">${</span><span class="nv">BEMLIR_PROJECT_ROOT</span><span class="si">}</span><span class="s2">/lib/libTX8MLIRTransforms.a&#34;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="cl">                <span class="c1"># Write &#39;tx8be-mlir&#39; to version.txt if library is absent</span>
</span></span><span class="line"><span class="cl">                <span class="nb">echo</span> -e <span class="s2">&#34;tx8be-mlir&#34;</span> &gt; <span class="s2">&#34;</span><span class="si">${</span><span class="nv">dir</span><span class="si">}</span><span class="s2">/version.txt&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span>
</span></span><span class="line"><span class="cl">                <span class="c1"># Write &#39;tx8be-mlir-sdk&#39; to version.txt if library is present</span>
</span></span><span class="line"><span class="cl">                <span class="nb">echo</span> -e <span class="s2">&#34;tx8be-mlir-sdk&#34;</span> &gt; <span class="s2">&#34;</span><span class="si">${</span><span class="nv">dir</span><span class="si">}</span><span class="s2">/version.txt&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="k">fi</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># Append git status to version.txt to record repository state</span>
</span></span><span class="line"><span class="cl">            git status --porcelain &gt;&gt; <span class="s2">&#34;</span><span class="si">${</span><span class="nv">dir</span><span class="si">}</span><span class="s2">/version.txt&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># Append last two git commits to version.txt for version history</span>
</span></span><span class="line"><span class="cl">            git log -2 &gt;&gt; <span class="s2">&#34;</span><span class="si">${</span><span class="nv">dir</span><span class="si">}</span><span class="s2">/version.txt&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="k">done</span>
</span></span><span class="line"><span class="cl">    <span class="nb">popd</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Change to the test_codegen directory</span>
</span></span><span class="line"><span class="cl">    <span class="nb">pushd</span> <span class="s2">&#34;</span><span class="si">${</span><span class="nv">BEMLIR_PROJECT_ROOT</span><span class="si">}</span><span class="s2">/external/tx8be-oplib/tests/test_codegen&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># Remove existing codegen_case directory to ensure a clean state</span>
</span></span><span class="line"><span class="cl">        rm -rf <span class="s2">&#34;</span><span class="si">${</span><span class="nv">codegen_case</span><span class="si">}</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># Copy the codegen_case directory from build/bin</span>
</span></span><span class="line"><span class="cl">        cp -r <span class="s2">&#34;</span><span class="si">${</span><span class="nv">BEMLIR_PROJECT_ROOT</span><span class="si">}</span><span class="s2">/build/bin/</span><span class="si">${</span><span class="nv">codegen_case</span><span class="si">}</span><span class="s2">&#34;</span> .
</span></span><span class="line"><span class="cl">    <span class="nb">popd</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Call get_codegen_host to process host-related tasks</span>
</span></span><span class="line"><span class="cl">    get_codegen_host <span class="s2">&#34;</span><span class="si">${</span><span class="nv">codegen_case</span><span class="si">}</span><span class="s2">&#34;</span> <span class="s2">&#34;</span><span class="nv">$2</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h2 id="get_codegen_host">get_codegen_host<a hidden class="anchor" aria-hidden="true" href="#get_codegen_host">#</a></h2>
<p><code>get_codegen_host </code> 用于为 host 环境准备代码生成用例的测试文件。它在指定的测试用例目录中处理 node &amp; chip 相关的文件，复制必要的配置文件、源代码和构建脚本，并根据 host_type 选择不同的主机实现文件 host_thread.cpp 或 host_stream.cpp.</p>
<ol>
<li>函数输入参数：</li>
</ol>
<ul>
<li><code>$1 (codegen_case)</code>: 代码生成用例的名称或路径，通常是一个目录 (例如 codegen0 或 codegen1) ，表示测试用例的根目录。</li>
<li><code>$2 (host_type)</code>: 主机执行模式，0: host_thread.cpp，1: host_stream.cpp.</li>
</ul>
<ol start="2">
<li>切换到 <code>${{OPLIB_PROJECT_ROOT}}/tests/test_codegen/${codegen_case}</code> 目录:</li>
</ol>
<ul>
<li>使用 find 命令查找符合 node_[0-9]+_[0-9] 模式 (例如 node_123_4) 的子目录，表示代码生成中的节点。</li>
<li>对每个 node_dir 追加版本信息和复制相关文件。</li>
</ul>
<ol start="3">
<li>处理 chip 目录:</li>
</ol>
<ul>
<li>在每个节点目录下，查找符合 <code> chip[0-9]+</code> 模式 (例如 chip0, chip1) 的子目录</li>
<li>为每个 dir 复制 Makefile_tile 到 <code>./${node_dir}/${dir}/Makefile</code>. 在 <code>./${node_dir}/${dir}/</code> 下创建 16 个子目录 (tiles0 - tiles15)，并为每个子目录复制 Makefile_main 到 t <code>iles$i/Makefile</code></li>
</ul>
<ol start="4">
<li>根据 <code>host_type</code> 复制 host_thread.cpp 或 host_stream.cpp 到当前目录的 host.cpp.</li>
<li>复制 CMakeLists.txt 和 Makefile 到当前目录。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># Function to prepare host-related files for a codegen test case</span>
</span></span><span class="line"><span class="cl"><span class="k">function</span> get_codegen_host<span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Print all input arguments for debugging</span>
</span></span><span class="line"><span class="cl">    <span class="nb">echo</span> <span class="s2">&#34;</span><span class="nv">$*</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Assign first argument as the codegen case name or path</span>
</span></span><span class="line"><span class="cl">    <span class="nv">codegen_case</span><span class="o">=</span><span class="nv">$1</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Assign second argument as host type (0: thread mode, 1: stream mode)</span>
</span></span><span class="line"><span class="cl">    <span class="nv">host_type</span><span class="o">=</span><span class="nv">$2</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Define relative path for test_codegen directory</span>
</span></span><span class="line"><span class="cl">    <span class="nv">oplib_path</span><span class="o">=</span><span class="s2">&#34;tests/test_codegen&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Change to the test_codegen directory for the codegen case</span>
</span></span><span class="line"><span class="cl">    <span class="nb">pushd</span> <span class="s2">&#34;</span><span class="si">${</span><span class="p">{OPLIB_PROJECT_ROOT</span><span class="si">}</span><span class="s2">}/tests/test_codegen/</span><span class="si">${</span><span class="nv">codegen_case</span><span class="si">}</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># Find node directories matching node_[0-9]+_[0-9] pattern (e.g., node_123_4)</span>
</span></span><span class="line"><span class="cl">        <span class="nv">node_dirs</span><span class="o">=</span><span class="k">$(</span>find . -maxdepth <span class="m">1</span> -type d -regex <span class="s1">&#39;.*/node_[0-9]+_[0-9]&#39;</span> -exec basename <span class="o">{}</span> <span class="se">\;</span><span class="k">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> node_dir in <span class="nv">$node_dirs</span><span class="p">;</span> <span class="k">do</span>  <span class="c1"># # Iterate through each node directory</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># Append oplib version info to version.txt</span>
</span></span><span class="line"><span class="cl">            <span class="nb">echo</span> -e <span class="s2">&#34;\n\ntx8be-oplib:&#34;</span> &gt;&gt; <span class="s2">&#34;</span><span class="si">${</span><span class="nv">node_dir</span><span class="si">}</span><span class="s2">/version.txt&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># Append git status to version.txt to record repository state</span>
</span></span><span class="line"><span class="cl">            git status --porcelain &gt;&gt; <span class="s2">&#34;</span><span class="si">${</span><span class="nv">node_dir</span><span class="si">}</span><span class="s2">/version.txt&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># Write last two git commits to version.txt for version history</span>
</span></span><span class="line"><span class="cl">            git log -2 &gt;&gt; <span class="s2">&#34;</span><span class="si">${</span><span class="nv">node_dir</span><span class="si">}</span><span class="s2">/version.txt&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1"># Copy all stream-related files to node directory</span>
</span></span><span class="line"><span class="cl">            cp <span class="s2">&#34;</span><span class="si">${</span><span class="p">{OPLIB_PROJECT_ROOT</span><span class="si">}</span><span class="s2">}/tools/codegen/stream*&#34;</span> <span class="s2">&#34;./</span><span class="si">${</span><span class="nv">node_dir</span><span class="si">}</span><span class="s2">/&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># Copy CMakeLists_chip.txt as CMakeLists.txt for node</span>
</span></span><span class="line"><span class="cl">            cp <span class="s2">&#34;</span><span class="si">${</span><span class="p">{OPLIB_PROJECT_ROOT</span><span class="si">}</span><span class="s2">}/tools/codegen/CMakeLists_chip.txt&#34;</span> <span class="s2">&#34;./</span><span class="si">${</span><span class="nv">node_dir</span><span class="si">}</span><span class="s2">/CMakeLists.txt&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># Copy main_kcore.c to node directory</span>
</span></span><span class="line"><span class="cl">            cp <span class="s2">&#34;</span><span class="si">${</span><span class="p">{OPLIB_PROJECT_ROOT</span><span class="si">}</span><span class="s2">}/tools/codegen/main_kcore.c&#34;</span> <span class="s2">&#34;./</span><span class="si">${</span><span class="nv">node_dir</span><span class="si">}</span><span class="s2">/&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># Copy Makefile_chip as Makefile for node</span>
</span></span><span class="line"><span class="cl">            cp <span class="s2">&#34;</span><span class="si">${</span><span class="p">{OPLIB_PROJECT_ROOT</span><span class="si">}</span><span class="s2">}/tools/codegen/Makefile_chip&#34;</span> <span class="s2">&#34;./</span><span class="si">${</span><span class="nv">node_dir</span><span class="si">}</span><span class="s2">/Makefile&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1"># Find chip directories matching chip[0-9]+ pattern (e.g., chip0, chip1)</span>
</span></span><span class="line"><span class="cl">            <span class="nv">chip_dirs</span><span class="o">=</span><span class="k">$(</span>find <span class="s2">&#34;./</span><span class="si">${</span><span class="nv">node_dir</span><span class="si">}</span><span class="s2">&#34;</span> -maxdepth <span class="m">1</span> -type d -regex <span class="s1">&#39;.*/chip[0-9]+&#39;</span> -exec basename <span class="o">{}</span> <span class="se">\;</span><span class="k">)</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># Iterate through each chip directory</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> dir in <span class="nv">$chip_dirs</span><span class="p">;</span> <span class="k">do</span>
</span></span><span class="line"><span class="cl">                <span class="c1"># Copy Makefile_tile as Makefile for chip</span>
</span></span><span class="line"><span class="cl">                cp <span class="s2">&#34;</span><span class="si">${</span><span class="p">{OPLIB_PROJECT_ROOT</span><span class="si">}</span><span class="s2">}/tools/codegen/Makefile_tile&#34;</span> <span class="s2">&#34;./</span><span class="si">${</span><span class="nv">node_dir</span><span class="si">}</span><span class="s2">/</span><span class="si">${</span><span class="nv">dir</span><span class="si">}</span><span class="s2">/Makefile&#34;</span>
</span></span><span class="line"><span class="cl">                <span class="c1"># Create Makefiles for 16 tiles (tiles0 to tiles15)</span>
</span></span><span class="line"><span class="cl">                <span class="k">for</span> <span class="o">((</span><span class="nv">i</span><span class="o">=</span>0<span class="p">;</span> i&lt;16<span class="p">;</span> i++<span class="o">))</span><span class="p">;</span> <span class="k">do</span>
</span></span><span class="line"><span class="cl">                    <span class="nv">dst_file</span><span class="o">=</span><span class="s2">&#34;./</span><span class="si">${</span><span class="nv">node_dir</span><span class="si">}</span><span class="s2">/</span><span class="si">${</span><span class="nv">dir</span><span class="si">}</span><span class="s2">/tiles</span><span class="si">${</span><span class="nv">i</span><span class="si">}</span><span class="s2">/Makefile&#34;</span>
</span></span><span class="line"><span class="cl">                    <span class="c1"># Copy Makefile_main to each tile&#39;s Makefile</span>
</span></span><span class="line"><span class="cl">                    cp <span class="s2">&#34;</span><span class="si">${</span><span class="p">{OPLIB_PROJECT_ROOT</span><span class="si">}</span><span class="s2">}/tools/codegen/Makefile_main&#34;</span> <span class="s2">&#34;</span><span class="nv">$dst_file</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl">                <span class="k">done</span>
</span></span><span class="line"><span class="cl">            <span class="k">done</span>
</span></span><span class="line"><span class="cl">        <span class="k">done</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># Copy host implementation based on host_type</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">[</span> <span class="nv">$host_type</span> -eq <span class="m">0</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># Use thread-based host implementation</span>
</span></span><span class="line"><span class="cl">            cp <span class="s2">&#34;</span><span class="si">${</span><span class="p">{OPLIB_PROJECT_ROOT</span><span class="si">}</span><span class="s2">}/tools/codegen/host_thread.cpp&#34;</span> <span class="s2">&#34;host.cpp&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># Use stream-based host implementation</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># Note: Fixed typo &#39;$t{OPLIB_PROJECT_ROOT}&#39; to &#39;${{OPLIB_PROJECT_ROOT}}&#39;</span>
</span></span><span class="line"><span class="cl">            cp <span class="s2">&#34;</span><span class="si">${</span><span class="p">{OPLIB_PROJECT_ROOT</span><span class="si">}</span><span class="s2">}/tools/codegen/host_stream.cpp&#34;</span> <span class="s2">&#34;host.cpp&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="k">fi</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># Copy top-level CMakeLists.txt for test case</span>
</span></span><span class="line"><span class="cl">        cp <span class="s2">&#34;</span><span class="si">${</span><span class="p">{OPLIB_PROJECT_ROOT</span><span class="si">}</span><span class="s2">}/tools/codegen/CMakeLists.txt&#34;</span> .
</span></span><span class="line"><span class="cl">        <span class="c1"># Copy top-level Makefile for test case</span>
</span></span><span class="line"><span class="cl">        cp <span class="s2">&#34;</span><span class="si">${</span><span class="p">{OPLIB_PROJECT_ROOT</span><span class="si">}</span><span class="s2">}/tools/codegen/Makefile&#34;</span> .
</span></span><span class="line"><span class="cl">    <span class="c1"># Restore original directory</span>
</span></span><span class="line"><span class="cl">    <span class="nb">popd</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h2 id="run_on_cmodel">run_on_cmodel<a hidden class="anchor" aria-hidden="true" href="#run_on_cmodel">#</a></h2>
<p><code>run_on_cmodel</code> 用于在指定的测试用例目录中运行 cmodel 仿真任务。函数的主要功能包括环境设置、构建、执行仿真脚本或程序，并处理错误。以下是详细的功能说明：</p>
<ol>
<li>函数输入参数：</li>
</ol>
<ul>
<li>$1 (case_name): 来自 <code>run_codegen_layer</code> 的 <code>codegen_path</code>，可能附加 <code>host_type</code>.</li>
<li>$2 (run_flag): 运行标志，来自 <code>run_codegen_layer</code> 的 <code>cmp_flag</code> 用于控制仿真执行的方式 (例如是否运行或运行模式) 。</li>
</ul>
<ol start="2">
<li>切换工作目录并执行:</li>
</ol>
<ul>
<li>切换到测试用例目录 <code>${{OPLIB_PROJECT_ROOT}}/tests/test_codegen/${case_name}</code></li>
<li>运行 <code>cmake .. -DUSING_RISCV=OFF</code>，配置构建系统，禁用 RISCV 支持。</li>
<li>运行 <code>make -j</code> 并动态设置并行任务数 (基于 CPU 核心数，<code>cat /proc/stat | grep cpu[0-9] -c</code>)</li>
</ul>
<ol start="3">
<li>仿真执行: 根据参数运行仿真脚本 (host_sim.sh) 或 host_sim.</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># Function to run a cmodel simulation for a given test case</span>
</span></span><span class="line"><span class="cl"><span class="k">function</span> run_on_cmodel<span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Assign first argument as the test case name</span>
</span></span><span class="line"><span class="cl">    <span class="nv">case_name</span><span class="o">=</span><span class="nv">$1</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Assign second argument as the run flag (controls execution mode)</span>
</span></span><span class="line"><span class="cl">    <span class="nv">run_flag</span><span class="o">=</span><span class="nv">$2</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Check if case_name is empty</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">[</span> -z <span class="s2">&#34;</span><span class="nv">$case_name</span><span class="s2">&#34;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="cl">        <span class="nb">echo</span> <span class="s2">&#34;Error: case_name is empty&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="m">1</span>
</span></span><span class="line"><span class="cl">    <span class="k">fi</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Check if the test case directory exists</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">[</span> ! -d <span class="s2">&#34;</span><span class="si">${</span><span class="p">{OPLIB_PROJECT_ROOT</span><span class="si">}</span><span class="s2">}/tests/test_codegen/</span><span class="si">${</span><span class="nv">case_name</span><span class="si">}</span><span class="s2">&#34;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="cl">        <span class="nb">echo</span> <span class="s2">&#34;Can not find </span><span class="si">${</span><span class="nv">case_name</span><span class="si">}</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="m">1</span>
</span></span><span class="line"><span class="cl">    <span class="k">fi</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Change to the test case directory</span>
</span></span><span class="line"><span class="cl">    <span class="nb">pushd</span> <span class="s2">&#34;</span><span class="si">${</span><span class="p">{OPLIB_PROJECT_ROOT</span><span class="si">}</span><span class="s2">}/tests/test_codegen/</span><span class="si">${</span><span class="nv">case_name</span><span class="si">}</span><span class="s2">&#34;</span>  <span class="c1"># FIXED DIR</span>
</span></span><span class="line"><span class="cl">        rm -rf build
</span></span><span class="line"><span class="cl">        mkdir build
</span></span><span class="line"><span class="cl">        <span class="nb">cd</span> build
</span></span><span class="line"><span class="cl">        <span class="c1"># Run cmake to configure the build, disabling RISCV support</span>
</span></span><span class="line"><span class="cl">        cmake .. -DUSING_RISCV<span class="o">=</span>OFF
</span></span><span class="line"><span class="cl">        <span class="c1"># Run make with parallel jobs based on CPU core count</span>
</span></span><span class="line"><span class="cl">        make -j<span class="k">$(</span>cat /proc/stat <span class="p">|</span> grep cpu<span class="o">[</span>0-9<span class="o">]</span> -c<span class="k">)</span>
</span></span><span class="line"><span class="cl">        <span class="nv">ret</span><span class="o">=</span><span class="nv">$?</span>  <span class="c1"># Capture the return code</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># If make fails, restore directory, print error, and exit</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">[[</span> <span class="nv">$ret</span> -ne <span class="m">0</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="cl">            <span class="nb">popd</span>
</span></span><span class="line"><span class="cl">            <span class="nb">echo</span> <span class="nv">$ret</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nv">$ret</span>
</span></span><span class="line"><span class="cl">        <span class="k">fi</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># Check if run_flag is empty</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">[</span> -z <span class="s2">&#34;</span><span class="nv">$run_flag</span><span class="s2">&#34;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="o">[</span> -e ../host_sim.sh <span class="o">]</span><span class="p">;</span> <span class="k">then</span>  <span class="c1"># Check if host_sim.sh exists in the parent directory</span>
</span></span><span class="line"><span class="cl">                cp ../host_sim.sh .
</span></span><span class="line"><span class="cl">                sh ./host_sim.sh
</span></span><span class="line"><span class="cl">                <span class="nv">ret</span><span class="o">=</span><span class="nv">$?</span>  <span class="c1"># Capture the return code</span>
</span></span><span class="line"><span class="cl">                <span class="c1"># If script fails, restore directory, print error, and exit</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="o">[[</span> <span class="nv">$ret</span> -ne <span class="m">0</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>  
</span></span><span class="line"><span class="cl">                    <span class="nb">popd</span>
</span></span><span class="line"><span class="cl">                    <span class="nb">echo</span> <span class="nv">$ret</span>
</span></span><span class="line"><span class="cl">                    <span class="k">return</span> <span class="nv">$ret</span>
</span></span><span class="line"><span class="cl">                <span class="k">fi</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span>
</span></span><span class="line"><span class="cl">                ./host_sim ../  <span class="c1"># Run host_sim with parent directory as argument</span>
</span></span><span class="line"><span class="cl">                <span class="nv">ret</span><span class="o">=</span><span class="nv">$?</span>  <span class="c1"># Capture the return code</span>
</span></span><span class="line"><span class="cl">                <span class="c1"># If host_sim fails, restore directory, print error, and exit</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="o">[[</span> <span class="nv">$ret</span> -ne <span class="m">0</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="cl">                    <span class="nb">popd</span>
</span></span><span class="line"><span class="cl">                    <span class="nb">echo</span> <span class="nv">$ret</span>
</span></span><span class="line"><span class="cl">                    <span class="k">return</span> <span class="nv">$ret</span>
</span></span><span class="line"><span class="cl">                <span class="k">fi</span>
</span></span><span class="line"><span class="cl">            <span class="k">fi</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># Check if run_flag is &#34;0&#34; or &#34;1&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="k">elif</span> <span class="o">[[</span> <span class="nv">$run_flag</span> <span class="o">==</span> <span class="s2">&#34;0&#34;</span> <span class="o">]]</span> <span class="o">||</span> <span class="o">[[</span> <span class="nv">$run_flag</span> <span class="o">==</span> <span class="s2">&#34;1&#34;</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># Run host_sim with parent directory and run_flag</span>
</span></span><span class="line"><span class="cl">            ./host_sim ../ <span class="s2">&#34;</span><span class="nv">$run_flag</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="nv">ret</span><span class="o">=</span><span class="nv">$?</span>  <span class="c1"># Capture the return code</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># If host_sim fails, restore directory, print error, and exit</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="o">[[</span> <span class="nv">$ret</span> -ne <span class="m">0</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="cl">                <span class="nb">popd</span>
</span></span><span class="line"><span class="cl">                <span class="nb">echo</span> <span class="nv">$ret</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="nv">$ret</span>
</span></span><span class="line"><span class="cl">            <span class="k">fi</span>
</span></span><span class="line"><span class="cl">        <span class="k">fi</span>
</span></span><span class="line"><span class="cl">    <span class="nb">popd</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nb">echo</span> <span class="s2">&#34;</span><span class="si">${</span><span class="nv">FUNCNAME</span><span class="p">[0]</span><span class="si">}</span><span class="s2"> </span><span class="nv">$*</span><span class="s2"> passed&#34;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h1 id="run_codegen_case_soc_rtt">run_codegen_case_soc_rtt<a hidden class="anchor" aria-hidden="true" href="#run_codegen_case_soc_rtt">#</a></h1>
<p>run_codegen_case_soc_rtt 位于 <code>tx8-oplib/scripts/regression.sh</code>，函数用于在 SOC 环境下运行 RTT (Real-Time Transfer) 测试。其主要流程如下：</p>
<ol>
<li>初始化和参数获取：</li>
</ol>
<ul>
<li>函数从命令行参数中获取 <code>case_name</code>, <code>copy_option</code>, 和 <code>multi_graph_enable</code>.</li>
<li>检查 <code>case_name</code> 是否为空，如果为空则输出错误信息并返回 1.</li>
</ul>
<ol start="2">
<li>环境设置和目录导航：</li>
</ol>
<ul>
<li>将工作目录切换到 <code>${OPLIB_PROJECT_ROOT}/tests/test_codegen/${case_name}</code>. 如果目录不存在，则输出错误信息并返回 1。</li>
</ul>
<ol start="3">
<li>构建和配置：</li>
</ol>
<ul>
<li>执行 <code>rm -rf ${case_name}_build</code> 清理之前的构建文件。</li>
<li>根据 <code>multi_graph_enable</code> 设置 <code>CONFIG_ARGS</code>，如果启用多图则设置为 &ldquo;-DMULTI_GRAPH=1&rdquo;，否则为空。</li>
<li>调用 cmake 命令生成构建文件，指定构建目录为 <code>${case_name}_build</code>，并根据 <code>copy_option</code> 设置 <code>COPY_RTT_FLAG</code>.</li>
<li>执行 make 命令进行实际构建，目标包括 all 和 chip_out.</li>
</ul>
<ol start="4">
<li>错误处理和退出：</li>
</ol>
<ul>
<li>每次关键步骤执行后，检查返回状态 <code>$ret</code>，如果非 0，则弹出目录并返回错误码。</li>
<li>构建成功后输出 <code>${FUNCNAME[0]} &quot;passed&quot;</code> 表示通过。</li>
</ul>
<ol start="5">
<li>清理和返回: 函数结束时弹出目录，恢复原始工作目录。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="k">function</span> run_codegen_case_soc_rtt<span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">echo</span> <span class="s2">&#34;</span><span class="si">${</span><span class="nv">FUNCNAME</span><span class="p">[0]</span><span class="si">}</span><span class="s2"> &#39;start&#39;&#34;</span>  <span class="c1"># 输出函数名和&#34;start&#34;表示开始</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nv">case_name</span><span class="o">=</span><span class="nv">$1</span>                  <span class="c1"># 获取用例名称</span>
</span></span><span class="line"><span class="cl">    <span class="nv">copy_option</span><span class="o">=</span><span class="nv">$2</span>                 <span class="c1"># 获取复制选项</span>
</span></span><span class="line"><span class="cl">    <span class="nv">multi_graph_enable</span><span class="o">=</span><span class="nv">$3</span>          <span class="c1"># 获取多图启用标志</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">[</span> -z <span class="s2">&#34;</span><span class="nv">$case_name</span><span class="s2">&#34;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>   <span class="c1"># 如果用例名称为空</span>
</span></span><span class="line"><span class="cl">        <span class="nb">echo</span> <span class="s2">&#34;case_name(</span><span class="nv">$case_name</span><span class="s2">) not found &#34;</span>  <span class="c1"># 输出错误信息</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="m">1</span>                   <span class="c1"># 返回错误码 1</span>
</span></span><span class="line"><span class="cl">    <span class="k">fi</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nv">case_dir</span><span class="o">=</span><span class="si">${</span><span class="nv">OPLIB_PROJECT_ROOT</span><span class="si">}</span>/tests/test_codegen/<span class="si">${</span><span class="nv">case_name</span><span class="si">}</span>  <span class="c1"># 设置用例目录</span>
</span></span><span class="line"><span class="cl">    <span class="nb">pushd</span> <span class="si">${</span><span class="nv">case_dir</span><span class="si">}</span>              <span class="c1"># 切换到用例目录</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    rm -rf <span class="si">${</span><span class="nv">case_name</span><span class="si">}</span>_build      <span class="c1"># 清理之前的构建文件</span>
</span></span><span class="line"><span class="cl">    <span class="nv">ret</span><span class="o">=</span><span class="nv">$?</span><span class="p">;</span> <span class="k">if</span> <span class="o">[</span> <span class="o">[</span> <span class="nv">$ret</span> -ne <span class="m">0</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span> popd<span class="p">;</span> <span class="nb">echo</span> <span class="nv">$ret</span><span class="p">;</span> <span class="k">return</span> <span class="nv">$ret</span><span class="p">;</span> <span class="k">fi</span>  <span class="c1"># 检查清理是否成功</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">[</span> -z <span class="s2">&#34;</span><span class="nv">$multi_graph_enable</span><span class="s2">&#34;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>  <span class="c1"># 如果多图启用标志为空</span>
</span></span><span class="line"><span class="cl">        <span class="nv">CONFIG_ARGS</span><span class="o">=</span><span class="s2">&#34;&#34;</span>                 <span class="c1"># 配置参数为空</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>                                 <span class="c1"># 否则</span>
</span></span><span class="line"><span class="cl">        <span class="nv">CONFIG_ARGS</span><span class="o">=</span><span class="s2">&#34;-DMULTI_GRAPH=1&#34;</span>  <span class="c1"># 设置多图配置参数</span>
</span></span><span class="line"><span class="cl">    <span class="k">fi</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    cmake -B <span class="s2">&#34;</span><span class="si">${</span><span class="nv">case_name</span><span class="si">}</span><span class="s2">_build&#34;</span> -DUSING_RISCV<span class="o">=</span>ON -TX8FW_BASE<span class="o">=</span><span class="si">${</span><span class="nv">OPLIB_PROJECT_ROOT</span><span class="si">}</span>/release/riscv/tx8-yoc-rt-thread-smp <span class="si">${</span><span class="nv">CONFIG_ARGS</span><span class="si">}</span> <span class="p">;</span> <span class="nv">ret</span><span class="o">=</span><span class="nv">$?</span><span class="p">;</span> <span class="k">if</span> <span class="o">[</span> <span class="o">[</span> <span class="nv">$ret</span> -ne <span class="m">0</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span> popd<span class="p">;</span> <span class="nb">echo</span> <span class="nv">$ret</span><span class="p">;</span> <span class="k">return</span> <span class="nv">$ret</span><span class="p">;</span> <span class="k">fi</span>  <span class="c1"># 生成构建文件</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    make -j -C <span class="s2">&#34;</span><span class="si">${</span><span class="nv">case_name</span><span class="si">}</span><span class="s2">_build&#34;</span> --target all chip_out <span class="p">;</span> <span class="nv">ret</span><span class="o">=</span><span class="nv">$?</span><span class="p">;</span> <span class="k">if</span> <span class="o">[</span> <span class="o">[</span> <span class="nv">$ret</span> -ne <span class="m">0</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span> popd<span class="p">;</span> <span class="nb">echo</span> <span class="nv">$ret</span><span class="p">;</span> <span class="k">return</span> <span class="nv">$ret</span><span class="p">;</span> <span class="k">fi</span>  <span class="c1"># 执行构建</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nb">popd</span>                          <span class="c1"># 恢复到原始目录</span>
</span></span><span class="line"><span class="cl">    <span class="nb">echo</span> <span class="s2">&#34;</span><span class="si">${</span><span class="nv">FUNCNAME</span><span class="p">[0]</span><span class="si">}</span><span class="s2"> &#39;passed&#39;&#34;</span> <span class="c1"># 输出函数名和&#34;passed&#34;表示通过</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h2 id="export_tx8fw_to_env">export_tx8fw_to_env<a hidden class="anchor" aria-hidden="true" href="#export_tx8fw_to_env">#</a></h2>
<p><code>export_tx8fw_to_env</code> 函数的主要目的是设置与 TX8FW 相关的环境变量，以便后续构建或运行时使用。以下是其流程：</p>
<ol>
<li>设置 SDK 路径：</li>
</ol>
<ul>
<li>定义 TX8FW 的 SDK 路径 <code>soc_sdk_path</code> 为 <code>${OPLIB_PROJECT_ROOT}/3rd_party/tx8-yoc-rt-thread-smp</code>.</li>
</ul>
<ol start="2">
<li>检查路径是否存在:</li>
</ol>
<ul>
<li>检查路径 <code>${soc_sdk_path}/tool/tx8fw-xuantie-sdk</code> 是否存在。如果不存在，打印错误信息并退出，状态码为 1.</li>
</ul>
<ol start="3">
<li>导出环境变量: 打印并设置以下环境变量</li>
</ol>
<ul>
<li>TX8FW_SDK_INSTALL_DIR：指向 ${soc_sdk_path}/tool/tx8fw-xuantie-sdk。</li>
<li>TX8FW_TOOLCHAIN_VARIANT：设置为 cross-compile。</li>
</ul>
<ol start="4">
<li>清理目录: 使用 popd 命令恢复到之前的目录.</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="k">function</span> export_tx8fw_to_env<span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="nv">soc_sdk_path</span><span class="o">=</span><span class="si">${</span><span class="nv">OPLIB_PROJECT_ROOT</span><span class="si">}</span>/3rd_party/tx8-yoc-rt-thread-smp  <span class="c1"># 设置 TX8FW SDK 路径</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nb">pushd</span> <span class="si">${</span><span class="nv">soc_sdk_path</span><span class="si">}</span>/tool/tx8fw-xuantie-sdk  <span class="c1"># 切换到 TX8FW SDK 工具目录</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">[</span> ! -d <span class="s2">&#34;xuantie-900-gcc-elf-newlib-x86_64-V2.8.0&#34;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>  <span class="c1"># 检查指定 SDK 目录是否存在</span>
</span></span><span class="line"><span class="cl">        <span class="nb">echo</span> <span class="s2">&#34;</span><span class="si">${</span><span class="nv">soc_sdk_path</span><span class="si">}</span><span class="s2">/tool/tx8fw-xuantie-sdk didn&#39;t exist&#34;</span>  <span class="c1"># 如果不存在，打印错误信息</span>
</span></span><span class="line"><span class="cl">        <span class="nb">exit</span> <span class="m">1</span>  <span class="c1"># 退出并返回状态码 1</span>
</span></span><span class="line"><span class="cl">    <span class="k">fi</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nb">echo</span> <span class="s2">&#34;export TX8FW_SDK_INSTALL_DIR=</span><span class="si">${</span><span class="nv">soc_sdk_path</span><span class="si">}</span><span class="s2">/tool/tx8fw-xuantie-sdk&#34;</span>  <span class="c1"># 打印并设置 TX8FW SDK 安装目录环境变量</span>
</span></span><span class="line"><span class="cl">    <span class="nb">export</span> <span class="nv">TX8FW_SDK_INSTALL_DIR</span><span class="o">=</span><span class="si">${</span><span class="nv">soc_sdk_path</span><span class="si">}</span>/tool/tx8fw-xuantie-sdk  <span class="c1"># 导出 TX8FW SDK 安装目录环境变量</span>
</span></span><span class="line"><span class="cl">    <span class="nb">export</span> <span class="nv">TX8FW_TOOLCHAIN_VARIANT</span><span class="o">=</span>cross-compile  <span class="c1"># 导出工具链变体为 cross-compile</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nb">popd</span>  <span class="c1"># 恢复到之前的目录</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h2 id="build_oplib_with_soc-函数">build_oplib_with_soc 函数<a hidden class="anchor" aria-hidden="true" href="#build_oplib_with_soc-函数">#</a></h2>
<p><code>build_oplib_with_soc</code> 函数用于构建 OPLib 并结合特定 SoC 配置。以下是其流程：</p>
<p>打印项目根目录：
打印 OPLIB_PROJECT_ROOT 环境变量，用于调试或日志记录。</p>
<ol>
<li>切换目录和初始化：</li>
</ol>
<ul>
<li>使用 pushd 切换到 <code>OPLIB_PROJECT_ROOT</code> 目录。</li>
<li>定义变量 <code>rm=rf build</code>, <code>mkdir=build</code> 和 <code>cd=build</code>，这些变量实际上是模拟命令（rm -rf build、mkdir build 和 cd build）。</li>
</ul>
<ol start="2">
<li>设置复制标志：</li>
</ol>
<ul>
<li>检查 <code>$1</code> (即 <code>copy_option</code>) 是否为 &ldquo;NOT_COPY&rdquo;，如果是，则设置 <code>COPY_RTT_FLAG</code> 为 <code>--DRTT_HOST_COPY=OFF</code>，否则为空。</li>
</ul>
<ol start="3">
<li>导出环境变量并构建：</li>
</ol>
<ul>
<li>调用 <code>export_tx8fw_to_env</code> 函数设置 TX8FW 相关环境变量。</li>
<li>运行 cmake 命令，生成构建文件，指定构建选项 <code>-DUSING_RISCV=ON</code> 和 <code>TX8FW_BASE</code>，并根据 <code>COPY_RTT_FLAG</code> 添加额外参数。</li>
<li>使用 make 命令执行构建，目标包括 grep epilog 和 c</li>
</ul>
<ol start="4">
<li>清理目录: 使用 popd 命令恢复到之前的目录.</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="k">function</span> build_oplib_with_soc<span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">echo</span> <span class="si">${</span><span class="nv">OPLIB_PROJECT_ROOT</span><span class="si">}</span>  <span class="c1"># 打印 OPLib 项目根目录路径</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nb">pushd</span> <span class="si">${</span><span class="nv">OPLIB_PROJECT_ROOT</span><span class="si">}</span>  <span class="c1"># 切换到 OPLib 项目根目录</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nv">rm</span><span class="o">=</span>rf build  <span class="c1"># 定义清理构建目录的命令</span>
</span></span><span class="line"><span class="cl">    <span class="nv">mkdir</span><span class="o">=</span>build  <span class="c1"># 定义创建构建目录的命令</span>
</span></span><span class="line"><span class="cl">    <span class="nv">cd</span><span class="o">=</span>build     <span class="c1"># 定义切换到构建目录的命令</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nv">COPY_RTT_FLAG</span><span class="o">=</span><span class="s2">&#34;&#34;</span>  <span class="c1"># 初始化 RTT 复制标志</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">[</span> <span class="s2">&#34;</span><span class="nv">$1</span><span class="s2">&#34;</span> <span class="o">==</span> <span class="s2">&#34;NOT_COPY&#34;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>  <span class="c1"># 如果传入的复制选项为 NOT_COPY</span>
</span></span><span class="line"><span class="cl">        <span class="nv">COPY_RTT_FLAG</span><span class="o">=</span><span class="s2">&#34;--DRTT_HOST_COPY=OFF&#34;</span>  <span class="c1"># 设置 RTT 复制标志为关闭</span>
</span></span><span class="line"><span class="cl">    <span class="k">fi</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    export_tx8fw_to_env  <span class="c1"># 调用函数导出 TX8FW 相关环境变量</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    cmake .. -DUSING_RISCV<span class="o">=</span>ON -TX8FW_BASE<span class="o">=</span><span class="si">${</span><span class="nv">OPLIB_PROJECT_ROOT</span><span class="si">}</span>/release/riscv/tx8-yoc-rt-thread-smp <span class="si">${</span><span class="nv">COPY_RTT_FLAG</span><span class="si">}</span>  <span class="c1"># 生成构建文件，指定 RISCV 和 TX8FW 路径</span>
</span></span><span class="line"><span class="cl">    <span class="nv">ret</span><span class="o">=</span><span class="nv">$?</span><span class="p">;</span> <span class="k">if</span> <span class="o">[</span> <span class="nv">$ret</span> -ne <span class="m">0</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span> popd<span class="p">;</span> <span class="k">return</span> <span class="nv">$ret</span><span class="p">;</span> <span class="k">fi</span>  <span class="c1"># 检查 cmake 是否成功，失败则返回</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    make -j cat /proc/stat <span class="p">|</span> grep epilog -c  <span class="c1"># 执行构建并检查 epilog 相关信息</span>
</span></span><span class="line"><span class="cl">    <span class="nv">ret</span><span class="o">=</span><span class="nv">$?</span><span class="p">;</span> <span class="k">if</span> <span class="o">[</span> <span class="nv">$ret</span> -ne <span class="m">0</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span> popd<span class="p">;</span> <span class="k">return</span> <span class="nv">$ret</span><span class="p">;</span> <span class="k">fi</span>  <span class="c1"># 检查 make 是否成功，失败则返回</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nb">popd</span>  <span class="c1"># 恢复到之前的目录</span>
</span></span><span class="line"><span class="cl">    <span class="nb">echo</span> <span class="si">${</span><span class="nv">FUNCNAME</span><span class="p">[0]</span><span class="si">}</span> <span class="s2">&#34;passed&#34;</span>  <span class="c1"># 输出函数名和&#34;passed&#34;表示构建成功</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><h2 id="run_on_soc_rtt">run_on_soc_rtt<a hidden class="anchor" aria-hidden="true" href="#run_on_soc_rtt">#</a></h2>
<p><code>run_on_soc_rtt</code>，用于在特定 SoC 和 RTT 环境下运行测试用例。以下是其主要流程：</p>
<ol>
<li>初始化和参数获取:</li>
</ol>
<ul>
<li>函数从命令行参数中获取 <code>case_name</code>, <code>rtt_option</code> 和 <code>multi_graph_enable</code>.</li>
<li>检查 <code>case_name</code> 是否为空，如果为空则输出错误信息并返回 1。</li>
</ul>
<ol start="2">
<li>目录切换和清理:</li>
</ol>
<ul>
<li>将工作目录切换到 <code>${OPLIB_PROJECT_ROOT}/tests/test_codegen/${case_name}</code>.</li>
<li>执行 <code>rm -rf ${case_name}_build</code> 清理之前的构建文件。</li>
</ul>
<ol start="3">
<li>配置设置: 根据 <code>multi_graph_enable</code> 设置 CONFIG_ARGS，如果启用多图则设置为 &ldquo;-DMULTI_GRAPH=1&rdquo;，否则为空。</li>
<li>构建和运行：</li>
</ol>
<ul>
<li>使用 cmake 生成构建文件，指定构建目录为 <code>${case_name}_build</code>，并设置 <code>-DUSING_RISCV=ON</code> 和 <code>-TX8FW_BASE</code> 路径。</li>
<li>使用 make 命令执行构建，目标包括 all 和 chip_out.</li>
</ul>
<ol start="5">
<li>清理和返回: 使用 popd 恢复到原始目录。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="k">function</span> run_on_soc_rtt<span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">echo</span> <span class="s2">&#34;</span><span class="si">${</span><span class="nv">FUNCNAME</span><span class="p">[0]</span><span class="si">}</span><span class="s2"> &#39;start&#39;&#34;</span>  <span class="c1"># 输出函数名和&#34;start&#34;表示开始</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nv">case_name</span><span class="o">=</span><span class="nv">$1</span>                  <span class="c1"># 获取用例名称</span>
</span></span><span class="line"><span class="cl">    <span class="nv">rtt_option</span><span class="o">=</span><span class="nv">$2</span>                 <span class="c1"># 获取 RTT 选项</span>
</span></span><span class="line"><span class="cl">    <span class="nv">multi_graph_enable</span><span class="o">=</span><span class="nv">$3</span>         <span class="c1"># 获取多图启用标志</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">[</span> -z <span class="s2">&#34;</span><span class="nv">$case_name</span><span class="s2">&#34;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>   <span class="c1"># 如果用例名称为空</span>
</span></span><span class="line"><span class="cl">        <span class="nb">echo</span> <span class="s2">&#34;case_name(</span><span class="nv">$case_name</span><span class="s2">) not found &#34;</span>  <span class="c1"># 输出错误信息</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="m">1</span>                   <span class="c1"># 返回错误码 1</span>
</span></span><span class="line"><span class="cl">    <span class="k">fi</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nv">case_dir</span><span class="o">=</span><span class="si">${</span><span class="nv">OPLIB_PROJECT_ROOT</span><span class="si">}</span>/tests/test_codegen/<span class="si">${</span><span class="nv">case_name</span><span class="si">}</span>  <span class="c1"># 设置用例目录</span>
</span></span><span class="line"><span class="cl">    <span class="nb">pushd</span> <span class="si">${</span><span class="nv">case_dir</span><span class="si">}</span>              <span class="c1"># 切换到用例目录</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    rm -rf <span class="si">${</span><span class="nv">case_name</span><span class="si">}</span>_build      <span class="c1"># 清理之前的构建文件</span>
</span></span><span class="line"><span class="cl">    <span class="nv">ret</span><span class="o">=</span><span class="nv">$?</span><span class="p">;</span> <span class="k">if</span> <span class="o">[</span> <span class="o">[</span> <span class="nv">$ret</span> -ne <span class="m">0</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span> popd<span class="p">;</span> <span class="nb">echo</span> <span class="nv">$ret</span><span class="p">;</span> <span class="k">return</span> <span class="nv">$ret</span><span class="p">;</span> <span class="k">fi</span>  <span class="c1"># 检查清理是否成功，失败则返回</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">[</span> -z <span class="s2">&#34;</span><span class="nv">$multi_graph_enable</span><span class="s2">&#34;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>  <span class="c1"># 如果多图启用标志为空</span>
</span></span><span class="line"><span class="cl">        <span class="nv">CONFIG_ARGS</span><span class="o">=</span><span class="s2">&#34;&#34;</span>                 <span class="c1"># 配置参数为空</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>                                 <span class="c1"># 否则</span>
</span></span><span class="line"><span class="cl">        <span class="nv">CONFIG_ARGS</span><span class="o">=</span><span class="s2">&#34;-DMULTI_GRAPH=1&#34;</span>  <span class="c1"># 设置多图配置参数</span>
</span></span><span class="line"><span class="cl">    <span class="k">fi</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    cmake -B <span class="s2">&#34;</span><span class="si">${</span><span class="nv">case_name</span><span class="si">}</span><span class="s2">_build&#34;</span> -DUSING_RISCV<span class="o">=</span>ON -TX8FW_BASE<span class="o">=</span><span class="si">${</span><span class="nv">OPLIB_PROJECT_ROOT</span><span class="si">}</span>/release/riscv/tx8-yoc-rt-thread-smp <span class="si">${</span><span class="nv">CONFIG_ARGS</span><span class="si">}</span> <span class="p">;</span> <span class="nv">ret</span><span class="o">=</span><span class="nv">$?</span><span class="p">;</span> <span class="k">if</span> <span class="o">[</span> <span class="o">[</span> <span class="nv">$ret</span> -ne <span class="m">0</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span> popd<span class="p">;</span> <span class="nb">echo</span> <span class="nv">$ret</span><span class="p">;</span> <span class="k">return</span> <span class="nv">$ret</span><span class="p">;</span> <span class="k">fi</span>  <span class="c1"># 生成构建文件，指定 RISCV 和 TX8FW 路径</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    make -C <span class="s2">&#34;</span><span class="si">${</span><span class="nv">case_name</span><span class="si">}</span><span class="s2">_build&#34;</span> --target all chip_out <span class="p">;</span> <span class="nv">ret</span><span class="o">=</span><span class="nv">$?</span><span class="p">;</span> <span class="k">if</span> <span class="o">[</span> <span class="o">[</span> <span class="nv">$ret</span> -ne <span class="m">0</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span> popd<span class="p">;</span> <span class="nb">echo</span> <span class="nv">$ret</span><span class="p">;</span> <span class="k">return</span> <span class="nv">$ret</span><span class="p">;</span> <span class="k">fi</span>  <span class="c1"># 执行构建，目标为 all 和 chip_out</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nb">popd</span>                          <span class="c1"># 恢复到原始目录</span>
</span></span><span class="line"><span class="cl">    <span class="nb">echo</span> <span class="s2">&#34;</span><span class="si">${</span><span class="nv">FUNCNAME</span><span class="p">[0]</span><span class="si">}</span><span class="s2"> &#39;passed&#39;&#34;</span> <span class="c1"># 输出函数名和&#34;passed&#34;表示通过</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/tx8-script/">Tx8-Script</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/blogs/llada/">
    <span class="title">« Prev</span>
    <br>
    <span>LLaDA</span>
  </a>
  <a class="next" href="http://localhost:1313/blogs/astra-sim/">
    <span class="title">Next »</span>
    <br>
    <span>astra-Sim</span>
  </a>
</nav>

  </footer><script src="https://giscus.app/client.js"
        data-repo="jamesnulliu/jamesnulliu.github.io"
        data-repo-id="R_kgDOMPCQIw"
        data-category="Announcements"
        data-category-id="DIC_kwDOMPCQI84Cgb2t"
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="bottom"
        data-theme="preferred_color_scheme"
        data-lang="en"
        crossorigin="anonymous"
        async>
</script>
</article>
    </main>
    
<footer class="footer">
        <span>© 2024-2025 WITHER</span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
