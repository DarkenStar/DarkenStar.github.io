<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>06 Backtracking | WITHER</title>
<meta name="keywords" content="Backtracking">
<meta name="description" content="Algorithm questions about backtracking.">
<meta name="author" content="WITHER">
<link rel="canonical" href="http://localhost:1313/blogs/leetcode/06_backtracking/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.dd3b5b907a50db3238b81d49d094cf1c04a091227797dc9cfde4e2fa3f35df49.css" integrity="sha256-3TtbkHpQ2zI4uB1J0JTPHASgkSJ3l9yc/eTi&#43;j8130k=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/blogs/leetcode/06_backtracking/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<script>
  MathJax = {
    tex: {
      displayMath: [['\\[', '\\]'], ['$$', '$$']],  
      inlineMath: [['\\(', '\\)'], ['$', '$']]  
    }
  };
</script>




<script src="https://cdn.bootcdn.net/ajax/libs/mermaid/9.1.6/mermaid.min.js"></script>
<script>
    mermaid.initialize({
        startOnLoad: true,
        theme: localStorage.getItem("pref-theme") === "dark" ? "dark" : "forest" 
    });
</script>

<meta property="og:url" content="http://localhost:1313/blogs/leetcode/06_backtracking/">
  <meta property="og:site_name" content="WITHER">
  <meta property="og:title" content="06 Backtracking">
  <meta property="og:description" content="Algorithm questions about backtracking.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="blogs">
    <meta property="article:published_time" content="2025-08-04T09:47:31+08:00">
    <meta property="article:modified_time" content="2025-09-19T09:20:48+08:00">
    <meta property="article:tag" content="Backtracking">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="06 Backtracking">
<meta name="twitter:description" content="Algorithm questions about backtracking.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Blogs",
      "item": "http://localhost:1313/blogs/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Leetcode",
      "item": "http://localhost:1313/blogs/leetcode/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "06 Backtracking",
      "item": "http://localhost:1313/blogs/leetcode/06_backtracking/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "06 Backtracking",
  "name": "06 Backtracking",
  "description": "Algorithm questions about backtracking.",
  "keywords": [
    "Backtracking"
  ],
  "articleBody": "Preliminary 原问题: 构造长度为 n 的字符串。 -枚举一个字母后 子问题: 构造长度为 n-1 的字符串。 回溯有一个增量构造答案的过程，这个过程通常用递归来实现。跟之前递归一样，只需要考虑边界条件和非边界条件的逻辑。总结成回溯三问:\n当前操作? 用一个 path 数组记录路径上的字母。当前操作为枚举 path[i] 要填入的字母。 这里需要注意递归参数中的 i 不是指的第 i 个，而是下标 \u003e= i 的这部分。\n子问题? 构造字符串 \u003e= i 的这部分。 下一个子问题? 构造字符串 \u003e= i 的这部分。 整个过程和在一棵树上进行 dfs 是类似的 (dfs(i) –\u003e dfs(i+1)). 17. Letter Combinations of a Phone Number 题目网址.\n边界条件: 枚举完当前路径后把 path 添加进 ans. 递归条件: 遍历当前要枚举的数字所对应的字母，添加进 path 之后进行下一层次递归。结束后恢复现场。 class Solution { public: unordered_map\u003cchar, string\u003e phoneMap{ {'2', \"abc\"}, {'3', \"def\"}, {'4', \"ghi\"}, {'5', \"jkl\"}, {'6', \"mno\"}, {'7', \"pqrs\"}, {'8', \"tuv\"}, {'9', \"wxyz\"} }; string path; vector\u003cstring\u003e ans; void dfs(int i, string digits) { if (i == digits.size()) { ans.push_back(path); return; } for (auto\u0026 c : phoneMap[digits[i]]) { path += c; dfs(i + 1, digits); path.pop_back(); } } vector\u003cstring\u003e letterCombinations(string digits) { if (0 == digits.size()) return vector\u003cstring\u003e{}; dfs(0, digits); return ans; } }; 时间复杂度：$O(n4^n)$，其中 n 为 digits 的长度。最坏情况下每次需要枚举 4 个字母，递归次数为一个满四叉树的节点个数，那么一共会递归 $O(4^n)$ (等比数列和) ，再算上加入答案时复制 path 需要 $O(n)$ 的时间，所以时间复杂度为 $O(n4^n)$. 空间复杂度：$O(n)$. 返回值的空间不计。 Subset Backtracking 子集型回溯本质上是看对于每个元素是选/不选。\n78. Subsets 题目网址. 对于生成子集有两种思路，关键是在于当前操作定义的区别.\n输入角度: 对数组中的每个元素 nums[i]，进行二元决策：要么选择该元素加入当前子集 (path) ，要么不选择。每次递归处理一个元素，逐步构建所有可能的子集。这样子问题和下一个子问题与上一题的定义一样。 void dfs(int i, vector\u003cint\u003e\u0026 nums) { if (i == nums.size()) { ans.push_back(path); return; } // don't choose nums[i], continue dfs dfs(i + 1, nums); // choose nuns[i], add to path then dfs, pop when return path.push_back(nums[i]); dfs(i + 1, nums); path.pop_back(); } === Testing dfs (Decision-Based) === Not choosing nums[0] = 1, before dfs: path: [] Not choosing nums[1] = 2, before dfs: path: [] Not choosing nums[2] = 3, before dfs: path: [] Reached end, adding path: [] Choosing nums[2] = 3, before dfs: path: [3] Reached end, adding path: [3] Choosing nums[1] = 2, before dfs: path: [2] Not choosing nums[2] = 3, before dfs: path: [2] Reached end, adding path: [2] Choosing nums[2] = 3, before dfs: path: [2, 3] Reached end, adding path: [2, 3] Choosing nums[0] = 1, before dfs: path: [1] Not choosing nums[1] = 2, before dfs: path: [1] Not choosing nums[2] = 3, before dfs: path: [1] Reached end, adding path: [1] Choosing nums[2] = 3, before dfs: path: [1, 3] Reached end, adding path: [1, 3] Choosing nums[1] = 2, before dfs: path: [1, 2] Not choosing nums[2] = 3, before dfs: path: [1, 2] Reached end, adding path: [1, 2] Choosing nums[2] = 3, before dfs: path: [1, 2, 3] Reached end, adding path: [1, 2, 3] Result: [[], [3], [2], [2, 3], [1], [1, 3], [1, 2], [1, 2, 3]] 答案视角: 从索引 i 开始，枚举后续所有可能的元素加入子集。每次递归时，将当前路径 path 作为子集加入结果集，然后尝试添加后续元素。为了避免重复子集的出现，需要枚举的下标 j \u003e= i 的数。子问题变为下标 \u003e= i 的数中构造子集。下一个子问题为从下标 \u003e= j+1 的数中构造子集。由于子集的长度没有限制，因此递归到的每个节点都是答案。从 dsf(i) 枚举 dfs(i+1), dfs(i+2), … , dfs(n). void dfs2(int i, vector\u003cint\u003e\u0026 nums) { ans.push_back(path); for (int j = i; j \u003c nums.size(); j++) { path.push_back(nums[j]); dfs2(j + 1, nums); path.pop_back(); } return; } === Testing dfs2 (Enumeration-Based) === Adding path: [] Choosing nums[0] = 1, before dfs2: path: [1] Adding path: [1] Choosing nums[1] = 2, before dfs2: path: [1, 2] Adding path: [1, 2] Choosing nums[2] = 3, before dfs2: path: [1, 2, 3] Adding path: [1, 2, 3] Choosing nums[2] = 3, before dfs2: path: [1, 3] Adding path: [1, 3] Choosing nums[1] = 2, before dfs2: path: [2] Adding path: [2] Choosing nums[2] = 3, before dfs2: path: [2, 3] Adding path: [2, 3] Choosing nums[2] = 3, before dfs2: path: [3] Adding path: [3] Result: [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]] 131. Palindrome Partitioning 题目网址.\n输入视角: 对于每个索引 i，决定是否在 i 和 i+1 之间插入分割点 (即是否将 s[last:i+1) 作为一个回文子串). void dfs(int i, int last, string s) { // whether choose ',' between i and i+1 if (i == s.size()) { ans.push_back(path); return; } if (i \u003c s.size() - 1) // must choose ',' when i==n-1 dfs(i + 1, last, s); // not , if (isPalindrome(s.substr(last, i - last + 1))) { path.push_back(s.substr(last, i - last + 1)); dfs(i+1, i+1, s); path.pop_back(); } return; } 若没有 if (i \u003c s.size() - 1) 代码仍会执行“不分割”分支 dfs(i + 1, last, s)，导致触发终止条件，记录当前 path。 但此时，path 不包含最后一个字符。\n答案视角: 枚举从 i 到字符串末尾的所有可能子串，检查是否为回文。如果 s[i:j+1) 是回文串，加入 path，递归处理剩余部分 (dfs2(j + 1, s)) 。 回溯时移除当前子串，继续尝试其他分割点。 void dfs2(int i, string s) { if (i == s.size()) { ans.push_back(path); return; } for (int j = i; j \u003c s.size(); j++) { // enumerate all possible ',' if (isPalindrome(s.substr(i, j - i + 1))) { path.push_back(s.substr(i, j - i + 1)); dfs2(j + 1, s); path.pop_back(); } } return; } Q: 为什么触发终止条件时 path 中的子串都是回文？\nA: 当 i == s.size() 时，说明已经遍历了字符串 s 的所有字符。由于递归过程中只有回文子串才会被加入 path，并且每次分割后 last 会被更新为新的起点，path 中的子串序列覆盖了从字符串开头到结尾的所有字符。\n784. Letter Case Permutation 题目网址. 直接将当前字符加入 path，递归到下一位。只对处理字母的情况下进行恢复。将 path 中对应位置的字符切换大小写 (大写变小写或小写变大写) ，递归到下一位。 移除当前字符恢复 path 进行回溯，以尝试其他组合。\nclass Solution { public: string path; vector\u003cstring\u003e ans; void dfs(int i, string s) { if (i == s.size()) { ans.push_back(path); return; } path += s[i]; dfs(i + 1, s); if (isalpha(s[i])) { path[i] = islower(s[i]) ? toupper(s[i]) : tolower(s[i]); dfs(i + 1, s); } path.pop_back(); return; } vector\u003cstring\u003e letterCasePermutation(string s) { dfs(0, s); return ans; } }; 2397. Maximum Rows Covered by Columns 题目网址. 思路很简单，选/不选每一列，判断能覆盖多少行，这里用位运算进行优化。\nrowMasks[i]: 第 i 行的 1 位置表示为位掩码，第 j 位为 1 表示 matrix[i][j] == 1. 枚举列组合：使用 mask (0 到 $2^n - 1$) 表示所有可能的列选择组合。__builtin_popcount(mask) 检查 mask 中 1 的个数从而判断是否选中了 numSelect 列。 检查覆盖: 对于每行，若 rowMasks[i] \u0026 mask == rowMasks[i]，说明该行的所有 1 都在选中的列中 (或该行无 1) . class Solution { public: int maximumRows(vector\u003cvector\u003cint\u003e\u003e\u0026 matrix, int numSelect) { int m = matrix.size(), n = matrix[0].size(); vector\u003cint\u003e rowMask(m, 0); // which col is 1 in row[i] for (int i = 0; i \u003c m; ++i) { for (int j = 0; j \u003c n; ++j) { if (matrix[i][j]) { rowMask[i] |= (1 \u003c\u003c j); } } } int maxRows = 0; for (int mask = 0; mask \u003c (1 \u003c\u003c n); mask++) { // col th bit 1/0 indicates select col or not if(__builtin_popcount(mask) != numSelect) continue; int covered = 0; for (int i = 0; i \u003c m; i++) { if ((rowMask[i] \u0026 mask) == rowMask[i]) covered++; } maxRows = max(maxRows, covered); } return maxRows; } }; 2212. Maximum Points in an Archery Competition 题目网址. 递归枚举每个区域是否得分：\n选择不得分: 一箭不射，跳到下一区域。 选择得分：射出 aliceArrows[i] + 1 箭，得 i 分，剩余箭数减少。 注意递归到最后一个区域的时候需要将所有箭射出。 Member Variable Initilization in C++ 不能直接在类定义中使用构造函数初始化语法，如 vector ans(12,0). 它被视为函数声明 (由于c++中最令人烦恼的解析) ，而不是变量初始化。编译器期望参数声明器 (例如，函数参数列表) ，导致期望参数声明器出错。\n在 c++11 之前，成员变量只能在构造函数的初始化列表中或在构造函数体中初始化。 在 c++11 及更高版本中，可以使用大括号初始化 ({}) 或默认成员初始化来使用类内初始化，但不能使用圆括号 () 。例如:\nvector\u003cint\u003e ans = vector\u003cint\u003e(12, 0); // Valid, but verbose vector\u003cint\u003e ans{vector\u003cint\u003e(12, 0)}; // Valid vector\u003cint\u003e ans = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}; // Valid class Solution { public: int maxScores = 0; vector\u003cint\u003e ans; void dfs(int i, int numArrows, vector\u003cint\u003e\u0026 aliceArrows, int score, vector\u003cint\u003e\u0026 bobArrows) { if (i == aliceArrows.size()) { if (score \u003e= maxScores) { maxScores = score; ans = bobArrows; // Update ans with current bobArrows if (numArrows \u003e 0) { ans[11] += numArrows; // Allocate remaining arrows to region 11 } } return; } // Pruning: Check if remaining score potential can beat maxScores int maxPossibleScore = score; for (int j = i; j \u003c aliceArrows.size(); ++j) { maxPossibleScore += j; // Assume all remaining regions are scored } if (maxPossibleScore \u003c maxScores || numArrows \u003c 0) return; // Option 1: Don't score in region i (use 0 arrows) bobArrows[i] = 0; dfs(i + 1, numArrows, aliceArrows, score, bobArrows); // Option 2: Score in region i (use aliceArrows[i] + 1 arrows) if (numArrows \u003e= aliceArrows[i] + 1) { bobArrows[i] = aliceArrows[i] + 1; dfs(i + 1, numArrows - aliceArrows[i] - 1, aliceArrows, score + i, bobArrows); bobArrows[i] = 0; // Backtrack } } vector\u003cint\u003e maximumBobPoints(int numArrows, vector\u003cint\u003e\u0026 aliceArrows) { vector\u003cint\u003e bobArrows(12, 0); // Initialize bobArrows with size 12 ans.resize(12, 0); // Initialize ans with size 12 dfs(0, numArrows, aliceArrows, 0, bobArrows); return ans; } }; 2698. Find the Punishment Number of an Integer 题目网址.\n终止条件: index 到达了字符串 s 的末尾，说明整个字符串已经被成功分割。此时，检查 sum 是否等于目标 i. 选/不选回溯: 对于每个位置我们可以选择分割或者不分割。要注意递归到最后一个数字的时候必须进行分割。 class Solution { public: int ans = 0; bool dfs(int i, string s, int start, int sum, int target) { if (i == s.size()) { return sum == target; } if (i \u003c s.size() - 1) // must select last if (dfs(i + 1, s, start, sum, target)) return true; string subs = s.substr(start, i - start + 1); if (dfs(i + 1, s, i + 1, sum + stoll(subs), target)) return true; return false; } int punishmentNumber(int n) { for (int i = 0; i \u003c= n; i++) if (dfs(0, to_string(i*i), 0, 0, i)) ans += i * i; return ans; } }; Combination Backtracking 回顾子集问题的搜索树，我们可以发现每一层节点的数字个数是相同的，它们恰好可以表示从 n 个数中选择 1, 2, …, n 个数的情况。从 n 个数中选 k 个数的组合可以看作是长度固定的子集。因此如果是找 k 个数的组合，我们可以提前返回而不用继续递归。\n77. Combinations 题目网址. 从大到小进行枚举，假设当前路径长度为 m，那么还需要选 d = k - m 个数。如果当前从 i 开始枚举，如果 i \u003c d，最后必然无法选出 k 个数，不需要继续递归，这是一种剪枝技巧。\n这里如果从小到大枚举，判断条件的不等式会稍微复杂一些。\n这里仍然可以采用选或不选 以及 枚举两种思路。\nclass Solution { vector\u003cint\u003e path; vector\u003cvector\u003cint\u003e\u003e ans; void dfs(int i, int k) { int m = path.size(); if (m == k) { ans.push_back(path); return; } if (i \u003c k - m) // not enough num to add return; dfs(i - 1, k); // don't choose i path.push_back(i); dfs(i - 1, k); path.pop_back(); return; } void dfs2(int i, int k) { int m = path.size(); if (m == k) { ans.push_back(path); return; } if (i \u003c k - m) // not enough num to add return; for (int j = i; j \u003e 0; j--) { path.push_back(j); dfs2(j - 1, k); path.pop_back(); } return; } public: vector\u003cvector\u003cint\u003e\u003e combine(int n, int k) { dfs(n, k); // dfs2(n, k); return ans; } }; 回溯的时间复杂度有一个公式: 叶子的个数 x 从根到叶子的路径长度。因此本题的时间复杂度为 $O(C_{n}^{k}k)$ 空间复杂度为 $O(k)$ 需要一个数组来存储组合数路径。\n216. Combination Sum III 题目网址. 这题多了一个选出的数目和为 n 的限制，和上题一样设还需要选 d = k - m 个数，使得它们的和为 t (初始为 n，每选一个数就减少). 这里可以剪枝的情况有\n剩余数字不够，即 i \u003c d. 当前所选数字之和已经大于 n，即 t \u003c 0. 即使剩余数字全部选最大前几个，它们的和也小于 t，即 $i+\\cdots+(i-d+1)=\\frac{(i+i-d+1)\\cdot d}2 \u003c t$. class Solution { vector\u003cint\u003e path; vector\u003cvector\u003cint\u003e\u003e ans; void dfs(int i, int k, int t) { int m = path.size(); if (m == k \u0026\u0026 t == 0) { ans.push_back(path); return; } int d = k - m; // need to choose d nums if (i \u003c d || t \u003c 0 || (i + i - d + 1) * d / 2 \u003c t) // cur sum \u003e n or sum of first d th big nums \u003c t return; dfs(i - 1, k, t); // don't choose i path.push_back(i); dfs(i - 1, k, t - i); path.pop_back(); return; } void dfs2(int i, int k, int t) { int m = path.size(); if (m == k \u0026\u0026 t == 0) { ans.push_back(path); return; } int d = k - m; // need to choose d nums if (i \u003c d || t \u003c 0 || (i + i - d + 1) * d / 2 \u003c t) // cur sum \u003e n or sum of first d th big nums \u003c t return; for (int j = i; j \u003e 0; j--) { path.push_back(j); dfs2(j - 1, k, t - j); path.pop_back(); } return; } public: vector\u003cvector\u003cint\u003e\u003e combinationSum3(int k, int n) { dfs(9, k, n); // dfs2(9, k, n); return ans; } }; 22. Generate Parentheses 题目网址. 对于字符串的每个前缀，左括号的个数都需要大于右括号的个数。这题可以看出从 2n 个位置中选 n 个位置放左括号。对于一个位置要么选择放左括号或者选择放右括号。\nclass Solution { public: string path; vector\u003cstring\u003e ans; void dfs(int left, int diff, int n) { // choose n pos '(' in 2n if (path.size() == 2 * n) { ans.push_back(path); return; } if (diff \u003e 0) { // if num of prefix '(' \u003e num of ')' path += ')'; dfs(left, diff - 1, n); // then can choose ')' path.pop_back(); } if (left \u003c n) { path += '('; dfs(left + 1, diff + 1, n); path.pop_back(); } return; } vector\u003cstring\u003e generateParenthesis(int n) { dfs(0, 0, n); return ans; } }; 39. Combination Sum 题目网址. 这题因为数字可以重复选择，因此进行递归的时候下标要注意。我们先对 candidates 数组进行排序以方便剪枝。\n终止条件: 如果 target == 0，说明当前路径的数字和达到目标值，将 path 加入答案 ans。 剪枝: 如果 i == candidates.size() 或当前递归的最小数字 candidates[i] \u003e target，说明无法继续选择，直接返回。 选/不选方法\n不选当前数字:直接递归调用 dfs(i + 1, candidates, target)，跳到下一个数字。 选择当前数字: 将 candidates[i] 加入 path 后递归调用 dfs(i, candidates, target - candidates[i])，注意这里是 i (而非 i + 1)，因为允许重复选择当前数字。回溯时弹出 path 中最后一个数字，恢复状态。 void dfs(int i, vector\u003cint\u003e\u0026 candidates, int target) { if (target == 0) { ans.push_back(path); return; } if (i == candidates.size() || candidates[i] \u003e target) return; dfs(i + 1, candidates, target); path.push_back(candidates[i]); dfs(i, candidates, target - candidates[i]); // can choose many times path.pop_back(); return; } 枚举下一个方法: 循环从下标 j = i 到 candidates.size() - 1 枚举从当前下标 i 开始的所有可能数字，逐步构建满足 target 的组合。每次循环尝试选择 candidates[j]，并递归到允许重复选择的状态 dfs2(j, ...).\nvoid dfs2(int i, vector\u003cint\u003e\u0026 candidates, int target) { if (target == 0) { ans.push_back(path); return; } if (i == candidates.size() || candidates[i] \u003e target) return; for (int j = i; j \u003c candidates.size(); j++) { path.push_back(candidates[j]); dfs2(j, candidates, target - candidates[j]); path.pop_back(); } return; } 93. Restore IP Addresses 题目网址. 用一个 vector 来存储当前路径上已经分割好的段。如果 s 本身长度 \u003c 4 或 \u003e12 则说明无法分割直接返回。\n首先明确分割的子串是否是一段非法的地址的条件:\n子串长度大于 1 且以 ‘0’ 开头。 将子串转为整数的结果大于 255。 子串长度大于 3. 并且可以发现就算延长子串的长度也不能使其合法。\n终止条件: 当 path 中已经有 4 段时，分割就结束了。此时，还需要检查是否已经用完了整个字符串 ( startIndex == s.length()). 如果同时满足这两个条件，说明找到了一个合法的 IP 地址。我们将 path 中的 4 段用 . 连接起来，存入最终的结果数组 ans 中。无论是否合法都需要返回。 选/不选思路:\n剪枝: 如果当前没分割成四段但是已经用完了数组，或者当前对应分割的子串已经非法就直接返回。 不分割: dfs(i + 1, …). 分割: 当前子串加入 path 后继续递归 dfs(i + 1, i + 1, s) 然后回溯。 bool valid(string s) { if (s.size() \u003e 3) return false; if (s[0] == '0' \u0026\u0026 s.size() \u003e 1) return false; if(stoi(s) \u003e 255) return false; return true; } void dfs(int i, int start, string s) { if (path.size() == 4) { if (start == s.size()) { string ip = path[0] + '.' + path[1] + '.' + path[2] + '.' + path[3]; ans.push_back(ip); } return; } if (i \u003e s.size() - 1) return; string segment = s.substr(start, i - start + 1); if (!valid(segment)) return; dfs(i + 1, start, s); path.push_back(segment); dfs(i + 1, i + 1, s); path.pop_back(); return; } 枚举所有分割点思路:\n从 start 开始，向后遍历，尝试截取长度为 1/2/3 的子串作为下一个 IP 段。 在循环中，需要不断检查当前截取的子串是否合法，不合法就没必要继续深入了。 如果当前子串 segment 合法，就把它加入到 path 中继续递归 dfs2(i + 1, s) 后回溯。 void dfs2(int start, string s) { if (path.size() == 4) { if (start == s.size()) { string ip = path[0] + '.' + path[1] + '.' + path[2] + '.' + path[3]; ans.push_back(ip); } return; } for (int i = start; i \u003c s.size(); i++) { string segment = s.substr(start, i - start + 1); if (!valid(segment)) // no need to insert . break; path.push_back(segment); dfs2(i + 1, s); path.pop_back(); } return; } Permutation Backtracking 46. Permutations 题目网址. 相比于组合来说，排列对顺序是有要求的。当选了一个数之后，用一个集合 s 记录剩余未选数字来告诉下面节点还可以选哪些数字。\n当前操作: 从 s 中枚举 path[i] 中要填入的数字 x. 这样就明确了递归的参数为 i 和 s. 子问题: 构造排列 \u003e= i 的部分，剩余未选数字集合 s. 下一个子问题: 构造排列 \u003e= i + 1 的部分，剩余未选数字集合 s - {x}. 由于 c++ set 删除元素的开销为 $O(\\log n)$，这里更高效的操作方法是用一个数组来标数字是否被选中。\nclass Solution { vector\u003cint\u003e path; vector\u003cvector\u003cint\u003e\u003e ans; void dfs(vector\u003cint\u003e\u0026 nums, vector\u003cbool\u003e\u0026 used) { if (path.size() == nums.size()) { ans.push_back(path); return; } for (int i = 0; i \u003c nums.size(); ++i) { if (!used[i]) { // select unused used[i] = true; // mark as used path.push_back(nums[i]); dfs(nums, used); path.pop_back(); used[i] = false; // recovery } } } public: vector\u003cvector\u003cint\u003e\u003e permute(vector\u003cint\u003e\u0026 nums) { vector\u003cbool\u003e used(nums.size(), false); dfs(nums, used); return ans; } }; 这里的重点是时间复杂度分析。之前说过可以用叶子节点个数 x 根到叶子节点路径长度来进行估算，按照这种方式得出的时间复杂度为 $O(n*n!)$. 更精确的方式是计算节点的个数，这样也就知道了递归的次数。\n最后一层节点个数为 $A_n^n$, 倒数第二层节点个数为 $A_n^{n-1}$…以此类推。根据公式 $A_{n}^{m}=\\frac{n!}{(n-m)!}$，我们有\n$$ \\sum_{k=0}^nA_n^k=\\sum_{k=0}^n\\frac{n!}{(n-k)!}=n!\\sum_{k=0}^n\\frac1{(n-k)!}=n!\\sum_{m=0}^n\\frac1{m!} $$其中 $m = n - k$. 这个和可以表示为\n$$ \\sum_{k=0}^nA_n^k=n!\\left(\\frac1{0!}+\\frac1{1!}+\\frac1{2!}+\\cdots+\\frac1{n!}\\right) $$求和项为 $e^x$ 在 $x=1$ 处的泰勒展开，因此这个和接近于 $n!\\cdot e$，由于节点个数为整数，因此这棵树的节点个数为 $\\lfloor n!\\cdot e \\rfloor$. 再算上把 path 添加进 ans 的时间，总的时间复杂度为 $O(n*n!)$. 空间复杂度为 $O(n)$，使用了额外的数组来记录路径和标记。\n51. N Queens 题目网址. 一个 nxn 的棋盘上要放 n 个皇后并且要求不同行，不同列，不在同一斜线其实就是要求每行每列有且仅有一个皇后。因为如果有一行/列不放皇后，剩下 n-1 行/列就要放 n 个皇后，必然不满足要求。\n用一个 col 数组来记录皇后的位置，col[i] 表示第 i 行的皇后被放置在第几列。那么 col 本身就是一个 0~n-1 的排列。对于右上方的斜线，行号 r + 列号 c 是一个定值；对于左上方的斜线，行号 r - 列号 c 是一个定值。我们可以从第 0 行开始向下枚举，用两个数组分别标记 r+c 和 r-c 是否有出现过。\nclass Solution { public: vector\u003cint\u003e col; vector\u003cvector\u003cstring\u003e\u003e ans; vector\u003cstring\u003e buildBoard(const vector\u003cint\u003e\u0026 queens, int n) { vector\u003cstring\u003e board(n, string(n, '.')); for (int r = 0; r \u003c n; r++) { board[r][queens[r]] = 'Q'; // Place queen in row r, column queens[r] } return board; } void dfs(int r, vector\u003cbool\u003e\u0026 used, vector\u003cbool\u003e diag1, vector\u003cbool\u003e diag2) { int n = used.size(); if (r == n) { ans.push_back(buildBoard(col, n)); return; } for (int c = 0; c \u003c n; c++) { if (!used[c] \u0026\u0026 !diag1[r + c] \u0026\u0026 !diag2[r - c + n - 1]) { used[c] = true; diag1[r + c] = true; diag2[r - c + n - 1] = true; // avoid negative col.push_back(c); dfs(r + 1, used, diag1, diag2); col.pop_back(); diag2[r - c + n - 1] = false; diag1[r + c] = false; used[c] = false; } } } vector\u003cvector\u003cstring\u003e\u003e solveNQueens(int n) { vector\u003cbool\u003e used(n, false); vector\u003cbool\u003e diag1(2*n - 1, false); // right_up vector\u003cbool\u003e diag2(2*n - 1, false); // left_up dfs(0, used, diag1, diag2); return ans; } }; 357. Count Numbers With Unique Digits 题目网址. 使用数学组合和动态规划的思路解决。\n定义 f(k) 为 k 位数字中，各位数都不同的数的个数。\nf(1) = 9 (1-9) f(2) = 9 * 9 (第一位不能是0，第二位不能和第一位相同) f(3) = 9 * 9 * 8 … f(k) = 9 * 9 * 8 * … * (10 - k + 1) 可以看出 k \u003e= 2 时 f(k) $ = 9A_9^{k-1}$. 由于题目要求的是小于 $10^n$ 的所有个数，因此答案为是 1 (数字0) + f(1) + f(2) + … + f(n).\nclass Solution { public: int countNumbersWithUniqueDigits(int n) { if (n == 0) return 1; int ans = 9, cur = 9; for (int i = 0; i \u003c n - 1; i ++) { cur *= 9 - i; ans += cur; } return ans + 1; // add 0 } }; 2850. Minimum Moves to Spread Stones over Grid 题目网址. 这个问题的本质不是模拟每一步移动，而是找到一个最佳的分配方案。\n源头 (Surplus): 某些单元格的石头数量大于 1。这些是“多余”的石头，可以被移走。一个有 k 个石头的单元格可以提供 k - 1 个石头。 目的地 (Deficit): 某些单元格的石头数量为 0。这些是“空缺”的单元格，需要石头。每个这样的单元格需要 1 个石头。 石头数为 1 的单元格是平衡的，我们不需要对它们进行任何操作。 由于石头总数是 9，并且目标是每个格子都有 1 个石头，那么多余石头的总数必然等于空缺格子的总数。 我们可以创建两个列表：\nfrom_list: 存储所有“多余”石头的起始坐标。如果一个单元格 (r, c) 有 k \u003e 1 个石头，我们就把这个坐标重复 k - 1 次加入列表。 to_list: 存储所有“空缺”单元格的坐标。如果 grid[i][j] == 0，我们就把 (i, j) 加入列表。 经过这个操作后，from_list 和 to_list 的大小一定是相等的。将一个石头从 (r1, c1) 移动到 (r2, c2)，最少的移动次数等于它们之间的曼哈顿距离 |r1 - r2| + |c1 - c2|. 现在问题就变成了： 如何将 from_list 中的每一个石头与 to_list 中的每一个空格进行一一配对，使得所有配对的曼哈顿距离之和最小？\n对于 k 个源头和 k 个目的地，寻找最优匹配的组合总数是 k! 极端情况下一个格子有 9 个石头，其他 8 个格子都是 0. 这时 k = 8，总共组合数有 40320 种情况。\nstd::next_permutation 是一个定义在 头文件中的函数。它的核心功能是将一个序列 (如 vector、string 或数组) 就地转换为它的下一个字典序排列。\nclass Solution { public: int minimumMoves(vector\u003cvector\u003cint\u003e\u003e\u0026 grid) { vector\u003cpair\u003cint, int\u003e\u003e from_coords; vector\u003cpair\u003cint, int\u003e\u003e to_coords; for (int i = 0; i \u003c 3; i++) { for (int j = 0; j \u003c 3; j++) { if (grid[i][j] \u003e 1) { for (int k = 0; k \u003c grid[i][j] - 1; k++) { // can supply num - 1 stones. from_coords.push_back({i, j}); } } else if (grid[i][j] == 0) { to_coords.push_back({i, j}); } } } if (to_coords.empty()) return 0; sort(from_coords.begin(), from_coords.end()); int minMove = INT_MAX; do { int curMove = 0; for (int i = 0; i \u003c from_coords.size(); i++) { curMove += abs(from_coords[i].first - to_coords[i].first) + abs(from_coords[i].second - to_coords[i].second); } minMove = min(curMove, minMove); } while(next_permutation(from_coords.begin(), from_coords.end())); return minMove; } }; ",
  "wordCount" : "6638",
  "inLanguage": "en",
  "datePublished": "2025-08-04T09:47:31+08:00",
  "dateModified": "2025-09-19T09:20:48+08:00",
  "author":[{
    "@type": "Person",
    "name": "WITHER"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/blogs/leetcode/06_backtracking/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "WITHER",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="WITHER (Alt + H)">WITHER</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="http://localhost:1313/zh/" title="简体中文"
                            aria-label="简体中文">简体中文</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/" title="🏠 Home">
                    <span>🏠 Home</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/about_me/" title="🙋🏻‍♂️ Me">
                    <span>🙋🏻‍♂️ Me</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/blogs/" title="📚 Blogs">
                    <span>📚 Blogs</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/categories/" title="🧩 Categories">
                    <span>🧩 Categories</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="🔖 Tags">
                    <span>🔖 Tags</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/archives/" title="⏱ Archive">
                    <span>⏱ Archive</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="🔍 Search (Alt &#43; /)" accesskey=/>
                    <span>🔍 Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/friends/" title="🤝 Friends">
                    <span>🤝 Friends</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/blogs/">Blogs</a>&nbsp;»&nbsp;<a href="http://localhost:1313/blogs/leetcode/">Leetcode</a></div>
    <h1 class="post-title entry-hint-parent">
      06 Backtracking
    </h1>
    <div class="post-description">
      Algorithm questions about backtracking.
    </div>
    <div class="post-meta"><span title='2025-08-04 09:47:31 +0800 CST'>Aug-04-2025</span>&nbsp;·&nbsp;14 min&nbsp;·&nbsp;6638 words&nbsp;·&nbsp;WITHER

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">Table of Contents</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#preliminary" aria-label="Preliminary">Preliminary</a><ul>
                            
                    <li>
                        <a href="#17-letter-combinations-of-a-phone-number" aria-label="17. Letter Combinations of a Phone Number">17. Letter Combinations of a Phone Number</a></li></ul>
                    </li>
                    <li>
                        <a href="#subset-backtracking" aria-label="Subset Backtracking">Subset Backtracking</a><ul>
                            
                    <li>
                        <a href="#78-subsets" aria-label="78. Subsets">78. Subsets</a></li>
                    <li>
                        <a href="#131-palindrome-partitioning" aria-label="131. Palindrome Partitioning">131. Palindrome Partitioning</a></li>
                    <li>
                        <a href="#784-letter-case-permutation" aria-label="784. Letter Case Permutation">784. Letter Case Permutation</a></li>
                    <li>
                        <a href="#2397-maximum-rows-covered-by-columns" aria-label="2397. Maximum Rows Covered by Columns">2397. Maximum Rows Covered by Columns</a></li>
                    <li>
                        <a href="#2212-maximum-points-in-an-archery-competition" aria-label="2212. Maximum Points in an Archery Competition">2212. Maximum Points in an Archery Competition</a></li>
                    <li>
                        <a href="#2698-find-the-punishment-number-of-an-integer" aria-label="2698. Find the Punishment Number of an Integer">2698. Find the Punishment Number of an Integer</a></li></ul>
                    </li>
                    <li>
                        <a href="#combination-backtracking" aria-label="Combination Backtracking">Combination Backtracking</a><ul>
                            
                    <li>
                        <a href="#77-combinations" aria-label="77. Combinations">77. Combinations</a></li>
                    <li>
                        <a href="#216-combination-sum-iii" aria-label="216. Combination Sum III">216. Combination Sum III</a></li>
                    <li>
                        <a href="#22-generate-parentheses" aria-label="22. Generate Parentheses">22. Generate Parentheses</a></li>
                    <li>
                        <a href="#39-combination-sum" aria-label="39. Combination Sum">39. Combination Sum</a></li>
                    <li>
                        <a href="#93-restore-ip-addresses" aria-label="93. Restore IP Addresses">93. Restore IP Addresses</a></li></ul>
                    </li>
                    <li>
                        <a href="#permutation-backtracking" aria-label="Permutation Backtracking">Permutation Backtracking</a><ul>
                            
                    <li>
                        <a href="#46-permutations" aria-label="46. Permutations">46. Permutations</a></li>
                    <li>
                        <a href="#51-n-queens" aria-label="51. N Queens">51. N Queens</a></li>
                    <li>
                        <a href="#357-count-numbers-with-unique-digits" aria-label="357. Count Numbers With Unique Digits">357. Count Numbers With Unique Digits</a></li>
                    <li>
                        <a href="#2850-minimum-moves-to-spread-stones-over-grid" aria-label="2850. Minimum Moves to Spread Stones over Grid">2850. Minimum Moves to Spread Stones over Grid</a>
                    </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    
    document.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();
    
        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
        if (elements.length > 0) {
            
            activeElement = elements[0];
            const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
            document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
        }
    
        
        const topLink = document.getElementById('top-link');
        if (topLink) {
            topLink.addEventListener('click', (event) => {
                
                event.preventDefault();
    
                
                window.scrollTo({ top: 0, behavior: 'smooth' });
            });
        }
    }, false);
    
    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);
    
    window.addEventListener('scroll', () => {
        
        const scrollPosition = window.pageYOffset || document.documentElement.scrollTop;
    
        
        if (scrollPosition === 0) {
            return;
        }
    
        
        if (elements && elements.length > 0) {
            
            activeElement = Array.from(elements).find((element) => {
                if ((getOffsetTop(element) - scrollPosition) > 0 && 
                    (getOffsetTop(element) - scrollPosition) < window.innerHeight / 2) {
                    return element;
                }
            }) || activeElement;
    
            elements.forEach(element => {
                const id = encodeURI(element.getAttribute('id')).toLowerCase();
                const tocLink = document.querySelector(`.inner ul li a[href="#${id}"]`);
                if (element === activeElement){
                    tocLink.classList.add('active');
    
                    
                    const tocContainer = document.querySelector('.toc .inner');
                    const linkOffsetTop = tocLink.offsetTop;
                    const containerHeight = tocContainer.clientHeight;
                    const linkHeight = tocLink.clientHeight;
    
                    
                    const scrollPosition = linkOffsetTop - (containerHeight / 2) + (linkHeight / 2);
                    tocContainer.scrollTo({ top: scrollPosition, behavior: 'smooth' });
                } else {
                    tocLink.classList.remove('active');
                }
            });
        }
    }, false);
    
    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);
    
    function checkTocPosition() {
        const width = document.body.scrollWidth;
    
        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }
    
    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
    
</script>

  <div class="post-content"><h1 id="preliminary">Preliminary<a hidden class="anchor" aria-hidden="true" href="#preliminary">#</a></h1>
<ul>
<li><strong>原问题</strong>: 构造长度为 n 的字符串。
-枚举一个字母后</li>
<li><strong>子问题</strong>: 构造长度为 n-1 的字符串。</li>
</ul>
<p>回溯有一个增量构造答案的过程，这个过程通常用递归来实现。跟之前递归一样，只需要考虑边界条件和非边界条件的逻辑。总结成回溯三问:</p>
<ol>
<li>当前操作? 用一个 path 数组记录路径上的字母。当前操作为枚举 <code>path[i]</code> 要填入的字母。
<blockquote>
<p>这里需要注意递归参数中的 i 不是指的第 i 个，而是下标 <code>&gt;= i</code> 的这部分。</p></blockquote>
</li>
<li>子问题? 构造字符串 <code>&gt;= i</code> 的这部分。</li>
<li>下一个子问题? 构造字符串 <code>&gt;= i</code> 的这部分。
整个过程和在一棵树上进行 dfs 是类似的 (dfs(i) &ndash;&gt; dfs(i+1)).</li>
</ol>
<h2 id="17-letter-combinations-of-a-phone-number">17. Letter Combinations of a Phone Number<a hidden class="anchor" aria-hidden="true" href="#17-letter-combinations-of-a-phone-number">#</a></h2>
<p><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">题目网址</a>.</p>
<ul>
<li>边界条件: 枚举完当前路径后把 path 添加进 ans.</li>
<li>递归条件: 遍历当前要枚举的数字所对应的字母，添加进 path 之后进行下一层次递归。结束后恢复现场。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;</span> <span class="n">phoneMap</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span><span class="sc">&#39;2&#39;</span><span class="p">,</span> <span class="s">&#34;abc&#34;</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span><span class="sc">&#39;3&#39;</span><span class="p">,</span> <span class="s">&#34;def&#34;</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span><span class="sc">&#39;4&#39;</span><span class="p">,</span> <span class="s">&#34;ghi&#34;</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span><span class="sc">&#39;5&#39;</span><span class="p">,</span> <span class="s">&#34;jkl&#34;</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span><span class="sc">&#39;6&#39;</span><span class="p">,</span> <span class="s">&#34;mno&#34;</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span><span class="sc">&#39;7&#39;</span><span class="p">,</span> <span class="s">&#34;pqrs&#34;</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span><span class="sc">&#39;8&#39;</span><span class="p">,</span> <span class="s">&#34;tuv&#34;</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span><span class="sc">&#39;9&#39;</span><span class="p">,</span> <span class="s">&#34;wxyz&#34;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">string</span> <span class="n">path</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">string</span> <span class="n">digits</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">digits</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">c</span> <span class="p">:</span> <span class="n">phoneMap</span><span class="p">[</span><span class="n">digits</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">path</span> <span class="o">+=</span> <span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">dfs</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">digits</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">path</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">letterCombinations</span><span class="p">(</span><span class="n">string</span> <span class="n">digits</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">digits</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">{};</span>
</span></span><span class="line"><span class="cl">        <span class="n">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">digits</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><ul>
<li>时间复杂度：$O(n4^n)$，其中 n 为 digits 的长度。最坏情况下每次需要枚举 4 个字母，递归次数为一个满四叉树的节点个数，那么一共会递归 $O(4^n)$ (等比数列和) ，再算上加入答案时复制 path 需要 $O(n)$ 的时间，所以时间复杂度为 $O(n4^n)$.</li>
<li>空间复杂度：$O(n)$. 返回值的空间不计。</li>
</ul>
<h1 id="subset-backtracking">Subset Backtracking<a hidden class="anchor" aria-hidden="true" href="#subset-backtracking">#</a></h1>
<p>子集型回溯本质上是看对于每个元素是<strong>选/不选</strong>。</p>
<h2 id="78-subsets">78. Subsets<a hidden class="anchor" aria-hidden="true" href="#78-subsets">#</a></h2>
<p><a href="https://leetcode.cn/problems/subsets/">题目网址</a>. 对于生成子集有两种思路，关键是在于当前操作定义的区别.</p>
<ul>
<li>输入角度: 对数组中的每个元素 nums[i]，进行二元决策：要么选择该元素加入当前子集 (path) ，要么不选择。每次递归处理一个元素，逐步构建所有可能的子集。这样子问题和下一个子问题与上一题的定义一样。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// don&#39;t choose  nums[i], continue dfs
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">dfs</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nums</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// choose nuns[i], add to path then dfs, pop when return
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">path</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="n">dfs</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nums</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">path</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">===</span> <span class="n">Testing</span> <span class="n">dfs</span> <span class="p">(</span><span class="n">Decision</span><span class="o">-</span><span class="n">Based</span><span class="p">)</span> <span class="o">===</span>
</span></span><span class="line"><span class="cl"><span class="n">Not</span> <span class="n">choosing</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">before</span> <span class="nl">dfs</span><span class="p">:</span> <span class="nl">path</span><span class="p">:</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">  <span class="n">Not</span> <span class="n">choosing</span> <span class="n">nums</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">before</span> <span class="nl">dfs</span><span class="p">:</span> <span class="nl">path</span><span class="p">:</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">    <span class="n">Not</span> <span class="n">choosing</span> <span class="n">nums</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">before</span> <span class="nl">dfs</span><span class="p">:</span> <span class="nl">path</span><span class="p">:</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">      <span class="n">Reached</span> <span class="n">end</span><span class="p">,</span> <span class="n">adding</span> <span class="nl">path</span><span class="p">:</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">    <span class="n">Choosing</span> <span class="n">nums</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">before</span> <span class="nl">dfs</span><span class="p">:</span> <span class="nl">path</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">      <span class="n">Reached</span> <span class="n">end</span><span class="p">,</span> <span class="n">adding</span> <span class="nl">path</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">  <span class="n">Choosing</span> <span class="n">nums</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">before</span> <span class="nl">dfs</span><span class="p">:</span> <span class="nl">path</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">Not</span> <span class="n">choosing</span> <span class="n">nums</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">before</span> <span class="nl">dfs</span><span class="p">:</span> <span class="nl">path</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">      <span class="n">Reached</span> <span class="n">end</span><span class="p">,</span> <span class="n">adding</span> <span class="nl">path</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">Choosing</span> <span class="n">nums</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">before</span> <span class="nl">dfs</span><span class="p">:</span> <span class="nl">path</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">      <span class="n">Reached</span> <span class="n">end</span><span class="p">,</span> <span class="n">adding</span> <span class="nl">path</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">Choosing</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">before</span> <span class="nl">dfs</span><span class="p">:</span> <span class="nl">path</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">  <span class="n">Not</span> <span class="n">choosing</span> <span class="n">nums</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">before</span> <span class="nl">dfs</span><span class="p">:</span> <span class="nl">path</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">Not</span> <span class="n">choosing</span> <span class="n">nums</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">before</span> <span class="nl">dfs</span><span class="p">:</span> <span class="nl">path</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">      <span class="n">Reached</span> <span class="n">end</span><span class="p">,</span> <span class="n">adding</span> <span class="nl">path</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">Choosing</span> <span class="n">nums</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">before</span> <span class="nl">dfs</span><span class="p">:</span> <span class="nl">path</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">      <span class="n">Reached</span> <span class="n">end</span><span class="p">,</span> <span class="n">adding</span> <span class="nl">path</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">  <span class="n">Choosing</span> <span class="n">nums</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">before</span> <span class="nl">dfs</span><span class="p">:</span> <span class="nl">path</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">Not</span> <span class="n">choosing</span> <span class="n">nums</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">before</span> <span class="nl">dfs</span><span class="p">:</span> <span class="nl">path</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">      <span class="n">Reached</span> <span class="n">end</span><span class="p">,</span> <span class="n">adding</span> <span class="nl">path</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">Choosing</span> <span class="n">nums</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">before</span> <span class="nl">dfs</span><span class="p">:</span> <span class="nl">path</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">      <span class="n">Reached</span> <span class="n">end</span><span class="p">,</span> <span class="n">adding</span> <span class="nl">path</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nl">Result</span><span class="p">:</span> <span class="na">[[], [3], [2], [2, 3], [1], [1, 3], [1, 2], [1, 2, 3]]</span>
</span></span></code></pre></div><ul>
<li>答案视角: 从索引 i 开始，枚举后续所有可能的元素加入子集。每次递归时，将当前路径 path 作为子集加入结果集，然后尝试添加后续元素。为了避免重复子集的出现，需要枚举的下标 <code>j &gt;= i</code> 的数。子问题变为下标 <code>&gt;= i</code> 的数中构造子集。下一个子问题为从下标 <code>&gt;= j+1</code> 的数中构造子集。由于子集的长度没有限制，因此递归到的每个节点都是答案。从 dsf(i) 枚举 dfs(i+1), dfs(i+2), &hellip; , dfs(n).</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">dfs2</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">path</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="n">dfs2</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nums</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">path</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">===</span> <span class="n">Testing</span> <span class="n">dfs2</span> <span class="p">(</span><span class="n">Enumeration</span><span class="o">-</span><span class="n">Based</span><span class="p">)</span> <span class="o">===</span>
</span></span><span class="line"><span class="cl"><span class="n">Adding</span> <span class="nl">path</span><span class="p">:</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl"><span class="n">Choosing</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">before</span> <span class="nl">dfs2</span><span class="p">:</span> <span class="nl">path</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">  <span class="n">Adding</span> <span class="nl">path</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">  <span class="n">Choosing</span> <span class="n">nums</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">before</span> <span class="nl">dfs2</span><span class="p">:</span> <span class="nl">path</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">Adding</span> <span class="nl">path</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">Choosing</span> <span class="n">nums</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">before</span> <span class="nl">dfs2</span><span class="p">:</span> <span class="nl">path</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">      <span class="n">Adding</span> <span class="nl">path</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">  <span class="n">Choosing</span> <span class="n">nums</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">before</span> <span class="nl">dfs2</span><span class="p">:</span> <span class="nl">path</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">Adding</span> <span class="nl">path</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">Choosing</span> <span class="n">nums</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">before</span> <span class="nl">dfs2</span><span class="p">:</span> <span class="nl">path</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">  <span class="n">Adding</span> <span class="nl">path</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">  <span class="n">Choosing</span> <span class="n">nums</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">before</span> <span class="nl">dfs2</span><span class="p">:</span> <span class="nl">path</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">Adding</span> <span class="nl">path</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">Choosing</span> <span class="n">nums</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">before</span> <span class="nl">dfs2</span><span class="p">:</span> <span class="nl">path</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">  <span class="n">Adding</span> <span class="nl">path</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nl">Result</span><span class="p">:</span> <span class="na">[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]</span>
</span></span></code></pre></div><h2 id="131-palindrome-partitioning">131. Palindrome Partitioning<a hidden class="anchor" aria-hidden="true" href="#131-palindrome-partitioning">#</a></h2>
<p><a href="https://leetcode.cn/problems/palindrome-partitioning/">题目网址</a>.</p>
<ul>
<li>输入视角: 对于每个索引 i，决定是否在 i 和 i+1 之间插入分割点 (即是否将 <code>s[last:i+1)</code> 作为一个回文子串).</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">last</span><span class="p">,</span> <span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// whether choose &#39;,&#39; between i and i+1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1">// must choose &#39;,&#39; when i==n-1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">dfs</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>  <span class="c1">//  not ,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">isPalindrome</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">last</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">last</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">path</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">last</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">last</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">path</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>若没有 <code>if (i &lt; s.size() - 1)</code> 代码仍会执行“不分割”分支 <code>dfs(i + 1, last, s)</code>，导致触发终止条件，记录当前 path。
但此时，path 不包含最后一个字符。</p>
<ul>
<li>答案视角: 枚举从 i 到字符串末尾的所有可能子串，检查是否为回文。如果 <code>s[i:j+1)</code> 是回文串，加入 path，递归处理剩余部分 (dfs2(j + 1, s)) 。
回溯时移除当前子串，继续尝试其他分割点。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">dfs2</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// enumerate all possible &#39;,&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">isPalindrome</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">path</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">            <span class="n">dfs2</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">path</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Q: 为什么触发终止条件时 path 中的子串都是回文？</p>
<p>A: 当 <code>i == s.size()</code> 时，说明已经遍历了字符串 s 的所有字符。由于递归过程中只有回文子串才会被加入 path，并且每次分割后 last 会被更新为新的起点，path 中的子串序列覆盖了从字符串开头到结尾的所有字符。</p>
<h2 id="784-letter-case-permutation">784. Letter Case Permutation<a hidden class="anchor" aria-hidden="true" href="#784-letter-case-permutation">#</a></h2>
<p><a href="https://leetcode.cn/problems/maximum-rows-covered-by-columns/">题目网址</a>. 直接将当前字符加入 path，递归到下一位。只对处理字母的情况下进行恢复。将 path 中对应位置的字符切换大小写 (大写变小写或小写变大写) ，递归到下一位。
移除当前字符恢复 path 进行回溯，以尝试其他组合。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">string</span> <span class="n">path</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">path</span> <span class="o">+=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">dfs</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">isalpha</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">islower</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">?</span> <span class="n">toupper</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">:</span> <span class="n">tolower</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">            <span class="n">dfs</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">path</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">letterCasePermutation</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h2 id="2397-maximum-rows-covered-by-columns">2397. Maximum Rows Covered by Columns<a hidden class="anchor" aria-hidden="true" href="#2397-maximum-rows-covered-by-columns">#</a></h2>
<p><a href="https://leetcode.cn/problems/maximum-rows-covered-by-columns/">题目网址</a>. 思路很简单，选/不选每一列，判断能覆盖多少行，这里用位运算进行优化。</p>
<ul>
<li><code>rowMasks[i]</code>: 第 i 行的 1 位置表示为位掩码，第 j 位为 1 表示 <code>matrix[i][j] == 1</code>.</li>
<li>枚举列组合：使用 mask (0 到 $2^n - 1$) 表示所有可能的列选择组合。<code>__builtin_popcount(mask)</code> 检查 mask 中 1 的个数从而判断是否选中了 numSelect 列。</li>
<li>检查覆盖: 对于每行，若 <code>rowMasks[i] &amp; mask == rowMasks[i]</code>，说明该行的所有 1 都在选中的列中 (或该行无 1) .</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">maximumRows</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">matrix</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numSelect</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">n</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">rowMask</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  <span class="c1">// which col is 1 in row[i]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">rowMask</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">j</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">maxRows</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">mask</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="p">);</span> <span class="n">mask</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// col th bit 1/0 indicates select col or not 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span><span class="p">(</span><span class="n">__builtin_popcount</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="o">!=</span> <span class="n">numSelect</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">covered</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">((</span><span class="n">rowMask</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">==</span> <span class="n">rowMask</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">                    <span class="n">covered</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="n">maxRows</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">maxRows</span><span class="p">,</span> <span class="n">covered</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">maxRows</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h2 id="2212-maximum-points-in-an-archery-competition">2212. Maximum Points in an Archery Competition<a hidden class="anchor" aria-hidden="true" href="#2212-maximum-points-in-an-archery-competition">#</a></h2>
<p><a href="https://leetcode.cn/problems/maximum-points-in-an-archery-competition/">题目网址</a>. 递归枚举每个区域是否得分：</p>
<ul>
<li>选择不得分: 一箭不射，跳到下一区域。</li>
<li>选择得分：射出 <code>aliceArrows[i] + 1</code> 箭，得 i 分，剩余箭数减少。
注意递归到最后一个区域的时候需要将所有箭射出。</li>
</ul>
<details class="custom-details">
    <summary class="custom-summary">Member Variable Initilization in C++</summary>
    <div><p>不能直接在类定义中使用构造函数初始化语法，如 <code>vector&lt;int&gt; ans(12,0)</code>. 它被视为函数声明 (由于c++中最令人烦恼的解析) ，而不是变量初始化。编译器期望参数声明器 (例如，函数参数列表) ，导致期望参数声明器出错。</p>
<p>在 c++11 之前，成员变量只能在构造函数的初始化列表中或在构造函数体中初始化。
在 c++11 及更高版本中，可以使用大括号初始化 ({}) 或默认成员初始化来使用类内初始化，但不能使用圆括号 () 。例如:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// Valid, but verbose
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ans</span><span class="p">{</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">0</span><span class="p">)};</span> <span class="c1">// Valid
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ans</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span> <span class="c1">// Valid
</span></span></span></code></pre></div></div>
</details><br>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">maxScores</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numArrows</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">aliceArrows</span><span class="p">,</span> <span class="kt">int</span> <span class="n">score</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">bobArrows</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">aliceArrows</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">score</span> <span class="o">&gt;=</span> <span class="n">maxScores</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">maxScores</span> <span class="o">=</span> <span class="n">score</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">ans</span> <span class="o">=</span> <span class="n">bobArrows</span><span class="p">;</span> <span class="c1">// Update ans with current bobArrows
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">if</span> <span class="p">(</span><span class="n">numArrows</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">ans</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">+=</span> <span class="n">numArrows</span><span class="p">;</span> <span class="c1">// Allocate remaining arrows to region 11
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// Pruning: Check if remaining score potential can beat maxScores
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">maxPossibleScore</span> <span class="o">=</span> <span class="n">score</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">aliceArrows</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">maxPossibleScore</span> <span class="o">+=</span> <span class="n">j</span><span class="p">;</span> <span class="c1">// Assume all remaining regions are scored
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">maxPossibleScore</span> <span class="o">&lt;</span> <span class="n">maxScores</span> <span class="o">||</span> <span class="n">numArrows</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// Option 1: Don&#39;t score in region i (use 0 arrows)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">bobArrows</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">dfs</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">numArrows</span><span class="p">,</span> <span class="n">aliceArrows</span><span class="p">,</span> <span class="n">score</span><span class="p">,</span> <span class="n">bobArrows</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// Option 2: Score in region i (use aliceArrows[i] + 1 arrows)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">numArrows</span> <span class="o">&gt;=</span> <span class="n">aliceArrows</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">bobArrows</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">aliceArrows</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">dfs</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">numArrows</span> <span class="o">-</span> <span class="n">aliceArrows</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">aliceArrows</span><span class="p">,</span> <span class="n">score</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">bobArrows</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">bobArrows</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Backtrack
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">maximumBobPoints</span><span class="p">(</span><span class="kt">int</span> <span class="n">numArrows</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">aliceArrows</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">bobArrows</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// Initialize bobArrows with size 12
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">ans</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// Initialize ans with size 12
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">numArrows</span><span class="p">,</span> <span class="n">aliceArrows</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bobArrows</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h2 id="2698-find-the-punishment-number-of-an-integer">2698. Find the Punishment Number of an Integer<a hidden class="anchor" aria-hidden="true" href="#2698-find-the-punishment-number-of-an-integer">#</a></h2>
<p><a href="https://leetcode.cn/problems/find-the-punishment-number-of-an-integer/">题目网址</a>.</p>
<ul>
<li>终止条件: index 到达了字符串 s 的末尾，说明整个字符串已经被成功分割。此时，检查 sum 是否等于目标 i.</li>
<li>选/不选回溯: 对于每个位置我们可以选择分割或者不分割。要注意递归到最后一个数字的时候必须进行分割。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">string</span> <span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">           <span class="k">return</span> <span class="n">sum</span> <span class="o">==</span> <span class="n">target</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1">// must select last 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">dfs</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">sum</span><span class="p">,</span> <span class="n">target</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">string</span> <span class="n">subs</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">dfs</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sum</span> <span class="o">+</span> <span class="n">stoll</span><span class="p">(</span><span class="n">subs</span><span class="p">),</span> <span class="n">target</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="nf">punishmentNumber</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">to_string</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">i</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                <span class="n">ans</span> <span class="o">+=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h1 id="combination-backtracking">Combination Backtracking<a hidden class="anchor" aria-hidden="true" href="#combination-backtracking">#</a></h1>
<p>回顾子集问题的搜索树，我们可以发现每一层节点的数字个数是相同的，它们恰好可以表示从 n 个数中选择 1, 2, &hellip;, n 个数的情况。从 n 个数中选 k 个数的<strong>组合</strong>可以看作是<strong>长度固定的子集</strong>。因此如果是找 k 个数的组合，我们可以提前返回而不用继续递归。</p>
<h2 id="77-combinations">77. Combinations<a hidden class="anchor" aria-hidden="true" href="#77-combinations">#</a></h2>
<p><a href="https://leetcode.cn/problems/combinations/">题目网址</a>. 从大到小进行枚举，假设当前路径长度为 m，那么还需要选 d = k - m 个数。如果当前从 i 开始枚举，如果 i &lt; d，最后必然无法选出 k 个数，不需要继续递归，这是一种<strong>剪枝</strong>技巧。</p>
<blockquote>
<p>这里如果从小到大枚举，判断条件的不等式会稍微复杂一些。</p></blockquote>
<p>这里仍然可以采用选或不选 以及 枚举两种思路。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">path</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">path</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span> <span class="o">-</span> <span class="n">m</span><span class="p">)</span>  <span class="c1">// not enough num to add
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">dfs</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>  <span class="c1">// don&#39;t choose i
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        
</span></span><span class="line"><span class="cl">        <span class="n">path</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">dfs</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">path</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">dfs2</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">path</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span> <span class="o">-</span> <span class="n">m</span><span class="p">)</span>  <span class="c1">// not enough num to add
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">path</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">dfs2</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">path</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">combine</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">dfs</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// dfs2(n, k);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>回溯的时间复杂度有一个公式: <strong>叶子的个数 x 从根到叶子的路径长度</strong>。因此本题的时间复杂度为 $O(C_{n}^{k}k)$ 空间复杂度为 $O(k)$ 需要一个数组来存储组合数路径。</p>
<h2 id="216-combination-sum-iii">216. Combination Sum III<a hidden class="anchor" aria-hidden="true" href="#216-combination-sum-iii">#</a></h2>
<p><a href="https://leetcode.cn/problems/combination-sum-iii/">题目网址</a>. 这题多了一个选出的数目和为 n 的限制，和上题一样设还需要选 d = k - m 个数，使得它们的和为 t (初始为 n，每选一个数就减少). 这里可以剪枝的情况有</p>
<ol>
<li>剩余数字不够，即 i &lt; d.</li>
<li>当前所选数字之和已经大于 n，即 t &lt; 0.</li>
<li>即使剩余数字全部选最大前几个，它们的和也小于 t，即 $i+\cdots+(i-d+1)=\frac{(i+i-d+1)\cdot d}2 < t$.</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">path</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">path</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="n">k</span> <span class="o">&amp;&amp;</span> <span class="n">t</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">k</span> <span class="o">-</span> <span class="n">m</span><span class="p">;</span>  <span class="c1">// need to choose d nums
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">d</span> <span class="o">||</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">i</span> <span class="o">-</span> <span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">d</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="n">t</span><span class="p">)</span>   <span class="c1">// cur sum &gt; n or sum of first d th big nums &lt; t
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">dfs</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>  <span class="c1">// don&#39;t choose i
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="n">path</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">dfs</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">t</span> <span class="o">-</span> <span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">path</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">dfs2</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">path</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="n">k</span> <span class="o">&amp;&amp;</span> <span class="n">t</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">k</span> <span class="o">-</span> <span class="n">m</span><span class="p">;</span>  <span class="c1">// need to choose d nums
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">d</span> <span class="o">||</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">i</span> <span class="o">-</span> <span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">d</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="n">t</span><span class="p">)</span>   <span class="c1">// cur sum &gt; n or sum of first d th big nums &lt; t
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">path</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">dfs2</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">t</span> <span class="o">-</span> <span class="n">j</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">path</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">combinationSum3</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">dfs</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// dfs2(9, k, n);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h2 id="22-generate-parentheses">22. Generate Parentheses<a hidden class="anchor" aria-hidden="true" href="#22-generate-parentheses">#</a></h2>
<p><a href="https://leetcode.cn/problems/generate-parentheses/">题目网址</a>. 对于字符串的每个前缀，左括号的个数都需要大于右括号的个数。这题可以看出从 2n 个位置中选 n 个位置放左括号。对于一个位置要么选择放左括号或者选择放右括号。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">string</span> <span class="n">path</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">diff</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// choose n pos &#39;(&#39; in 2n
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">diff</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// if num of prefix &#39;(&#39; &gt; num of &#39;)&#39; 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">path</span> <span class="o">+=</span> <span class="sc">&#39;)&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">dfs</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">diff</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>  <span class="c1">// then can choose &#39;)&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">path</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">path</span> <span class="o">+=</span> <span class="sc">&#39;(&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">dfs</span><span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">diff</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">path</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">generateParenthesis</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h2 id="39-combination-sum">39. Combination Sum<a hidden class="anchor" aria-hidden="true" href="#39-combination-sum">#</a></h2>
<p><a href="https://leetcode.cn/problems/combination-sum/">题目网址</a>. 这题因为数字可以重复选择，因此进行递归的时候下标要注意。我们先对 candidates 数组进行排序以方便剪枝。</p>
<ul>
<li>终止条件: 如果 target == 0，说明当前路径的数字和达到目标值，将 path 加入答案 ans。</li>
<li>剪枝: 如果 <code>i == candidates.size()</code> 或当前递归的最小数字 <code>candidates[i] &gt; target</code>，说明无法继续选择，直接返回。</li>
</ul>
<p>选/不选方法</p>
<ul>
<li>不选当前数字:直接递归调用 <code>dfs(i + 1, candidates, target)</code>，跳到下一个数字。</li>
<li>选择当前数字: 将 <code>candidates[i]</code> 加入 path 后递归调用 <code>dfs(i, candidates, target - candidates[i])</code>，注意这里是 i (而非 i + 1)，因为允许重复选择当前数字。回溯时弹出 path 中最后一个数字，恢复状态。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">candidates</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">candidates</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">||</span> <span class="n">candidates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">dfs</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">candidates</span><span class="p">,</span> <span class="n">target</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">path</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">candidates</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">candidates</span><span class="p">,</span> <span class="n">target</span> <span class="o">-</span> <span class="n">candidates</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>  <span class="c1">// can choose many times
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">path</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>枚举下一个方法: 循环从下标 <code>j = i</code> 到 <code>candidates.size() - 1</code> 枚举从当前下标 i 开始的所有可能数字，逐步构建满足 target 的组合。每次循环尝试选择 candidates[j]，并递归到允许重复选择的状态 <code>dfs2(j, ...)</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">dfs2</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">candidates</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">candidates</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">||</span> <span class="n">candidates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">candidates</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">path</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">candidates</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">            <span class="n">dfs2</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">candidates</span><span class="p">,</span> <span class="n">target</span> <span class="o">-</span> <span class="n">candidates</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">            <span class="n">path</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></div><h2 id="93-restore-ip-addresses">93. Restore IP Addresses<a hidden class="anchor" aria-hidden="true" href="#93-restore-ip-addresses">#</a></h2>
<p><a href="https://leetcode.cn/problems/restore-ip-addresses/">题目网址</a>. 用一个 <code>vector&lt;string&gt;</code> 来存储当前路径上已经分割好的段。如果 s 本身长度 &lt; 4 或 &gt;12 则说明无法分割直接返回。</p>
<p>首先明确分割的子串是否是一段非法的地址的条件:</p>
<ol>
<li>子串长度大于 1 且以 &lsquo;0&rsquo; 开头。</li>
<li>将子串转为整数的结果大于 255。</li>
<li>子串长度大于 3.</li>
</ol>
<p>并且可以发现就算延长子串的长度也不能使其合法。</p>
<ul>
<li>终止条件: 当 path 中已经有 4 段时，分割就结束了。此时，还需要检查是否已经用完了整个字符串 (<code> startIndex == s.length()</code>). 如果同时满足这两个条件，说明找到了一个合法的 IP 地址。我们将 path 中的 4 段用 . 连接起来，存入最终的结果数组 ans 中。无论是否合法都需要返回。</li>
</ul>
<p>选/不选思路:</p>
<ul>
<li>剪枝: 如果当前没分割成四段但是已经用完了数组，或者当前对应分割的子串已经非法就直接返回。</li>
<li>不分割: dfs(i + 1, &hellip;).</li>
<li>分割: 当前子串加入 path 后继续递归 <code>dfs(i + 1, i + 1, s)</code> 然后回溯。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">valid</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;0&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">stoi</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">255</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">==</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">string</span> <span class="n">ip</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="sc">&#39;.&#39;</span> <span class="o">+</span> <span class="n">path</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="sc">&#39;.&#39;</span> <span class="o">+</span> <span class="n">path</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="sc">&#39;.&#39;</span> <span class="o">+</span> <span class="n">path</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">string</span> <span class="n">segment</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">valid</span><span class="p">(</span><span class="n">segment</span><span class="p">))</span> <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">dfs</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">path</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">segment</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">dfs</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">path</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>枚举所有分割点思路:</p>
<ul>
<li>从 start 开始，向后遍历，尝试截取长度为 1/2/3 的子串作为下一个 IP 段。</li>
<li>在循环中，需要不断检查当前截取的子串是否合法，不合法就没必要继续深入了。</li>
<li>如果当前子串 segment 合法，就把它加入到 path 中继续递归 <code>dfs2(i + 1, s)</code> 后回溯。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">dfs2</span><span class="p">(</span><span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">==</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">string</span> <span class="n">ip</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="sc">&#39;.&#39;</span> <span class="o">+</span> <span class="n">path</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="sc">&#39;.&#39;</span> <span class="o">+</span> <span class="n">path</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="sc">&#39;.&#39;</span> <span class="o">+</span> <span class="n">path</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">string</span> <span class="n">segment</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">valid</span><span class="p">(</span><span class="n">segment</span><span class="p">))</span>  <span class="c1">// no need to insert .
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">path</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">segment</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">dfs2</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">path</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h1 id="permutation-backtracking">Permutation Backtracking<a hidden class="anchor" aria-hidden="true" href="#permutation-backtracking">#</a></h1>
<h2 id="46-permutations">46. Permutations<a hidden class="anchor" aria-hidden="true" href="#46-permutations">#</a></h2>
<p><a href="https://leetcode.cn/problems/permutations/">题目网址</a>. 相比于组合来说，排列对顺序是有要求的。当选了一个数之后，用一个集合 s 记录剩余未选数字来告诉下面节点还可以选哪些数字。</p>
<ul>
<li>当前操作: 从 s 中枚举 <code>path[i]</code> 中要填入的数字 x. 这样就明确了递归的参数为 i 和 s.</li>
<li>子问题: 构造排列 &gt;= i 的部分，剩余未选数字集合 s.</li>
<li>下一个子问题: 构造排列 &gt;= i + 1 的部分，剩余未选数字集合 s - {x}.</li>
</ul>
<p>由于 c++ set 删除元素的开销为 $O(\log n)$，这里更高效的操作方法是用一个数组来标数字是否被选中。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">path</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;&amp;</span> <span class="n">used</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">used</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>  <span class="c1">// select unused
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">used</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>  <span class="c1">// mark as used
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">path</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">                <span class="n">dfs</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">used</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">path</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">                <span class="n">used</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>  <span class="c1">// recovery
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">permute</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">used</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="nb">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">dfs</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">used</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>这里的重点是时间复杂度分析。之前说过可以用叶子节点个数 x 根到叶子节点路径长度来进行估算，按照这种方式得出的时间复杂度为 $O(n*n!)$. 更精确的方式是计算节点的个数，这样也就知道了递归的次数。</p>
<p>最后一层节点个数为 $A_n^n$, 倒数第二层节点个数为 $A_n^{n-1}$&hellip;以此类推。根据公式 $A_{n}^{m}=\frac{n!}{(n-m)!}$，我们有</p>
$$
\sum_{k=0}^nA_n^k=\sum_{k=0}^n\frac{n!}{(n-k)!}=n!\sum_{k=0}^n\frac1{(n-k)!}=n!\sum_{m=0}^n\frac1{m!}
$$<p>其中 $m = n - k$. 这个和可以表示为</p>
$$
\sum_{k=0}^nA_n^k=n!\left(\frac1{0!}+\frac1{1!}+\frac1{2!}+\cdots+\frac1{n!}\right)
$$<p>求和项为 $e^x$ 在 $x=1$ 处的泰勒展开，因此这个和接近于 $n!\cdot e$，由于节点个数为整数，因此这棵树的节点个数为 $\lfloor n!\cdot e \rfloor$. 再算上把 path 添加进 ans 的时间，总的时间复杂度为 $O(n*n!)$. 空间复杂度为 $O(n)$，使用了额外的数组来记录路径和标记。</p>
<h2 id="51-n-queens">51. N Queens<a hidden class="anchor" aria-hidden="true" href="#51-n-queens">#</a></h2>
<p><a href="https://leetcode.cn/problems/n-queens/">题目网址</a>. 一个 nxn 的棋盘上要放 n 个皇后并且要求不同行，不同列，不在同一斜线其实就是要求每行每列有且仅有一个皇后。因为如果有一行/列不放皇后，剩下 n-1 行/列就要放 n 个皇后，必然不满足要求。</p>
<p>用一个 col 数组来记录皇后的位置，<code>col[i]</code> 表示第 i 行的皇后被放置在第几列。那么 col 本身就是一个 0~n-1 的排列。对于右上方的斜线，行号 r + 列号 c 是一个定值；对于左上方的斜线，行号 r - 列号 c 是一个定值。我们可以从第 0 行开始向下枚举，用两个数组分别标记 r+c 和 r-c 是否有出现过。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">col</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">buildBoard</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">queens</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">board</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">string</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="sc">&#39;.&#39;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">r</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">board</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">queens</span><span class="p">[</span><span class="n">r</span><span class="p">]]</span> <span class="o">=</span> <span class="sc">&#39;Q&#39;</span><span class="p">;</span> <span class="c1">// Place queen in row r, column queens[r]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">board</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;&amp;</span> <span class="n">used</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">diag1</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">diag2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">used</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">buildBoard</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">n</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">c</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">used</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">diag1</span><span class="p">[</span><span class="n">r</span> <span class="o">+</span> <span class="n">c</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">diag2</span><span class="p">[</span><span class="n">r</span> <span class="o">-</span> <span class="n">c</span> <span class="o">+</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">used</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">diag1</span><span class="p">[</span><span class="n">r</span> <span class="o">+</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">diag2</span><span class="p">[</span><span class="n">r</span> <span class="o">-</span> <span class="n">c</span> <span class="o">+</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>  <span class="c1">// avoid negative
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">col</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">dfs</span><span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">used</span><span class="p">,</span> <span class="n">diag1</span><span class="p">,</span> <span class="n">diag2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">col</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">                <span class="n">diag2</span><span class="p">[</span><span class="n">r</span> <span class="o">-</span> <span class="n">c</span> <span class="o">+</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">diag1</span><span class="p">[</span><span class="n">r</span> <span class="o">+</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">used</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">solveNQueens</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">used</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">diag1</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>  <span class="c1">// right_up
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">diag2</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>  <span class="c1">// left_up
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="n">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">used</span><span class="p">,</span> <span class="n">diag1</span><span class="p">,</span> <span class="n">diag2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h2 id="357-count-numbers-with-unique-digits">357. Count Numbers With Unique Digits<a hidden class="anchor" aria-hidden="true" href="#357-count-numbers-with-unique-digits">#</a></h2>
<p><a href="https://leetcode.cn/problems/count-numbers-with-unique-digits">题目网址</a>. 使用数学组合和动态规划的思路解决。</p>
<p>定义 f(k) 为 k 位数字中，各位数都不同的数的个数。</p>
<ul>
<li>f(1) = 9  (1-9)</li>
<li>f(2) = 9 * 9 (第一位不能是0，第二位不能和第一位相同)</li>
<li>f(3) = 9 * 9 * 8</li>
<li>&hellip;</li>
<li>f(k) = 9 * 9 * 8 * &hellip; * (10 - k + 1)</li>
</ul>
<p>可以看出 k &gt;= 2 时 f(k) $ = 9A_9^{k-1}$. 由于题目要求的是小于 $10^n$ 的所有个数，因此答案为是 1 (数字0) + f(1) + f(2) + &hellip; + f(n).</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">countNumbersWithUniqueDigits</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span> <span class="n">cur</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">cur</span> <span class="o">*=</span> <span class="mi">9</span> <span class="o">-</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">ans</span> <span class="o">+=</span> <span class="n">cur</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">ans</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// add 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h2 id="2850-minimum-moves-to-spread-stones-over-grid">2850. Minimum Moves to Spread Stones over Grid<a hidden class="anchor" aria-hidden="true" href="#2850-minimum-moves-to-spread-stones-over-grid">#</a></h2>
<p><a href="https://leetcode.cn/problems/minimum-moves-to-spread-stones-over-grid">题目网址</a>. 这个问题的本质不是模拟每一步移动，而是找到一个最佳的分配方案。</p>
<ul>
<li>源头 (Surplus): 某些单元格的石头数量大于 1。这些是“多余”的石头，可以被移走。一个有 k 个石头的单元格可以提供 k - 1 个石头。</li>
<li>目的地 (Deficit): 某些单元格的石头数量为 0。这些是“空缺”的单元格，需要石头。每个这样的单元格需要 1 个石头。</li>
<li>石头数为 1 的单元格是平衡的，我们不需要对它们进行任何操作。</li>
</ul>
<p>由于石头总数是 9，并且目标是每个格子都有 1 个石头，那么<strong>多余石头的总数必然等于空缺格子的总数</strong>。
我们可以创建两个列表：</p>
<ul>
<li><code>from_list</code>: 存储所有“多余”石头的起始坐标。如果一个单元格 <code>(r, c)</code> 有 k &gt; 1 个石头，我们就把这个坐标重复 k - 1 次加入列表。</li>
<li><code>to_list</code>: 存储所有“空缺”单元格的坐标。如果 <code>grid[i][j] == 0</code>，我们就把 <code>(i, j)</code> 加入列表。</li>
</ul>
<p>经过这个操作后，<code>from_list</code> 和 <code>to_list</code> 的大小一定是相等的。将一个石头从 (r1, c1) 移动到 (r2, c2)，最少的移动次数等于它们之间的曼哈顿距离 |r1 - r2| + |c1 - c2|. 现在问题就变成了：
如何将 from_list 中的每一个石头与 to_list 中的每一个空格进行一一配对，使得所有配对的曼哈顿距离之和最小？</p>
<p>对于 k 个源头和 k 个目的地，寻找最优匹配的组合总数是 k! 极端情况下一个格子有 9 个石头，其他 8 个格子都是 0. 这时 k = 8，总共组合数有 40320 种情况。</p>
<blockquote>
<p><code>std::next_permutation</code> 是一个定义在 <code>&lt;algorithm&gt;</code> 头文件中的函数。它的核心功能是将一个序列 (如 vector、string 或数组) 就地转换为它的下一个字典序排列。</p></blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">minimumMoves</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">grid</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">from_coords</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">to_coords</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// can supply num - 1 stones.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="n">from_coords</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">});</span>
</span></span><span class="line"><span class="cl">                    <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">to_coords</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">});</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">to_coords</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="n">sort</span><span class="p">(</span><span class="n">from_coords</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">from_coords</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">minMove</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">curMove</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">from_coords</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">curMove</span> <span class="o">+=</span> <span class="n">abs</span><span class="p">(</span><span class="n">from_coords</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">first</span> <span class="o">-</span> <span class="n">to_coords</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">first</span><span class="p">)</span> <span class="o">+</span> 
</span></span><span class="line"><span class="cl">                        <span class="n">abs</span><span class="p">(</span><span class="n">from_coords</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">second</span> <span class="o">-</span> <span class="n">to_coords</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">second</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="n">minMove</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">curMove</span><span class="p">,</span> <span class="n">minMove</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="n">next_permutation</span><span class="p">(</span><span class="n">from_coords</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">from_coords</span><span class="p">.</span><span class="n">end</span><span class="p">()));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">minMove</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/backtracking/">Backtracking</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/blogs/leetcode/07_dynamicprogramming/">
    <span class="title">« Prev</span>
    <br>
    <span>07 DynamicProgramming</span>
  </a>
  <a class="next" href="http://localhost:1313/blogs/leetcode/05_binarytree/">
    <span class="title">Next »</span>
    <br>
    <span>05 Binary Tree</span>
  </a>
</nav>

  </footer><script src="https://giscus.app/client.js"
        data-repo="jamesnulliu/jamesnulliu.github.io"
        data-repo-id="R_kgDOMPCQIw"
        data-category="Announcements"
        data-category-id="DIC_kwDOMPCQI84Cgb2t"
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="bottom"
        data-theme="preferred_color_scheme"
        data-lang="en"
        crossorigin="anonymous"
        async>
</script>
</article>
    </main>
    
<footer class="footer">
        <span>© 2024-2025 WITHER</span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
