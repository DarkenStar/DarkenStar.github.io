<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Hot100 | WITHER</title>
<meta name="keywords" content="word 1, word 2">
<meta name="description" content="Hash
1
由于题目规定不能用重复元素，因此要先判断哈希表中是否已经有 target - nums[i] 再将 nums[i] 加入到哈希表 (否则 2*nums[i] = target 情况就会加入重复元素)
class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
        vector&lt;int&gt; ans;
        unordered_map&lt;int, int&gt; map;
        for (int i = 0; i &lt; nums.size(); i&#43;&#43;) {
            if (map.find(target - nums[i]) != map.end()) {
                ans = {i, map[target - nums[i]]};
                break;
            }
            map[nums[i]] = i;
        }
        return ans;
    }
};
49

字母异位词是通过重新排列不同单词或短语的字母而形成的单词或短语，并使用所有原字母一次。">
<meta name="author" content="WITHER">
<link rel="canonical" href="http://localhost:1313/blogs/leetcode/hot100/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.dd3b5b907a50db3238b81d49d094cf1c04a091227797dc9cfde4e2fa3f35df49.css" integrity="sha256-3TtbkHpQ2zI4uB1J0JTPHASgkSJ3l9yc/eTi&#43;j8130k=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/blogs/leetcode/hot100/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<script>
  MathJax = {
    tex: {
      displayMath: [['\\[', '\\]'], ['$$', '$$']],  
      inlineMath: [['\\(', '\\)'], ['$', '$']]  
    }
  };
</script>




<script src="https://cdn.bootcdn.net/ajax/libs/mermaid/9.1.6/mermaid.min.js"></script>
<script>
    mermaid.initialize({
        startOnLoad: true,
        theme: localStorage.getItem("pref-theme") === "dark" ? "dark" : "forest" 
    });
</script>

<meta property="og:url" content="http://localhost:1313/blogs/leetcode/hot100/">
  <meta property="og:site_name" content="WITHER">
  <meta property="og:title" content="Hot100">
  <meta property="og:description" content="Hash 1 由于题目规定不能用重复元素，因此要先判断哈希表中是否已经有 target - nums[i] 再将 nums[i] 加入到哈希表 (否则 2*nums[i] = target 情况就会加入重复元素)
class Solution { public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { vector&lt;int&gt; ans; unordered_map&lt;int, int&gt; map; for (int i = 0; i &lt; nums.size(); i&#43;&#43;) { if (map.find(target - nums[i]) != map.end()) { ans = {i, map[target - nums[i]]}; break; } map[nums[i]] = i; } return ans; } }; 49 字母异位词是通过重新排列不同单词或短语的字母而形成的单词或短语，并使用所有原字母一次。">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="blogs">
    <meta property="article:published_time" content="2025-08-23T13:46:45+08:00">
    <meta property="article:modified_time" content="2025-09-19T09:39:16+08:00">
    <meta property="article:tag" content="Tag 1">
    <meta property="article:tag" content="Tag 2">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hot100">
<meta name="twitter:description" content="Hash
1
由于题目规定不能用重复元素，因此要先判断哈希表中是否已经有 target - nums[i] 再将 nums[i] 加入到哈希表 (否则 2*nums[i] = target 情况就会加入重复元素)
class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
        vector&lt;int&gt; ans;
        unordered_map&lt;int, int&gt; map;
        for (int i = 0; i &lt; nums.size(); i&#43;&#43;) {
            if (map.find(target - nums[i]) != map.end()) {
                ans = {i, map[target - nums[i]]};
                break;
            }
            map[nums[i]] = i;
        }
        return ans;
    }
};
49

字母异位词是通过重新排列不同单词或短语的字母而形成的单词或短语，并使用所有原字母一次。">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Blogs",
      "item": "http://localhost:1313/blogs/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Leetcode",
      "item": "http://localhost:1313/blogs/leetcode/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Hot100",
      "item": "http://localhost:1313/blogs/leetcode/hot100/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Hot100",
  "name": "Hot100",
  "description": "Hash 1 由于题目规定不能用重复元素，因此要先判断哈希表中是否已经有 target - nums[i] 再将 nums[i] 加入到哈希表 (否则 2*nums[i] = target 情况就会加入重复元素)\nclass Solution { public: vector\u0026lt;int\u0026gt; twoSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { vector\u0026lt;int\u0026gt; ans; unordered_map\u0026lt;int, int\u0026gt; map; for (int i = 0; i \u0026lt; nums.size(); i++) { if (map.find(target - nums[i]) != map.end()) { ans = {i, map[target - nums[i]]}; break; } map[nums[i]] = i; } return ans; } }; 49 字母异位词是通过重新排列不同单词或短语的字母而形成的单词或短语，并使用所有原字母一次。\n",
  "keywords": [
    "word 1", "word 2"
  ],
  "articleBody": "Hash 1 由于题目规定不能用重复元素，因此要先判断哈希表中是否已经有 target - nums[i] 再将 nums[i] 加入到哈希表 (否则 2*nums[i] = target 情况就会加入重复元素)\nclass Solution { public: vector\u003cint\u003e twoSum(vector\u003cint\u003e\u0026 nums, int target) { vector\u003cint\u003e ans; unordered_map\u003cint, int\u003e map; for (int i = 0; i \u003c nums.size(); i++) { if (map.find(target - nums[i]) != map.end()) { ans = {i, map[target - nums[i]]}; break; } map[nums[i]] = i; } return ans; } }; 49 字母异位词是通过重新排列不同单词或短语的字母而形成的单词或短语，并使用所有原字母一次。\n这提示我们如果两个单词按字母表顺序排序后相等，那么就是字母异位词。可以用一个哈希表来存储排序后相等的字符串。\nclass Solution { public: vector\u003cvector\u003cstring\u003e\u003e groupAnagrams(vector\u003cstring\u003e\u0026 strs) { vector\u003cvector\u003cstring\u003e\u003e ans; unordered_map\u003cstring, vector\u003cstring\u003e\u003e map; for (int i = 0; i \u003c strs.size(); i++) { string s = strs[i]; ranges::sort(s); map[s].push_back(strs[i]); } for (auto [key, value] : map) { ans.push_back(value); } return ans; } }; 128 用一个哈希集合来存储 nums 中的不同元素，这样可以实现平均 $O(1)$ 时间复杂度的查找。遍历集合中的数字 x，如果发现 x-1 也在集合中，则跳过该数字。因为从 x-1 开始查找的连续长度肯定比从 x 开始的长。从每一个可能的起点 (不存在比他小 1 的数字) 查找连续长度并不断更新。\nclass Solution { public: int longestConsecutive(vector\u003cint\u003e\u0026 nums) { int ans = 0; unordered_set\u003cint\u003e s(nums.begin(), nums.end()); for (int num : s) { if (s.contains(num - 1)) { continue; } int x = 1; while (s.contains(num + 1)) { x++; num++; } ans = max(ans, x); if (ans * 2 \u003e= nums.size()) { break; } } return ans; } }; Double-Pointer 283 把 0 视作空位\n慢指针 slow 指向下一个非零元素应该被放置的位置。换句话说，slow 左边的所有元素（不包括slow指向的位置）都是处理好的、不为零的元素。 快指针 fast 开始向右遍历数组，若遇到非零元素则将其和 slow 位置的元素交换，然后，将慢指针 slow 向右移动一位。遇到零则什么都不做继续向前遍历。 这样 [slow, fast - 1] 所形成的区间内均为 0.\nclass Solution { public: void moveZeroes(vector\u003cint\u003e\u0026 nums) { int slow = 0; for (int\u0026 num : nums) { if (num) { swap(num, nums[slow]); slow++; } } } }; 12 给定左右模板的位置 left 和 right。容器能接水的高度取决于较矮的那个。当相向移动指针的时候，宽度变短，想要盛水更多只能寄希望于接水高度增加。因此 left \u003c right 的时候我们移动指向较矮木板的指针。\nclass Solution { public: int maxArea(vector\u003cint\u003e\u0026 height) { int ans = 0; int left = 0, right = height.size() - 1; while (left \u003c right) { int area = min(height[left],height[right]) * (right - left); ans = max(area, ans); height[left] \u003c height[right] ? left++ : right--; } return ans; } }; 15 想找到 a + b + c = 0，如果能确定一个数 a，问题就变成了在数组剩下的部分寻找两个数 b 和 c，使得 b + c = -a. 这就从三数之和问题降维成了我们熟悉的两数之和问题。对整个数组进行排序，然后遍历排序后的数组，对于每个元素 nums[i]，我们将其视为 a，然后在它后面的区间 [i+1, n-1] 内使用双指针法寻找 b 和 c.\n去重注意点\n枚举的端点 nums[i] 和上一个 nums[i-1] 相等时需要调过。 双指针遍历找到一个可行解时，移动 j 和 k 直到他们指向位置的元素和加入答案中的值不相等。 剪枝优化\nnums[i] + nums[i+1] + nums[i + 2] \u003e 0: 说明以 i 及之后为端点的所有三元组之和全都 \u003e 0. 直接退出循环。 nums[i] + nums[n - 2] + nums[n - 1] \u003c 0: 说明 以 i 为端点的所有三元组之和和全都 \u003c 0. 枚举下一个端点。 class Solution { public: vector\u003cvector\u003cint\u003e\u003e threeSum(vector\u003cint\u003e\u0026 nums) { vector\u003cvector\u003cint\u003e\u003e ans; int n = nums.size(); ranges::sort(nums); for (int i = 0; i \u003c n - 2; i++) { if (i \u003e 0 \u0026\u0026 nums[i] == nums[i - 1]) continue; if (nums[i] + nums[i+1] + nums[i + 2] \u003e 0) break; if (nums[i] + nums[n - 2] + nums[n - 1] \u003c 0) continue; int j = i + 1, k = n - 1; while (j \u003c k) { int sum = nums[i] + nums[j] + nums[k]; if (sum \u003c 0) { j++; } else if (sum \u003e 0) { k--; } else { ans.push_back({nums[i], nums[j], nums[k]}); j++; k--; while(j \u003c k \u0026\u0026 nums[j] == nums [j - 1]) j++; while(j \u003c k \u0026\u0026 nums[k] == nums [k + 1]) k--; } } } return ans; } }; 42 同样是接雨水问题，每个柱子能接水的量为左右两侧柱子较矮者减去自己的高度。因此初始化两个指针指向左右端点，从左往右遍历过程中看哪边柱子矮就移动哪边，不断更新左右侧柱子的最大高度。最后左右指针一定会在高度最高的柱子相遇，而这个位置是无法接水的。\nclass Solution { public: int trap(vector\u003cint\u003e\u0026 height) { int ans = 0; int left = 0, right = height.size() - 1; int lMax = 0, rMax = 0; for (int i = 0; i \u003c height.size(); i++) { lMax = max(lMax, height[left]); rMax = max(rMax, height[right]); ans += min(lMax, rMax) - height[i]; lMax \u003c rMax ? left++ : right--; } return ans; } }; Sliding Window 3 我们滑动窗口维护的是一段没有重复字符的子串，需要用一个哈希表来记录子串中字符对应的下标。\n通过从左向右遍历来尝试扩大窗口\n若发现字符已存在，则 left 到 map[s[right]] 的所有字符都需要被删除。窗口左端点变为 map[s[right]] + 1，更新当前的无重复子串长度，以及这个重复字符对应的下标。 否则当前无重复子串长度 + 1，更新答案，将字符及对应下标记录在哈希表中。 class Solution { public: int lengthOfLongestSubstring(string s) { unordered_map\u003cchar, int\u003e map; int ans = 0; int left = 0; int len = 0; for (int right = 0; right \u003c s.size(); right++) { if (map.find(s[right]) != map.end()) { while (left \u003c= map[s[right]]) { map.erase(s[left]); left++; } len = right - left + 1; } else { len++; ans = max(ans, len); } map[s[right]] = right; } return ans; } }; 438 维持一个和 p 字符串长度相等的窗口，在 s 字符串上滑动。我们只需要判断窗口内的字符串是不是 p 的一个异位词。不需要每次都对窗口内的子串进行排序，而是通过字符频率来判断。由于题目说了字符串只包含小写字母，因此可以用长度为 26 的数组来存储频率。\n首先构造第一个窗口，判断是否相同后向后滑动，在每一步循环中更新窗口内字符的频率，然后再次进行比较判断。\nclass Solution { public: vector\u003cint\u003e findAnagrams(string s, string p) { vector\u003cint\u003e ans; int sLen = s.length(), pLen = p.length(); if (sLen \u003c pLen) { return ans; } vector\u003cint\u003e pFreq(26, 0), wFreq(26, 0); // init first window for (int i = 0; i \u003c pLen; i++) { pFreq[p[i] - 'a']++; wFreq[s[i] - 'a']++; } if (pFreq == wFreq) { ans.push_back(0); } for (int right = pLen; right \u003c sLen; right++) { int left = right - pLen + 1; // insert and remove wFreq[s[right] - 'a']++; wFreq[s[left - 1] - 'a']--; if (pFreq == wFreq) { ans.push_back(left); } } return ans; } }; Substr 560 定义 pre[i] 为从 nums[0] 到 nums[i] 的前缀和。那么，从索引 j 到 i (j \u003c= i) 的子数组的和就可以表示为 pre[i] - pre[j-1]. 题目要求我们找到和为 k 的子数组，也就是说，我们需要找到满足 pre[i] - pre[j-1] == k 的 (i, j) 组合的数量。\n将上面的等式变换一下，就得到 pre[j-1] == pre[i] - k. 对于当前的索引 i，我们不再需要向前遍历 j 来检查每一个子数组的和。我们只需要知道，在 0 到 i-1 的范围内，有多少个 j-1 使得 pre[j-1] 的值恰好等于 pre[i] - k.\n我们可以用一个哈希表来存储出现过的前缀和及出现的次数。初始化的时候为 {0, 1} 表示前缀和为 0 的情况出现过 1 次。初始化前缀和 preSum = 0. 遍历数组的时候一边累加前缀和一边查找 preSum - k 出现过的次数。注意要先查找后添加 (2 * preSum = k 情况下就多找了).\nclass Solution { public: int subarraySum(vector\u003cint\u003e\u0026 nums, int k) { unordered_map\u003cint, int\u003e map; map[0] = 1; int ans = 0, preSum = 0; for (int i = 0; i \u003c nums.size(); i++) { preSum += nums[i]; if (map.count(preSum - k)) { ans += map[preSum - k]; } map[preSum]++; } return ans; }· }; 239 维护一个从头到尾单调递减的双端队列。移动窗口 (遍历数组) 的过程中，如果数组元素 \u003e= 队尾元素就一直将队尾元素弹出，直到条件不满足或者队列为空，然后将元素插入队尾。\n同时为了不超出窗口大小，队列中需要记录的是元素的下标，并在每次循环的过程中判断当前元素下标减去队头元素下标是否超出窗口大小。当遍历到的下标 i \u003e= k - 1 时说明窗口形成，将队头元素对应数组中的值加入答案。\nclass Solution { public: vector\u003cint\u003e maxSlidingWindow(vector\u003cint\u003e\u0026 nums, int k) { vector\u003cint\u003e ans; deque\u003cint\u003e dq; for (int i = 0; i \u003c nums.size(); i++) { while (!dq.empty() \u0026\u0026 nums[i] \u003e= nums[dq.back()]) { dq.pop_back(); } dq.push_back(i); if (i - dq.front() + 1 \u003e k) { dq.pop_front(); } if (i \u003e= k - 1) { ans.push_back(nums[dq.front()]); } } return ans; } }; 76 还是滑动窗口的思想，不断枚举子串的右端点，如果当前窗口包含 t，我们就不断移动左端点来缩小窗口，不断更新长度最小的子串直至当前窗口不再包含 t.\n对于如何判断窗口是否包含 t，由于 s 和 t 都只由大小写字母组成，我们可以用一个数组 cnt 来记录窗口中字母小于 t 中出现的次数，并用一个变量 less 来记录当前窗口中有多少字母的次数低于 t 中对应字母的次数。\n遍历过程中将 cnt 对应字母频率 -1 (出现负数也不影响判断)，cnt[s[right]] == 0 时说明 t 中对应字母已经被完全覆盖，less--. 当 less == 0 说明窗口包含 t. 在缩小窗口的过程中还原 cnt 数组，如果 cnt[s[left]] == 0，那么还原后窗口该字母出现的次数又会小于 t 的，less++.\nclass Solution { public: string minWindow(string s, string t) { if (s.length() \u003c t.length()) { return \"\"; } int cnt[128]{}, less = 0; for (char c : t) { if (cnt[c] == 0) { less++; } cnt[c]++; } int left = 0; int ans_left = -1, ans_right = s.length(); for (int right = 0; right \u003c s.length(); right++) { char c = s[right]; cnt[c]--; if (cnt[c] == 0) { less--; } while (less == 0) { if (right - left \u003c ans_right - ans_left) { ans_right = right; ans_left = left; } if (cnt[s[left]] == 0) { less++; } cnt[s[left]]++; left++; } } return ans_left \u003c 0 ? \"\" : s.substr(ans_left, ans_right - ans_left + 1); } }; Array 53 定义 f[i] 为以 nums[i] 为结尾的最大子数组和。f[i] 可以选择和之前的拼在一起 f[i-1] + nums[i] 或者自成一个子数组 nums[i]. 如果之前的最大子数组和 \u003c 0 则拼在一起只会更小，所以我们有\n$$ f[i]=\\begin{cases}nums[i],\u0026i=0\\\\\\max(f[i-1],0)+nums[i],\u0026i\\geq1\\end{cases} $$答案为 f 数组中最大的那一个。\nclass Solution { public: int maxSubArray(vector\u003cint\u003e\u0026 nums) { vector\u003cint\u003e f(nums.size()); f[0] = nums[0]; for (int i = 1; i \u003c nums.size(); i++) { f[i] = max(f[i - 1], 0) + nums[i]; } return ranges::max(f); } }; 观察到我们更新的等式只用到了两个状态，因此可以降低空间复杂度\nclass Solution { public: int maxSubArray(vector\u003cint\u003e\u0026 nums) { int ans = nums[0]; int f = nums[0]; for (int i = 1; i \u003c nums.size(); i++) { f = max(f, 0) + nums[i]; ans = max(ans, f); } return ans; } }; 56 两个区间 [a, b], [c, d] 重合的充要条件为 a \u003c= d \u0026\u0026 c \u003c= b. 先按照区间开始时间排序就保证了 a \u003c= c \u003c= d. 遍历数组的时候若 c \u003c= b 就说明两个区间可以重合，然后更新结束时间为两个区间的较大者。\nclass Solution { public: vector\u003cvector\u003cint\u003e\u003e merge(vector\u003cvector\u003cint\u003e\u003e\u0026 intervals) { ranges::sort(intervals); vector\u003cvector\u003cint\u003e\u003e ans; int begin = intervals[0][0], end = intervals[0][1]; for (auto interval : intervals) { if (interval[0] \u003c= end) { end = max(end, interval[1]); } else{ ans.push_back({begin, end}); begin = interval[0]; end = interval[1]; } } ans.push_back({begin, end}); return ans; } }; 189 设数组大小为 n.\n反转前 n - k 个元素。 反转后 k 个元素。 反转整个数组。 class Solution { public: void rotate(vector\u003cint\u003e\u0026 nums, int k) { int n = nums.size(); k %= n; // 1. 反转前 n - k 个元素 std::reverse(nums.begin(), nums.begin() + n - k); // 2. 反转后 k 个元素 std::reverse(nums.begin() + n - k, nums.end()); // 3. 反转整个数组 std::reverse(nums.begin(), nums.end()); } }; 238 对于数组中的任意一个位置 i，answer[i] 的值是它左边所有元素的乘积 乘以 右边所有元素的乘积。我们可以分两步来计算：\n计算前缀乘积 (Prefix Products): 创建一个数组（或者直接利用结果数组 answer），answer[i] 存储 nums[0] 到 nums[i-1] 的所有元素的乘积。\n计算后缀乘积 (Suffix Products) 并得出最终结果: 从后向前遍历数组。引入一个变量 suffix_product 来记录右侧所有元素的累积乘积。在遍历到位置 i 时，先将 answer[i]（此时存储的是前缀乘积）乘以 suffix_product，然后更新 suffix_product 为 suffix_product * nums[i]，为下一个位置的计算做准备。\nclass Solution { public: vector\u003cint\u003e productExceptSelf(vector\u003cint\u003e\u0026 nums) { int n = nums.size(); vector\u003cint\u003e suf(n, 1); for (int i = n - 2; i \u003e= 0; i--) { suf[i] = suf[i + 1] * nums[i + 1]; } int pre = nums[0]; for (int i = 1; i \u003c n; i++) { suf[i] *= pre; pre *= nums[i]; } return suf; } }; 41 $O(1)$ 的空间复杂度限制意味着我们不能使用哈希表等额外的数据结构来记录数字的出现情况。必须在输入数组 nums 本身上进行修改和标记，以达到记录信息的目的。\n我们的目标是找到缺失的第一个正整数。假设数组的长度为 n，那么这个缺失的数一定在 [1, n+1] 这个范围内。\n如果 1 到 n 都在数组 nums 中，那么缺失的第一个正整数就是 n+1. 如果 1 到 n 中有任何一个数不在 nums 中，那么缺失的第一个正整数就在 [1, n] 这个区间内。 因此，我们的问题转化为了：检查 1 到 n 这些数字是否在 nums 数组中。\n我们可以利用数组的索引来充当哈希表的键，数组中的元素来充当值，从而建立一种映射关系。具体来说，我们希望数字 k 能够被放到索引为 k-1 的位置上。例如，数字 1 应该被放到索引 0，数字 2 应该被放到索引 1，以此类推。\n第一次遍历数组时，只要 nums[i] 是一个在 [1, n] 范围内的正数，并且它没有被放到正确的位置上 (即 nums[i] != nums[nums[i] - 1])，我们就继续交换。\nnums[i] != nums[nums[i] - 1] 是为了防止当两个相同数字需要交换时陷入死循环。例如 nums = [1, 1], i = 0, nums[0] = 1, 遍历到 nums[1] 时 nums[nums[1]-1] = nums[0] = 1. 说明要进行交换的位置上的值已经是正确的。\n经过上一步的整理，数组 nums 已经尽可能地把数字 k 放在了索引 k-1 的位置 (在答案范围内且没有重复的)。现在我们再遍历一次数组：检查 nums[i] 是否等于 i+1。第一个不满足条件的索引 i，就意味着 i+1 是缺失的第一个正整数。遍历完成都满足说明缺失的第一个正整数为 n+1.\nclass Solution { public: int firstMissingPositive(vector\u003cint\u003e\u0026 nums) { int n = nums.size(); for (int i = 0; i \u003c n; i++) { while (nums[i] \u003e= 1 \u0026\u0026 nums[i] \u003c= n \u0026\u0026 nums[i] != nums[nums[i] - 1]) { swap(nums[i], nums[nums[i] - 1]); } } for (int i = 0; i \u003c n; i++) { if (nums[i] != i + 1) { return i + 1; } } return n + 1; } }; Matrix 73 可以利用矩阵的第一行和第一列来存储哪些行和列需要被置零。\n首先，我们需要两个布尔变量 isFirstRowZero 和 isFirstColZero 来单独记录第一行和第一列是否本身就包含 0. 因为第一行第一列 matrix[0][0] 的状态是共享的，所以需要分开记录。\n用第一行/列做标记：遍历除第一行和第一列之外的矩阵部分，如果 matrix[i][j] == 0，则将对应的第一行 matrix[i][0] 和第一列 matrix[0][j] 的元素置零。\n再次遍历除第一行和第一列之外的矩阵部分。如果 matrix[i][0] == 0 或 matrix[0][j] == 0，说明第 i 行或第 j 列需要被清零，因此将 matrix[i][j] 置为 0.\n最后，根据步骤 1 中记录的 isFirstRowZero 和 isFirstColZero 的值来决定是否将第一行和第一列整体置零。\nclass Solution { public: void setZeroes(std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 matrix) { int m = matrix.size(); if (m == 0) return; int n = matrix[0].size(); bool isFirstColZero = false; bool isFirstRowZero = false; // 1. 检查第一列是否需要置零 for (int i = 0; i \u003c m; ++i) { if (matrix[i][0] == 0) { isFirstColZero = true; break; } } // 2. 检查第一行是否需要置零 for (int j = 0; j \u003c n; ++j) { if (matrix[0][j] == 0) { isFirstRowZero = true; break; } } // 3. 用第一行和第一列记录其他行列的零状态 // 从 (1, 1) 开始遍历 for (int i = 1; i \u003c m; ++i) { for (int j = 1; j \u003c n; ++j) { if (matrix[i][j] == 0) { matrix[i][0] = 0; matrix[0][j] = 0; } } } // 4. 根据第一行和第一列的标记，更新矩阵（不包括第一行第一列） for (int i = 1; i \u003c m; ++i) { for (int j = 1; j \u003c n; ++j) { if (matrix[i][0] == 0 || matrix[0][j] == 0) { matrix[i][j] = 0; } } } // 5. 最后处理第一行和第一列 if (isFirstRowZero) { for (int j = 0; j \u003c n; ++j) { matrix[0][j] = 0; } } if (isFirstColZero) { for (int i = 0; i \u003c m; ++i) { matrix[i][0] = 0; } } } }; 54 维护四个变量，分别代表当前待遍历矩阵的上、下、左、右四个边界。在每一轮循环中，我们沿着这四个边界走一圈 (👉👇👈👆)，然后向内收缩边界，直到边界相遇或交错。\n当螺旋收缩到只剩一行或一列时，上面第 1、2 步执行完后，边界条件可能就不满足了（例如，top \u003e bottom）。因此，在执行第 3、4 步之前，需要再次检查边界条件，防止重复添加元素。\nclass Solution { public: std::vector\u003cint\u003e spiralOrder(std::vector\u003cstd::vector\u003cint\u003e\u003e\u0026 matrix) { int m = matrix.size(); int n = matrix[0].size(); std::vector\u003cint\u003e ans; ans.reserve(m * n); int top = 0, bottom = m - 1, left = 0, right = n - 1; while (left \u003c= right \u0026\u0026 top \u003c= bottom) { // 1. 从左到右遍历上边界 for (int j = left; j \u003c= right; ++j) { ans.push_back(matrix[top][j]); } top++; // 上边界下移 // 2. 从上到下遍历右边界 for (int i = top; i \u003c= bottom; ++i) { ans.push_back(matrix[i][right]); } right--; // 右边界左移 // 检查边界，防止在只剩一行或一列时重复遍历 if (top \u003c= bottom) { // 3. 从右到左遍历下边界 for (int j = right; j \u003e= left; --j) { ans.push_back(matrix[bottom][j]); } bottom--; // 下边界上移 } if (left \u003c= right) { // 4. 从下到上遍历左边界 for (int i = bottom; i \u003e= top; --i) { ans.push_back(matrix[i][left]); } left++; // 左边界右移 } } return ans; } }; 48 位于 i 行 j 列的元素，去到 j 行 n−1−i 列，即 (i,j) -\u003e (j,n−1−i). 因此可以通过先转置再纵向对称翻转实现。\nclass Solution { public: void rotate(vector\u003cvector\u003cint\u003e\u003e\u0026 matrix) { int m = matrix.size(); int n = matrix[0].size(); for (int i = 0; i \u003c m; i++) { for (int j = i + 1; j \u003c n; j++) { swap(matrix[i][j], matrix[j][i]); } } for (int i = 0; i \u003c m; i++) { for (int j = 0; j \u003c n / 2; j++) { swap(matrix[i][j], matrix[i][n - 1 - j]); } } } }; 240 右上角的元素，它是当前行的最大值，同时也是当前列的最小值。每一步都可以排除掉一行或者一列，从而不断缩小搜索范围。从右上角开始搜索:\nmatrix[row][col] \u003e target: 当前元素是其所在列的最小值，如果它都比 target 大，那么这一整列下方的所有元素必定也比 target 大。因此，可以完全排除当前列。向左移动，col--.\nmatrix[row][col] \u003c target: 因为当前元素是其所在行的最大值，如果它都比 target 小，那么这一整行左边的所有元素必定也比 target 小。因此，可以完全排除当前行。向下移动，row++.\n当超出下边界或超出左边界时说明找不到目标值。\nclass Solution { public: bool searchMatrix(vector\u003cvector\u003cint\u003e\u003e\u0026 matrix, int target) { int m = matrix.size(); int n = matrix[0].size(); int row = 0, col = n - 1; while (row \u003c m \u0026\u0026 col \u003e= 0) { if (matrix[row][col] \u003e target) { col--; } else if (matrix[row][col] \u003c target) { row++; } else { return true; } } return false; } }; Linked List 160 使用两个指针 pa 和 pb 分别指向 headA 和 headB. 同时遍历两个链表:\n如果 pa 或 pb 到达链表末尾（nullptr），将其切换到另一个链表的头部继续遍历。这样，两个指针最终会“走过相同的距离”，要么在相交节点相遇，要么都到达 nullptr.\n设链表 A 的长度为 a + c，链表 B 的长度为 b + c，其中 c 是相交部分的长度。指针 pa 遍历 a + c + b 后，指针 pb 遍历 b + c + a 后，它们会在相交节点相遇 (无交点则都到达 nulll ptr).\nclass Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { ListNode*pa = headA, *pb = headB; while (pa != pb) { pa = pa ? pa-\u003enext : headB; pb = pb ? pb-\u003enext : headA; } return pa; } }; 206 从 pre = nullptr 开始，这样可以自然地将原头节点的 next 设置为 nullptr.\nclass Solution { public: ListNode* reverseList(ListNode* head) { ListNode* pre = nullptr, *cur = head; while (cur) { ListNode* n = cur-\u003enext; cur-\u003enext = pre; pre = cur; cur = n; } return pre; } }; 141 慢指针 slow 一次移动一步，快指针 fast 一次移动两步。如果能相遇说明有环，否则快指针会先走到链表末尾 nullptr.\nclass Solution { public: bool hasCycle(ListNode *head) { ListNode* slow = head, *fast = head; while (fast \u0026\u0026 fast-\u003enext) { slow = slow-\u003enext; fast = fast-\u003enext-\u003enext; if (slow == fast) { return true; } } return false; } }; 142 假设进环前的路程为 a，环长为 b。设慢指针走了 x 步时，快慢指针相遇，此时快指针走了 2x 步。显然 2x-x=nb（快指针比慢指针多走了 n 圈），即 x=nb. 也就是说慢指针总共走过的路程是 nb，但这 nb 当中，实际上包含了进环前的一个小 a，因此慢指针在环中只走了 nb-a 步，它还得再往前走 a 步，才是完整的 n 圈。所以，我们让头节点和慢指针同时往前走，当他俩相遇时，就走过了最后这 a 步。\nclass Solution { public: ListNode *detectCycle(ListNode *head) { ListNode* slow = head, *fast = head; while (fast \u0026\u0026 fast-\u003enext) { slow = slow-\u003enext; fast = fast-\u003enext-\u003enext; if (slow == fast) { while (head != slow) { slow = slow-\u003enext; head = head-\u003enext; } return slow; } } return nullptr; } }; 21 创建一个 dummy 节点，作为合并后的新链表头节点的前一个节点。\n比较 list 1 和 list2的节点值，如果 list1 的节点值小，则把 list1 加到新链表的末尾，然后把 list1 替换成它的下一个节点。反之同样。\n直到一个链表为空就把另一个链表直接加到新链表末尾，返回 dummy.next.\nclass Solution { public: ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) { ListNode dummy(0); ListNode* tail = \u0026dummy; while (list1 \u0026\u0026 list2) { if (list1-\u003eval \u003c list2-\u003eval) { tail-\u003enext = list1; list1 = list1-\u003enext; } else { tail-\u003enext = list2; list2 = list2-\u003enext; } tail = tail-\u003enext; } tail-\u003enext = list1 ? list1 : list2; return dummy.next; } }; 2 注意两个链表遍历完后可能还有进位。\nclass Solution { public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { ListNode dummy; ListNode* p = \u0026dummy; int carry = 0; while (l1 \u0026\u0026 l2) { int num = l1-\u003eval + l2-\u003eval + carry; carry = num \u003e= 10 ? 1 : 0; num %= 10; p-\u003enext = new ListNode(num); p = p-\u003enext; l1 = l1-\u003enext; l2 = l2-\u003enext; } while (l1) { int num = l1-\u003eval + carry; carry = num \u003e= 10 ? 1 : 0; num %= 10; p-\u003enext = new ListNode(num); p = p-\u003enext; l1 = l1-\u003enext; } while (l2) { int num = l2-\u003eval + carry; carry = num \u003e= 10 ? 1 : 0; num %= 10; p-\u003enext = new ListNode(num); p = p-\u003enext; l2 = l2-\u003enext; } if (carry) { p-\u003enext = new ListNode(carry); } return dummy.next; } }; 19 为了简化需要删除头节点的逻辑，我们需要添加一个哨兵节点 dummy. 慢指针 slow 在链表 dummy，先移动快指针 slow 到正数第 n 个节点。然后同时移动快慢指针，fast 到达 nullptr 时，左端点就在倒数第 n 个节点。\nclass Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode dummy(0, head); ListNode* slow = \u0026dummy, *fast = head; for (int i = 0; i \u003c n; i++) { fast = fast-\u003enext; } while (fast) { slow = slow-\u003enext; fast= fast-\u003enext; } slow-\u003enext = slow-\u003enext-\u003enext; return dummy.next; } }; 24 用一个指针 pre 指向已经翻转部分的最后一个节点，cur 指向下一个要翻转的节点。当要翻转的一对节点 cur \u0026\u0026 cur-\u003enext 都存在时:\npre-\u003enext = cur-\u003enext cur-\u003enext = cur-\u003enext-\u003enext cur-\u003enext-\u003enext = cur 此时 cur 成为已经翻转部分的最后一个节点，让 pre 指向它，cur 再指向 cur-\u003enext. 由于需要对头节点进行翻转，所以我们初始化哨兵节点来作为一开始已经翻转部分的最后一个节点。\nclass Solution { public: ListNode* swapPairs(ListNode* head) { if (!head || !head-\u003enext) { return head; } ListNode dummy(0, head); ListNode* pre = \u0026dummy, *cur = head; while (cur \u0026\u0026 cur-\u003enext) { ListNode* next = cur-\u003enext; pre-\u003enext = next; cur-\u003enext = next-\u003enext; next-\u003enext = cur; pre = cur; cur = cur-\u003enext; } return dummy.next; } }; 25 通过一次遍历计算出链表总长度，从而确定总共需要反转多少个分组。 pre 指向已经翻转的部分的最后一个节点， 内循环进行每一组的链表反转。反转结束后 cur 指向的是下一组的开始节点。重新链接反转后的子链表。 class Solution { public: ListNode* reverseKGroup(ListNode* head, int k) { int len = 0; ListNode* cur = head; while (cur) { len++; cur = cur-\u003enext; } int ng = len / k; ListNode dummy(0, head); ListNode* pre = \u0026dummy; cur = head; for (int i = 0; i \u003c ng; i++) { ListNode* p = nullptr; for (int j = 0; j \u003c k; j++) { ListNode* next = cur-\u003enext; cur-\u003enext = p; p = cur; cur = next; } pre-\u003enext-\u003enext = cur; ListNode* next_pre = pre-\u003enext; pre-\u003enext = p; pre = next_pre; } return dummy.next; } }; 234 用快慢指针找到链表中间位置 (len / 2) 的节点。 翻转后一半链表。 同时从头尾开始遍历判断值是否相等。 class Solution { ListNode* reverseList(ListNode* head) { ListNode* pre = nullptr, *cur = head; while (cur) { ListNode* n = cur-\u003enext; cur-\u003enext = pre; pre = cur; cur = n; } return pre; } ListNode* middleList(ListNode* head) { ListNode* slow = head, *fast = head; while (fast \u0026\u0026 fast-\u003enext) { slow = slow-\u003enext; fast = fast-\u003enext-\u003enext; } return slow; } public: bool isPalindrome(ListNode* head) { ListNode* mid = middleList(head); ListNode* tail = reverseList(mid); while (head \u0026\u0026 tail) { if (head-\u003eval != tail-\u003eval) { return false; } head = head-\u003enext; tail = tail-\u003enext; } return true; } }; 138 创建交织链表: 遍历原链表，对于每个节点，创建一个新节点（副本），并将其插入到原节点和原节点的下一个节点之间。例如，原链表 A -\u003e B -\u003e C 变成 A -\u003e A' -\u003e B -\u003e B' -\u003e C -\u003e C'.\n设置 random 指针: 对于原链表的每个节点 N，其副本节点 N’ 紧随其后。 如果 N-\u003erandom 指向某个节点 M，则 N'-\u003erandom 应指向 M’ (M 的副本). 由于 M’ 是 M-\u003enext，我们可以直接设置 N-\u003enext-\u003erandom = N-\u003erandom-\u003enext.\n分离新旧链表: 遍历交织链表，将新节点和旧节点分开，恢复原链表并提取新链表。确保正确设置 next 指针，断开新旧节点之间的连接。\nclass Solution { public: Node* copyRandomList(Node* head) { if (!head) return nullptr; Node * cur = head; while (cur) { cur-\u003enext = new Node(cur-\u003eval, cur-\u003enext, nullptr); cur = cur-\u003enext-\u003enext; } cur = head; while (cur) { if (cur-\u003erandom) { cur-\u003enext-\u003erandom = cur-\u003erandom-\u003enext; } cur = cur-\u003enext-\u003enext; } Node *newHead = head-\u003enext; cur = head; while (cur-\u003enext-\u003enext) { Node* copy = cur-\u003enext; cur-\u003enext = copy-\u003enext; copy-\u003enext = cur-\u003enext-\u003enext; cur = cur-\u003enext; } cur-\u003enext = nullptr; return newHead; } }; 148 遍历链表，获取链表长度。 自底向上归并排序: 将链表中的每个节点都看作是一个长度为 1 的、已经排好序的子链表。在内部循环每一轮中找到每一对要合并的子链表 head1 和 head2，然后将它们合并，并链接到上一段合并好的链表的末尾。 第一轮：将相邻的、长度为 1 的子链表两两合并，形成多个长度为 2 的有序子链表。 第二轮：将相邻的、长度为 2 的子链表两两合并，形成多个长度为 4 的有序子链表。 第三轮：将相邻的、长度为 4 的子链表两两合并，形成多个长度为 8 的有序子链表。 每次从 dummy 节点开始重复这个过程，归并后将子链表的长度 subLen 翻倍 (1, 2, 4, 8, …)，直到 subLen \u003e= 整个链表的长度。 class Solution { ListNode* merge(ListNode* head1, ListNode* head2) { ListNode dummy(0); ListNode* tail = \u0026dummy; while (head1 \u0026\u0026 head2) { if (head1-\u003eval \u003c head2-\u003eval) { tail-\u003enext = head1; head1 = head1-\u003enext; } else { tail-\u003enext = head2; head2 = head2-\u003enext; } tail = tail-\u003enext; } tail-\u003enext = head1 ? head1 : head2; return dummy.next; } public: ListNode* sortList(ListNode* head) { int len = 0; ListNode* p = head; while (p) { len++; p = p-\u003enext; } ListNode dummy(0, head); for (int subLen = 1; subLen \u003c len; subLen*= 2) { ListNode* pre = \u0026dummy; // pre records the tail of last merged 2 segments ListNode* cur = dummy.next; // cur records the start node to merge while (cur) { // find first segment chainList with subLen ListNode* head1 = cur; for (int i = 1; i \u003c subLen \u0026\u0026 cur \u0026\u0026 cur-\u003enext; i++) { cur = cur-\u003enext; } // find second segment chianList and cut the connection with first segement ListNode* head2 = nullptr; if (cur) { head2 = cur-\u003enext; cur-\u003enext = nullptr; } // find the tail of second segment cur = head2; for (int i = 1; i \u003c subLen \u0026\u0026 cur \u0026\u0026 cur-\u003enext; i++) { cur = cur-\u003enext; } // record the next round start node to merge and cut the connection with second segement ListNode* nextSub = nullptr; if (cur) { nextSub = cur-\u003enext; cur-\u003enext = nullptr; } ListNode* merged = merge(head1, head2); pre-\u003enext = merged; // move pre to the end of merged segment while (pre-\u003enext) { pre = pre-\u003enext; } cur = nextSub; } } return dummy.next; } }; 23 直接自底向上合并链表：\n两两合并：把 lists[0] 和 lists[1] 合并，合并后的链表保存在 lists[0] 中；把 lists[2] 和 lists[3] 合并，合并后的链表保存在 lists[2] 中；依此类推。 四四合并：把 lists[0] 和 lists[2] 合并（相当于合并前四条链表），合并后的链表保存在 lists[0] 中；把 lists[4] 和 lists[6] 合并，合并后的链表保存在 lists[4] 中；依此类推。 八八合并：把 lists[0] 和 lists[4] 合并（相当于合并前八条链表），合并后的链表保存在 lists[0] 中；把 lists[8] 和 lists[12] 合并，合并后的链表保存在 lists[8] 中；依此类推。 依此类推，直到所有链表都合并到 lists[0] 中。最后返回 lists[0]. class Solution { ListNode* merge(ListNode* head1, ListNode* head2) { ListNode dummy(0); ListNode* tail = \u0026dummy; while (head1 \u0026\u0026 head2) { if (head1-\u003eval \u003c head2-\u003eval) { tail-\u003enext = head1; head1 = head1-\u003enext; } else { tail-\u003enext = head2; head2 = head2-\u003enext; } tail = tail-\u003enext; } tail-\u003enext = head1 ? head1 : head2; return dummy.next; } public: ListNode* mergeKLists(vector\u003cListNode*\u003e\u0026 lists) { if (lists.empty()) return nullptr; if (lists.size() == 1) return lists[0]; for (int step = 1; step \u003c lists.size(); step *= 2) { for (int i = 0; i \u003c lists.size() - step; i += step * 2) { lists[i] = merge(lists[i], lists[i + step]); } } return lists[0]; } }; 146 双向链表 (std::list): 维护数据的使用顺序。\n链表中存储 (key, value) 对。 链表头部 (front)：存放最近访问过的数据。 链表尾部 (back)：存放最久未被访问的数据。 哈希表 (std::unordered_map): 实现 O(1) 的快速查找。通过 key，我们能立刻定位到它在链表中的位置。\nkey：存储缓存项的键。 value：存储一个指向双向链表中对应节点的指针或迭代器。 get(key):\n通过哈希表查找 key. 如果未找到直接返回 -1.如果找到了:\n从哈希表中获取到链表节点的指针/迭代器。 通过指针/迭代器获取节点中的 value. 将这个节点从它当前的位置移动到链表的头部（表示它刚刚被访问过）。 返回 value. put(key, value) 操作: 通过哈希表查找 key.\n如果找到了 (key 已存在)：\n从哈希表中获取到链表节点的指针/迭代器。 更新该节点中的 value. 将这个节点移动到链表的头部。 如果未找到 (key 是新的)：\n检查缓存是否已满，如果已满: 获取链表尾部的节点。 从哈希表中删除尾部节点的 key。 从链表中删除该尾部节点。 在链表头部创建一个新节点，存储 (key, value). 在哈希表中插入新的 key，并让其 value 指向刚创建的链表头节点。 ",
  "wordCount" : "8661",
  "inLanguage": "en",
  "datePublished": "2025-08-23T13:46:45+08:00",
  "dateModified": "2025-09-19T09:39:16+08:00",
  "author":[{
    "@type": "Person",
    "name": "WITHER"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/blogs/leetcode/hot100/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "WITHER",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="WITHER (Alt + H)">WITHER</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="http://localhost:1313/zh/" title="简体中文"
                            aria-label="简体中文">简体中文</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/" title="🏠 Home">
                    <span>🏠 Home</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/about_me/" title="🙋🏻‍♂️ Me">
                    <span>🙋🏻‍♂️ Me</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/blogs/" title="📚 Blogs">
                    <span>📚 Blogs</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/categories/" title="🧩 Categories">
                    <span>🧩 Categories</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="🔖 Tags">
                    <span>🔖 Tags</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/archives/" title="⏱ Archive">
                    <span>⏱ Archive</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="🔍 Search (Alt &#43; /)" accesskey=/>
                    <span>🔍 Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/friends/" title="🤝 Friends">
                    <span>🤝 Friends</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/blogs/">Blogs</a>&nbsp;»&nbsp;<a href="http://localhost:1313/blogs/leetcode/">Leetcode</a></div>
    <h1 class="post-title entry-hint-parent">
      Hot100
    </h1>
    <div class="post-meta"><span title='2025-08-23 13:46:45 +0800 CST'>Aug-23-2025</span>&nbsp;·&nbsp;18 min&nbsp;·&nbsp;8661 words&nbsp;·&nbsp;WITHER

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">Table of Contents</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#hash" aria-label="Hash">Hash</a><ul>
                            
                    <li>
                        <a href="#1" aria-label="1">1</a></li>
                    <li>
                        <a href="#49" aria-label="49">49</a></li>
                    <li>
                        <a href="#128" aria-label="128">128</a></li></ul>
                    </li>
                    <li>
                        <a href="#double-pointer" aria-label="Double-Pointer">Double-Pointer</a><ul>
                            
                    <li>
                        <a href="#283" aria-label="283">283</a></li>
                    <li>
                        <a href="#12" aria-label="12">12</a></li>
                    <li>
                        <a href="#15" aria-label="15">15</a></li>
                    <li>
                        <a href="#42" aria-label="42">42</a></li></ul>
                    </li>
                    <li>
                        <a href="#sliding-window" aria-label="Sliding Window">Sliding Window</a><ul>
                            
                    <li>
                        <a href="#3" aria-label="3">3</a></li>
                    <li>
                        <a href="#438" aria-label="438">438</a></li></ul>
                    </li>
                    <li>
                        <a href="#substr" aria-label="Substr">Substr</a><ul>
                            
                    <li>
                        <a href="#560" aria-label="560">560</a></li>
                    <li>
                        <a href="#239" aria-label="239">239</a></li>
                    <li>
                        <a href="#76" aria-label="76">76</a></li></ul>
                    </li>
                    <li>
                        <a href="#array" aria-label="Array">Array</a><ul>
                            
                    <li>
                        <a href="#53" aria-label="53">53</a></li>
                    <li>
                        <a href="#56" aria-label="56">56</a></li>
                    <li>
                        <a href="#189" aria-label="189">189</a></li>
                    <li>
                        <a href="#238" aria-label="238">238</a></li>
                    <li>
                        <a href="#41" aria-label="41">41</a></li></ul>
                    </li>
                    <li>
                        <a href="#matrix" aria-label="Matrix">Matrix</a><ul>
                            
                    <li>
                        <a href="#73" aria-label="73">73</a></li>
                    <li>
                        <a href="#54" aria-label="54">54</a></li>
                    <li>
                        <a href="#48" aria-label="48">48</a></li>
                    <li>
                        <a href="#240" aria-label="240">240</a></li></ul>
                    </li>
                    <li>
                        <a href="#linked-list" aria-label="Linked List">Linked List</a><ul>
                            
                    <li>
                        <a href="#160" aria-label="160">160</a></li>
                    <li>
                        <a href="#206" aria-label="206">206</a></li>
                    <li>
                        <a href="#141" aria-label="141">141</a></li>
                    <li>
                        <a href="#142" aria-label="142">142</a></li>
                    <li>
                        <a href="#21" aria-label="21">21</a></li>
                    <li>
                        <a href="#2" aria-label="2">2</a></li>
                    <li>
                        <a href="#19" aria-label="19">19</a></li>
                    <li>
                        <a href="#24" aria-label="24">24</a></li>
                    <li>
                        <a href="#25" aria-label="25">25</a></li>
                    <li>
                        <a href="#234" aria-label="234">234</a></li>
                    <li>
                        <a href="#138" aria-label="138">138</a></li>
                    <li>
                        <a href="#148" aria-label="148">148</a></li>
                    <li>
                        <a href="#23" aria-label="23">23</a></li>
                    <li>
                        <a href="#146" aria-label="146">146</a>
                    </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    
    document.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();
    
        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
        if (elements.length > 0) {
            
            activeElement = elements[0];
            const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
            document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
        }
    
        
        const topLink = document.getElementById('top-link');
        if (topLink) {
            topLink.addEventListener('click', (event) => {
                
                event.preventDefault();
    
                
                window.scrollTo({ top: 0, behavior: 'smooth' });
            });
        }
    }, false);
    
    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);
    
    window.addEventListener('scroll', () => {
        
        const scrollPosition = window.pageYOffset || document.documentElement.scrollTop;
    
        
        if (scrollPosition === 0) {
            return;
        }
    
        
        if (elements && elements.length > 0) {
            
            activeElement = Array.from(elements).find((element) => {
                if ((getOffsetTop(element) - scrollPosition) > 0 && 
                    (getOffsetTop(element) - scrollPosition) < window.innerHeight / 2) {
                    return element;
                }
            }) || activeElement;
    
            elements.forEach(element => {
                const id = encodeURI(element.getAttribute('id')).toLowerCase();
                const tocLink = document.querySelector(`.inner ul li a[href="#${id}"]`);
                if (element === activeElement){
                    tocLink.classList.add('active');
    
                    
                    const tocContainer = document.querySelector('.toc .inner');
                    const linkOffsetTop = tocLink.offsetTop;
                    const containerHeight = tocContainer.clientHeight;
                    const linkHeight = tocLink.clientHeight;
    
                    
                    const scrollPosition = linkOffsetTop - (containerHeight / 2) + (linkHeight / 2);
                    tocContainer.scrollTo({ top: scrollPosition, behavior: 'smooth' });
                } else {
                    tocLink.classList.remove('active');
                }
            });
        }
    }, false);
    
    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);
    
    function checkTocPosition() {
        const width = document.body.scrollWidth;
    
        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }
    
    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
    
</script>

  <div class="post-content"><h1 id="hash">Hash<a hidden class="anchor" aria-hidden="true" href="#hash">#</a></h1>
<h2 id="1">1<a hidden class="anchor" aria-hidden="true" href="#1">#</a></h2>
<p>由于题目规定不能用重复元素，因此要先判断哈希表中是否已经有 <code>target - nums[i]</code> 再将 <code>nums[i]</code> 加入到哈希表 (否则 <code>2*nums[i] = target</code> 情况就会加入重复元素)</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">twoSum</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">map</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">target</span> <span class="o">-</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">!=</span> <span class="n">map</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">ans</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">,</span> <span class="n">map</span><span class="p">[</span><span class="n">target</span> <span class="o">-</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]]};</span>
</span></span><span class="line"><span class="cl">                <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="n">map</span><span class="p">[</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h2 id="49">49<a hidden class="anchor" aria-hidden="true" href="#49">#</a></h2>
<blockquote>
<p>字母异位词是通过重新排列不同单词或短语的字母而形成的单词或短语，并使用所有原字母一次。</p></blockquote>
<p>这提示我们如果两个单词按字母表顺序排序后相等，那么就是字母异位词。可以用一个哈希表来存储排序后相等的字符串。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">groupAnagrams</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">strs</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">map</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">strs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="n">strs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="n">ranges</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">map</span><span class="p">[</span><span class="n">s</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">strs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="p">[</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">]</span> <span class="o">:</span> <span class="n">map</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h2 id="128">128<a hidden class="anchor" aria-hidden="true" href="#128">#</a></h2>
<p>用一个哈希集合来存储 <code>nums</code> 中的不同元素，这样可以实现平均 $O(1)$ 时间复杂度的查找。<strong>遍历集合中的数字</strong> x，如果发现 x-1 也在集合中，则跳过该数字。因为从 x-1 开始查找的连续长度肯定比从 x 开始的长。从每一个可能的起点 (不存在比他小 1 的数字) 查找连续长度并不断更新。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">longestConsecutive</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">nums</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">num</span> <span class="p">:</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="n">num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">while</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="n">num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">x</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">num</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="n">ans</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">ans</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">&gt;=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h1 id="double-pointer">Double-Pointer<a hidden class="anchor" aria-hidden="true" href="#double-pointer">#</a></h1>
<h2 id="283">283<a hidden class="anchor" aria-hidden="true" href="#283">#</a></h2>
<p>把 0 视作空位</p>
<ul>
<li>慢指针 slow 指向下一个非零元素应该被放置的位置。换句话说，slow 左边的所有元素（不包括slow指向的位置）都是处理好的、不为零的元素。</li>
<li>快指针 fast 开始向右遍历数组，若遇到非零元素则将其和 slow 位置的元素交换，然后，将慢指针 slow 向右移动一位。遇到零则什么都不做继续向前遍历。</li>
</ul>
<p>这样 <code>[slow, fast - 1]</code> 所形成的区间内均为 0.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">moveZeroes</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">slow</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="nl">num</span> <span class="p">:</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">swap</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">nums</span><span class="p">[</span><span class="n">slow</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">                <span class="n">slow</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h2 id="12">12<a hidden class="anchor" aria-hidden="true" href="#12">#</a></h2>
<p>给定左右模板的位置 left 和 right。容器能接水的高度取决于较矮的那个。当相向移动指针的时候，宽度变短，想要盛水更多只能寄希望于接水高度增加。因此 <code>left &lt; right</code> 的时候我们移动指向较矮木板的指针。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">maxArea</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">height</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">height</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">area</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">height</span><span class="p">[</span><span class="n">left</span><span class="p">],</span><span class="n">height</span><span class="p">[</span><span class="n">right</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">ans</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">area</span><span class="p">,</span> <span class="n">ans</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">height</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">?</span> <span class="n">left</span><span class="o">++</span> <span class="o">:</span> <span class="n">right</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h2 id="15">15<a hidden class="anchor" aria-hidden="true" href="#15">#</a></h2>
<p>想找到 <code>a + b + c = 0</code>，如果能确定一个数 a，问题就变成了在数组剩下的部分寻找两个数 b 和 c，使得 <code>b + c = -a</code>. 这就从三数之和问题降维成了我们熟悉的两数之和问题。对整个数组进行排序，然后遍历排序后的数组，对于每个元素 <code>nums[i]</code>，我们将其视为 a，然后在它后面的区间 <code>[i+1, n-1]</code> 内使用双指针法寻找 b 和 c.</p>
<p>去重注意点</p>
<ol>
<li>枚举的端点 nums[i] 和上一个 nums[i-1] 相等时需要调过。</li>
<li>双指针遍历找到一个可行解时，移动 j 和 k 直到他们指向位置的元素和加入答案中的值不相等。</li>
</ol>
<p>剪枝优化</p>
<ol>
<li><code>nums[i] + nums[i+1] + nums[i + 2] &gt; 0</code>: 说明以 i 及之后为端点的所有三元组之和全都 &gt; 0. 直接退出循环。</li>
<li><code>nums[i] + nums[n - 2] + nums[n - 1] &lt; 0</code>: 说明 以 i 为端点的所有三元组之和和全都 &lt; 0. 枚举下一个端点。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">threeSum</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">ranges</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">nums</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>  <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">                <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">sum</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">j</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">sum</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">k</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="p">]});</span>
</span></span><span class="line"><span class="cl">                    <span class="n">j</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                    <span class="n">k</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                    <span class="k">while</span><span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">k</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span> <span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="n">j</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                    <span class="k">while</span><span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">k</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span> <span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="n">k</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h2 id="42">42<a hidden class="anchor" aria-hidden="true" href="#42">#</a></h2>
<p>同样是接雨水问题，每个柱子能接水的量为左右两侧柱子较矮者减去自己的高度。因此初始化两个指针指向左右端点，从左往右遍历过程中看哪边柱子矮就移动哪边，不断更新左右侧柱子的最大高度。最后左右指针一定会在高度最高的柱子相遇，而这个位置是无法接水的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">trap</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">height</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">height</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">lMax</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rMax</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">lMax</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">lMax</span><span class="p">,</span> <span class="n">height</span><span class="p">[</span><span class="n">left</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">            <span class="n">rMax</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">rMax</span><span class="p">,</span> <span class="n">height</span><span class="p">[</span><span class="n">right</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">            <span class="n">ans</span> <span class="o">+=</span> <span class="n">min</span><span class="p">(</span><span class="n">lMax</span><span class="p">,</span> <span class="n">rMax</span><span class="p">)</span> <span class="o">-</span> <span class="n">height</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="n">lMax</span> <span class="o">&lt;</span> <span class="n">rMax</span> <span class="o">?</span> <span class="n">left</span><span class="o">++</span> <span class="o">:</span> <span class="n">right</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h1 id="sliding-window">Sliding Window<a hidden class="anchor" aria-hidden="true" href="#sliding-window">#</a></h1>
<h2 id="3">3<a hidden class="anchor" aria-hidden="true" href="#3">#</a></h2>
<p>我们滑动窗口维护的是一段没有重复字符的子串，需要用一个哈希表来记录子串中字符对应的下标。</p>
<p>通过从左向右遍历来尝试扩大窗口</p>
<ul>
<li>若发现字符已存在，则 <code>left</code> 到 <code>map[s[right]]</code> 的所有字符都需要被删除。窗口左端点变为 <code>map[s[right]] + 1</code>，更新当前的无重复子串长度，以及这个重复字符对应的下标。</li>
<li>否则当前无重复子串长度 + 1，更新答案，将字符及对应下标记录在哈希表中。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">lengthOfLongestSubstring</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">map</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">right</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">right</span><span class="p">])</span> <span class="o">!=</span> <span class="n">map</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">map</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">right</span><span class="p">]])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">map</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">left</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">                    <span class="n">left</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="n">len</span> <span class="o">=</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">len</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">ans</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="n">map</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">right</span><span class="p">]]</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h2 id="438">438<a hidden class="anchor" aria-hidden="true" href="#438">#</a></h2>
<p>维持一个和 p 字符串长度相等的窗口，在 s 字符串上滑动。我们只需要判断窗口内的字符串是不是 p 的一个异位词。不需要每次都对窗口内的子串进行排序，而是通过字符频率来判断。由于题目说了字符串只包含小写字母，因此可以用长度为 26 的数组来存储频率。</p>
<p>首先构造第一个窗口，判断是否相同后向后滑动，在每一步循环中更新窗口内字符的频率，然后再次进行比较判断。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">findAnagrams</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">,</span> <span class="n">string</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">sLen</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">(),</span> <span class="n">pLen</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">sLen</span> <span class="o">&lt;</span> <span class="n">pLen</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pFreq</span><span class="p">(</span><span class="mi">26</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">wFreq</span><span class="p">(</span><span class="mi">26</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// init first window
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pLen</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">pFreq</span><span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">wFreq</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">pFreq</span> <span class="o">==</span> <span class="n">wFreq</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">pLen</span><span class="p">;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">sLen</span><span class="p">;</span> <span class="n">right</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">right</span> <span class="o">-</span> <span class="n">pLen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// insert and remove
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">wFreq</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">wFreq</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">left</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">pFreq</span> <span class="o">==</span> <span class="n">wFreq</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span> 
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h1 id="substr">Substr<a hidden class="anchor" aria-hidden="true" href="#substr">#</a></h1>
<h2 id="560">560<a hidden class="anchor" aria-hidden="true" href="#560">#</a></h2>
<p>定义 <code>pre[i]</code> 为从 <code>nums[0]</code> 到 <code>nums[i]</code> 的前缀和。那么，从索引 j 到 i (<code>j &lt;= i</code>) 的子数组的和就可以表示为 <code>pre[i] - pre[j-1]</code>. 题目要求我们找到和为 k 的子数组，也就是说，我们需要找到满足 <code>pre[i] - pre[j-1] == k</code> 的 <code>(i, j)</code> 组合的数量。</p>
<p>将上面的等式变换一下，就得到 <code>pre[j-1] == pre[i] - k</code>. 对于当前的索引 i，我们不再需要向前遍历 j 来检查每一个子数组的和。我们只需要知道，在 0 到 i-1 的范围内，有多少个 j-1 使得 <code>pre[j-1]</code> 的值恰好等于 <code>pre[i] - k</code>.</p>
<p>我们可以用一个哈希表来存储出现过的前缀和及出现的次数。初始化的时候为 <code>{0, 1}</code> 表示前缀和为 0 的情况出现过 1 次。初始化前缀和 <code>preSum = 0</code>. 遍历数组的时候一边累加前缀和一边查找 <code>preSum - k</code> 出现过的次数。<strong>注意要先查找后添加</strong> (<code>2 * preSum = k</code> 情况下就多找了).</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">subarraySum</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">map</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">map</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">preSum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">preSum</span> <span class="o">+=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">preSum</span> <span class="o">-</span> <span class="n">k</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">ans</span> <span class="o">+=</span> <span class="n">map</span><span class="p">[</span><span class="n">preSum</span> <span class="o">-</span> <span class="n">k</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="n">map</span><span class="p">[</span><span class="n">preSum</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span><span class="err">·</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h2 id="239">239<a hidden class="anchor" aria-hidden="true" href="#239">#</a></h2>
<p>维护一个从头到尾单调递减的双端队列。移动窗口 (遍历数组) 的过程中，如果数组元素 &gt;= 队尾元素就一直将队尾元素弹出，直到条件不满足或者队列为空，然后将元素插入队尾。</p>
<p>同时为了不超出窗口大小，队列中需要记录的是元素的下标，并在每次循环的过程中判断当前元素下标减去队头元素下标是否超出窗口大小。当遍历到的下标 <code>i &gt;= k - 1</code> 时说明窗口形成，将队头元素对应数组中的值加入答案。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">maxSlidingWindow</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">deque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">dq</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">dq</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">nums</span><span class="p">[</span><span class="n">dq</span><span class="p">.</span><span class="n">back</span><span class="p">()])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">dq</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="n">dq</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">dq</span><span class="p">.</span><span class="n">front</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">dq</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">dq</span><span class="p">.</span><span class="n">front</span><span class="p">()]);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h2 id="76">76<a hidden class="anchor" aria-hidden="true" href="#76">#</a></h2>
<p>还是滑动窗口的思想，不断枚举子串的右端点，如果当前窗口包含 t，我们就不断移动左端点来缩小窗口，不断更新长度最小的子串直至当前窗口不再包含 t.</p>
<p>对于如何判断窗口是否包含 t，由于 s 和 t 都只由大小写字母组成，我们可以用一个数组 cnt 来记录<strong>窗口中字母小于 t 中出现的次数</strong>，并用一个变量 less 来记录当前窗口中有多少字母的次数低于 t 中对应字母的次数。</p>
<p>遍历过程中将 cnt 对应字母频率 -1 (出现负数也不影响判断)，<code>cnt[s[right]] == 0</code> 时说明 t 中对应字母已经被完全覆盖，<code>less--</code>. 当 <code>less == 0</code> 说明窗口包含 t. 在缩小窗口的过程中还原 cnt 数组，如果 cnt[s[left]] == 0，那么还原后窗口该字母出现的次数又会小于 t 的，<code>less++</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">string</span> <span class="n">minWindow</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">,</span> <span class="n">string</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">t</span><span class="p">.</span><span class="n">length</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">cnt</span><span class="p">[</span><span class="mi">128</span><span class="p">]{},</span> <span class="n">less</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">char</span> <span class="nl">c</span> <span class="p">:</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">cnt</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">less</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="n">cnt</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">ans_left</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">ans_right</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="n">right</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">right</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="n">cnt</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">cnt</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">less</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="k">while</span> <span class="p">(</span><span class="n">less</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">ans_right</span> <span class="o">-</span> <span class="n">ans_left</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">ans_right</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                    <span class="n">ans_left</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">cnt</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">left</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">less</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="n">cnt</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">left</span><span class="p">]]</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">left</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">ans_left</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="s">&#34;&#34;</span> <span class="o">:</span> <span class="n">s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">ans_left</span><span class="p">,</span> <span class="n">ans_right</span> <span class="o">-</span> <span class="n">ans_left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h1 id="array">Array<a hidden class="anchor" aria-hidden="true" href="#array">#</a></h1>
<h2 id="53">53<a hidden class="anchor" aria-hidden="true" href="#53">#</a></h2>
<p>定义 <code>f[i]</code> 为以 <code>nums[i]</code> 为结尾的最大子数组和。<code>f[i]</code> 可以选择和之前的拼在一起 <code>f[i-1] + nums[i]</code> 或者自成一个子数组 <code>nums[i]</code>. 如果之前的最大子数组和 &lt; 0 则拼在一起只会更小，所以我们有</p>
$$
f[i]=\begin{cases}nums[i],&i=0\\\max(f[i-1],0)+nums[i],&i\geq1\end{cases}
$$<p>答案为 f 数组中最大的那一个。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">maxSubArray</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">f</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">        <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">ranges</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>观察到我们更新的等式只用到了两个状态，因此可以降低空间复杂度</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">maxSubArray</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">f</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">f</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="n">ans</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h2 id="56">56<a hidden class="anchor" aria-hidden="true" href="#56">#</a></h2>
<p>两个区间 <code>[a, b], [c, d]</code> 重合的充要条件为 <code>a &lt;= d &amp;&amp; c &lt;= b</code>. 先按照区间开始时间排序就保证了 <code>a &lt;= c &lt;= d</code>. 遍历数组的时候若 <code>c &lt;= b</code> 就说明两个区间可以重合，然后更新结束时间为两个区间的较大者。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">merge</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">intervals</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">ranges</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">intervals</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">begin</span> <span class="o">=</span> <span class="n">intervals</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">end</span> <span class="o">=</span> <span class="n">intervals</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">interval</span> <span class="p">:</span> <span class="n">intervals</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">interval</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">end</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">interval</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span> <span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">});</span>
</span></span><span class="line"><span class="cl">                <span class="n">begin</span> <span class="o">=</span> <span class="n">interval</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                <span class="n">end</span> <span class="o">=</span> <span class="n">interval</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>           
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">});</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h2 id="189">189<a hidden class="anchor" aria-hidden="true" href="#189">#</a></h2>
<p>设数组大小为 n.</p>
<ol>
<li>反转前 n - k 个元素。</li>
<li>反转后 k 个元素。</li>
<li>反转整个数组。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">rotate</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">k</span> <span class="o">%=</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 1. 反转前 n - k 个元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">std</span><span class="o">::</span><span class="n">reverse</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">n</span> <span class="o">-</span> <span class="n">k</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 2. 反转后 k 个元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">std</span><span class="o">::</span><span class="n">reverse</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">n</span> <span class="o">-</span> <span class="n">k</span><span class="p">,</span> <span class="n">nums</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 3. 反转整个数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">std</span><span class="o">::</span><span class="n">reverse</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">nums</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h2 id="238">238<a hidden class="anchor" aria-hidden="true" href="#238">#</a></h2>
<p>对于数组中的任意一个位置 i，<code>answer[i]</code> 的值是<strong>它左边所有元素的乘积 乘以 右边所有元素的乘积</strong>。我们可以分两步来计算：</p>
<ol>
<li>
<p>计算前缀乘积 (Prefix Products): 创建一个数组（或者直接利用结果数组 answer），answer[i] 存储 nums[0] 到 nums[i-1] 的所有元素的乘积。</p>
</li>
<li>
<p>计算后缀乘积 (Suffix Products) 并得出最终结果: 从后向前遍历数组。引入一个变量 <code>suffix_product</code> 来记录右侧所有元素的累积乘积。在遍历到位置 i 时，先将 <code>answer[i]</code>（此时存储的是前缀乘积）乘以 <code>suffix_product</code>，然后更新 <code>suffix_product</code> 为 <code>suffix_product * nums[i]</code>，为下一个位置的计算做准备。</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">productExceptSelf</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">suf</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">suf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">suf</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">pre</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">suf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="n">pre</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">pre</span> <span class="o">*=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">suf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h2 id="41">41<a hidden class="anchor" aria-hidden="true" href="#41">#</a></h2>
<p>$O(1)$ 的空间复杂度限制意味着我们不能使用哈希表等额外的数据结构来记录数字的出现情况。必须在输入数组 nums 本身上进行修改和标记，以达到记录信息的目的。</p>
<p>我们的目标是找到缺失的第一个正整数。假设数组的长度为 n，那么这个缺失的数一定在 <code>[1, n+1]</code> 这个范围内。</p>
<ol>
<li>如果 1 到 n 都在数组 nums 中，那么缺失的第一个正整数就是 n+1.</li>
<li>如果 1 到 n 中有任何一个数不在 nums 中，那么缺失的第一个正整数就在 <code>[1, n]</code> 这个区间内。</li>
</ol>
<p>因此，我们的问题转化为了：检查 1 到 n 这些数字是否在 nums 数组中。</p>
<p>我们可以利用数组的索引来充当哈希表的键，数组中的元素来充当值，从而建立一种映射关系。具体来说，我们希望数字 k 能够被放到索引为 k-1 的位置上。例如，数字 1 应该被放到索引 0，数字 2 应该被放到索引 1，以此类推。</p>
<p>第一次遍历数组时，只要 <code>nums[i]</code> 是一个在 <code>[1, n]</code> 范围内的正数，并且它没有被放到正确的位置上 (即 <code>nums[i] != nums[nums[i] - 1]</code>)，我们就继续交换。</p>
<blockquote>
<p><code>nums[i] != nums[nums[i] - 1]</code> 是为了防止当两个相同数字需要交换时陷入死循环。例如<code> nums = [1, 1], i = 0, nums[0] = 1</code>, 遍历到 nums[1] 时 <code>nums[nums[1]-1] = nums[0] = 1</code>. 说明<strong>要进行交换的位置上的值已经是正确的</strong>。</p></blockquote>
<p>经过上一步的整理，数组 nums 已经尽可能地把数字 k 放在了索引 k-1 的位置 (在答案范围内且没有重复的)。现在我们再遍历一次数组：检查 nums[i] 是否等于 i+1。第一个不满足条件的索引 i，就意味着 i+1 是缺失的第一个正整数。遍历完成都满足说明缺失的第一个正整数为 n+1.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">firstMissingPositive</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">while</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">nums</span><span class="p">[</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">swap</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h1 id="matrix">Matrix<a hidden class="anchor" aria-hidden="true" href="#matrix">#</a></h1>
<h2 id="73">73<a hidden class="anchor" aria-hidden="true" href="#73">#</a></h2>
<p>可以利用矩阵的第一行和第一列来存储哪些行和列需要被置零。</p>
<p>首先，我们需要两个布尔变量 <code>isFirstRowZero</code> 和 <code>isFirstColZero</code> 来单独记录第一行和第一列是否本身就包含 0. 因为第一行第一列 <code>matrix[0][0]</code> 的状态是共享的，所以需要分开记录。</p>
<p>用第一行/列做标记：遍历除第一行和第一列之外的矩阵部分，如果 <code>matrix[i][j] == 0</code>，则将对应的第一行 <code>matrix[i][0]</code> 和第一列 <code>matrix[0][j]</code> 的元素置零。</p>
<p>再次遍历除第一行和第一列之外的矩阵部分。如果 <code>matrix[i][0] == 0</code> 或 <code>matrix[0][j] == 0</code>，说明第 i 行或第 j 列需要被清零，因此将 <code>matrix[i][j]</code> 置为 0.</p>
<p>最后，根据步骤 1 中记录的 <code>isFirstRowZero</code> 和 <code>isFirstColZero</code> 的值来决定是否将第一行和第一列整体置零。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">setZeroes</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">matrix</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="kt">bool</span> <span class="n">isFirstColZero</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">bool</span> <span class="n">isFirstRowZero</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 1. 检查第一列是否需要置零
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">isFirstColZero</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 2. 检查第一行是否需要置零
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">isFirstRowZero</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 3. 用第一行和第一列记录其他行列的零状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 从 (1, 1) 开始遍历
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                    <span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 4. 根据第一行和第一列的标记，更新矩阵（不包括第一行第一列）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="c1">// 5. 最后处理第一行和第一列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">isFirstRowZero</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">isFirstColZero</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h2 id="54">54<a hidden class="anchor" aria-hidden="true" href="#54">#</a></h2>
<p>维护四个变量，分别代表当前待遍历矩阵的上、下、左、右四个边界。在每一轮循环中，我们沿着这四个边界走一圈  (👉👇👈👆)，然后向内收缩边界，直到边界相遇或交错。</p>
<p>当螺旋收缩到只剩一行或一列时，上面第 1、2 步执行完后，边界条件可能就不满足了（例如，top &gt; bottom）。因此，在执行第 3、4 步之前，需要再次检查边界条件，防止重复添加元素。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">spiralOrder</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">matrix</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">ans</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">m</span> <span class="o">*</span> <span class="n">n</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">top</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bottom</span> <span class="o">=</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">top</span> <span class="o">&lt;=</span> <span class="n">bottom</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 1. 从左到右遍历上边界
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">top</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="n">top</span><span class="o">++</span><span class="p">;</span> <span class="c1">// 上边界下移
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 2. 从上到下遍历右边界
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">top</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">bottom</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">right</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="n">right</span><span class="o">--</span><span class="p">;</span> <span class="c1">// 右边界左移
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 检查边界，防止在只剩一行或一列时重复遍历
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">top</span> <span class="o">&lt;=</span> <span class="n">bottom</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 3. 从右到左遍历下边界
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">left</span><span class="p">;</span> <span class="o">--</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">bottom</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="n">bottom</span><span class="o">--</span><span class="p">;</span> <span class="c1">// 下边界上移
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 4. 从下到上遍历左边界
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">bottom</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">top</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">left</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="n">left</span><span class="o">++</span><span class="p">;</span> <span class="c1">// 左边界右移
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h2 id="48">48<a hidden class="anchor" aria-hidden="true" href="#48">#</a></h2>
<p>位于 i 行 j 列的元素，去到 j 行 <code>n−1−i</code> 列，即 <code>(i,j) -&gt; (j,n−1−i)</code>.
因此可以通过先转置再纵向对称翻转实现。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">rotate</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">matrix</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">swap</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">matrix</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">swap</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">j</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h2 id="240">240<a hidden class="anchor" aria-hidden="true" href="#240">#</a></h2>
<p>右上角的元素，它是当前行的最大值，同时也是当前列的最小值。每一步都可以排除掉一行或者一列，从而不断缩小搜索范围。从右上角开始搜索:</p>
<ul>
<li>
<p><code>matrix[row][col] &gt; target</code>: 当前元素是其所在列的最小值，如果它都比 target 大，那么这一整列下方的所有元素必定也比 target 大。因此，可以完全排除当前列。向左移动，<code>col--</code>.</p>
</li>
<li>
<p><code>matrix[row][col] &lt; target</code>: 因为当前元素是其所在行的最大值，如果它都比 target 小，那么这一整行左边的所有元素必定也比 target 小。因此，可以完全排除当前行。向下移动，<code>row++</code>.</p>
</li>
</ul>
<p>当超出下边界或超出左边界时说明找不到目标值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="n">searchMatrix</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">matrix</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="n">row</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="o">&amp;&amp;</span> <span class="n">col</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">col</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">row</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h1 id="linked-list">Linked List<a hidden class="anchor" aria-hidden="true" href="#linked-list">#</a></h1>
<h2 id="160">160<a hidden class="anchor" aria-hidden="true" href="#160">#</a></h2>
<p>使用两个指针 pa 和 pb 分别指向 headA 和 headB. 同时遍历两个链表:</p>
<p>如果 pa 或 pb 到达链表末尾（nullptr），将其切换到另一个链表的头部继续遍历。这样，两个指针最终会“走过相同的距离”，要么在相交节点相遇，要么都到达 nullptr.</p>
<blockquote>
<p>设链表 A 的长度为 a + c，链表 B 的长度为 b + c，其中 c 是相交部分的长度。指针 pa 遍历 a + c + b 后，指针 pb 遍历 b + c + a 后，它们会在相交节点相遇 (无交点则都到达 nulll ptr).</p></blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">ListNode</span> <span class="o">*</span><span class="n">getIntersectionNode</span><span class="p">(</span><span class="n">ListNode</span> <span class="o">*</span><span class="n">headA</span><span class="p">,</span> <span class="n">ListNode</span> <span class="o">*</span><span class="n">headB</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">ListNode</span><span class="o">*</span><span class="n">pa</span> <span class="o">=</span> <span class="n">headA</span><span class="p">,</span> <span class="o">*</span><span class="n">pb</span> <span class="o">=</span> <span class="n">headB</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="n">pa</span> <span class="o">!=</span> <span class="n">pb</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">pa</span> <span class="o">=</span> <span class="n">pa</span> <span class="o">?</span> <span class="n">pa</span><span class="o">-&gt;</span><span class="nl">next</span> <span class="p">:</span> <span class="n">headB</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">pb</span> <span class="o">=</span> <span class="n">pb</span> <span class="o">?</span> <span class="n">pb</span><span class="o">-&gt;</span><span class="nl">next</span> <span class="p">:</span> <span class="n">headA</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">pa</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h2 id="206">206<a hidden class="anchor" aria-hidden="true" href="#206">#</a></h2>
<p>从 <code>pre = nullptr</code> 开始，这样可以自然地将原头节点的 <code>next</code> 设置为 <code>nullptr</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">ListNode</span><span class="o">*</span> <span class="n">reverseList</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">ListNode</span><span class="o">*</span> <span class="n">pre</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">,</span> <span class="o">*</span><span class="n">cur</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="n">cur</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">ListNode</span><span class="o">*</span> <span class="n">n</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">pre</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">pre</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">cur</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">pre</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h2 id="141">141<a hidden class="anchor" aria-hidden="true" href="#141">#</a></h2>
<p>慢指针 slow 一次移动一步，快指针 fast 一次移动两步。如果能相遇说明有环，否则快指针会先走到链表末尾 nullptr.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="n">hasCycle</span><span class="p">(</span><span class="n">ListNode</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">ListNode</span><span class="o">*</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">head</span><span class="p">,</span> <span class="o">*</span><span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="n">fast</span> <span class="o">&amp;&amp;</span> <span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">slow</span> <span class="o">==</span> <span class="n">fast</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h2 id="142">142<a hidden class="anchor" aria-hidden="true" href="#142">#</a></h2>
<p>假设进环前的路程为 a，环长为 b。设慢指针走了 x 步时，快慢指针相遇，此时快指针走了 2x 步。显然 2x-x=nb（快指针比慢指针多走了 n 圈），即 x=nb. 也就是说慢指针总共走过的路程是 nb，但这 nb 当中，实际上包含了进环前的一个小 a，因此慢指针在环中只走了 nb-a 步，它还得再往前走 a 步，才是完整的 n 圈。所以，我们让头节点和慢指针同时往前走，当他俩相遇时，就走过了最后这 a 步。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">ListNode</span> <span class="o">*</span><span class="n">detectCycle</span><span class="p">(</span><span class="n">ListNode</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">ListNode</span><span class="o">*</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">head</span><span class="p">,</span> <span class="o">*</span><span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="n">fast</span> <span class="o">&amp;&amp;</span> <span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">slow</span> <span class="o">==</span> <span class="n">fast</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">while</span> <span class="p">(</span><span class="n">head</span> <span class="o">!=</span> <span class="n">slow</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                    <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="n">slow</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h2 id="21">21<a hidden class="anchor" aria-hidden="true" href="#21">#</a></h2>
<p>创建一个 dummy 节点，作为合并后的新链表头节点的前一个节点。</p>
<p>比较 list 1 和 list2的节点值，如果 list1 的节点值小，则把 list1 加到新链表的末尾，然后把 list1 替换成它的下一个节点。反之同样。</p>
<p>直到一个链表为空就把另一个链表直接加到新链表末尾，返回 <code>dummy.next</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">ListNode</span><span class="o">*</span> <span class="n">mergeTwoLists</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">list1</span><span class="p">,</span> <span class="n">ListNode</span><span class="o">*</span> <span class="n">list2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">ListNode</span> <span class="nf">dummy</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">ListNode</span><span class="o">*</span> <span class="n">tail</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dummy</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="n">list1</span> <span class="o">&amp;&amp;</span> <span class="n">list2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">list1</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">list2</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">list1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">list1</span> <span class="o">=</span> <span class="n">list1</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">list2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">list2</span> <span class="o">=</span> <span class="n">list2</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="n">tail</span> <span class="o">=</span> <span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">list1</span> <span class="o">?</span> <span class="nl">list1</span> <span class="p">:</span> <span class="n">list2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">dummy</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h2 id="2">2<a hidden class="anchor" aria-hidden="true" href="#2">#</a></h2>
<p>注意两个链表遍历完后可能还有进位。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">ListNode</span><span class="o">*</span> <span class="n">addTwoNumbers</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">l1</span><span class="p">,</span> <span class="n">ListNode</span><span class="o">*</span> <span class="n">l2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">ListNode</span> <span class="n">dummy</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">ListNode</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dummy</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">carry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="n">l1</span> <span class="o">&amp;&amp;</span> <span class="n">l2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">l1</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">+</span> <span class="n">l2</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">+</span> <span class="n">carry</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">carry</span> <span class="o">=</span> <span class="n">num</span> <span class="o">&gt;=</span> <span class="mi">10</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">num</span> <span class="o">%=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="n">num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">l1</span> <span class="o">=</span> <span class="n">l1</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">l2</span> <span class="o">=</span> <span class="n">l2</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="n">l1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">l1</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">+</span> <span class="n">carry</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">carry</span> <span class="o">=</span> <span class="n">num</span> <span class="o">&gt;=</span> <span class="mi">10</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">num</span> <span class="o">%=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="n">num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">l1</span> <span class="o">=</span> <span class="n">l1</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="n">l2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">l2</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">+</span> <span class="n">carry</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">carry</span> <span class="o">=</span> <span class="n">num</span> <span class="o">&gt;=</span> <span class="mi">10</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">num</span> <span class="o">%=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="n">num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">l2</span> <span class="o">=</span> <span class="n">l2</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">carry</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="n">carry</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">dummy</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h2 id="19">19<a hidden class="anchor" aria-hidden="true" href="#19">#</a></h2>
<p>为了简化需要删除头节点的逻辑，我们需要添加一个哨兵节点 dummy. 慢指针 slow 在链表 dummy，先移动快指针 slow 到正数第 n 个节点。然后同时移动快慢指针，fast 到达 nullptr 时，左端点就在倒数第 n 个节点。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">ListNode</span><span class="o">*</span> <span class="n">removeNthFromEnd</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">ListNode</span> <span class="nf">dummy</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">ListNode</span><span class="o">*</span> <span class="n">slow</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dummy</span><span class="p">,</span> <span class="o">*</span><span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="n">fast</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">fast</span><span class="o">=</span> <span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">slow</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">slow</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">dummy</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h2 id="24">24<a hidden class="anchor" aria-hidden="true" href="#24">#</a></h2>
<p>用一个指针 pre 指向已经翻转部分的最后一个节点，cur 指向下一个要翻转的节点。当要翻转的一对节点 <code>cur &amp;&amp; cur-&gt;next</code> 都存在时:</p>
<ol>
<li><code>pre-&gt;next = cur-&gt;next</code></li>
<li><code>cur-&gt;next = cur-&gt;next-&gt;next</code></li>
<li><code>cur-&gt;next-&gt;next = cur</code></li>
</ol>
<p>此时 cur 成为已经翻转部分的最后一个节点，让 pre 指向它，cur 再指向 <code>cur-&gt;next</code>. 由于需要对头节点进行翻转，所以我们初始化哨兵节点来作为一开始已经翻转部分的最后一个节点。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">ListNode</span><span class="o">*</span> <span class="n">swapPairs</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">head</span> <span class="o">||</span> <span class="o">!</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">head</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">ListNode</span> <span class="nf">dummy</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">ListNode</span><span class="o">*</span> <span class="n">pre</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dummy</span><span class="p">,</span> <span class="o">*</span><span class="n">cur</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="n">cur</span> <span class="o">&amp;&amp;</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">ListNode</span><span class="o">*</span> <span class="n">next</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">pre</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="n">pre</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">dummy</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h2 id="25">25<a hidden class="anchor" aria-hidden="true" href="#25">#</a></h2>
<ol>
<li>通过一次遍历计算出链表总长度，从而确定总共需要反转多少个分组。</li>
<li>pre 指向已经翻转的部分的最后一个节点， 内循环进行每一组的链表反转。反转结束后 cur 指向的是下一组的开始节点。重新链接反转后的子链表。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">ListNode</span><span class="o">*</span> <span class="n">reverseKGroup</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">ListNode</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="n">cur</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">len</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">ng</span> <span class="o">=</span> <span class="n">len</span> <span class="o">/</span> <span class="n">k</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">ListNode</span> <span class="nf">dummy</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">ListNode</span><span class="o">*</span> <span class="n">pre</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dummy</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">cur</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ng</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">ListNode</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">ListNode</span><span class="o">*</span> <span class="n">next</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">p</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">cur</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="n">pre</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">ListNode</span><span class="o">*</span> <span class="n">next_pre</span> <span class="o">=</span> <span class="n">pre</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">pre</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">pre</span> <span class="o">=</span> <span class="n">next_pre</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">dummy</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h2 id="234">234<a hidden class="anchor" aria-hidden="true" href="#234">#</a></h2>
<ol>
<li>用快慢指针找到链表中间位置 (len / 2) 的节点。</li>
<li>翻转后一半链表。</li>
<li>同时从头尾开始遍历判断值是否相等。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ListNode</span><span class="o">*</span> <span class="nf">reverseList</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">ListNode</span><span class="o">*</span> <span class="n">pre</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">,</span> <span class="o">*</span><span class="n">cur</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="n">cur</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">ListNode</span><span class="o">*</span> <span class="n">n</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">pre</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">pre</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">cur</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">pre</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">ListNode</span><span class="o">*</span> <span class="nf">middleList</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">ListNode</span><span class="o">*</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">head</span><span class="p">,</span> <span class="o">*</span><span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="n">fast</span> <span class="o">&amp;&amp;</span> <span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">slow</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="n">isPalindrome</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">ListNode</span><span class="o">*</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">middleList</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">ListNode</span><span class="o">*</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">reverseList</span><span class="p">(</span><span class="n">mid</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="n">head</span> <span class="o">&amp;&amp;</span> <span class="n">tail</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">!=</span> <span class="n">tail</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">tail</span> <span class="o">=</span> <span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h2 id="138">138<a hidden class="anchor" aria-hidden="true" href="#138">#</a></h2>
<ol>
<li>
<p>创建交织链表: 遍历原链表，对于每个节点，创建一个新节点（副本），并将其插入到原节点和原节点的下一个节点之间。例如，原链表 <code>A -&gt; B -&gt; C</code> 变成 <code>A -&gt; A' -&gt; B -&gt; B' -&gt; C -&gt; C'</code>.</p>
</li>
<li>
<p>设置 random 指针: 对于原链表的每个节点 N，其副本节点 N&rsquo; 紧随其后。
如果 <code>N-&gt;random</code> 指向某个节点 M，则 <code>N'-&gt;random</code> 应指向 M&rsquo; (M 的副本). 由于 M&rsquo; 是 <code>M-&gt;next</code>，我们可以直接设置 N<code>-&gt;next-&gt;random = N-&gt;random-&gt;next</code>.</p>
</li>
<li>
<p>分离新旧链表: 遍历交织链表，将新节点和旧节点分开，恢复原链表并提取新链表。确保正确设置 next 指针，断开新旧节点之间的连接。</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">*</span> <span class="n">copyRandomList</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">head</span><span class="p">)</span> <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">       
</span></span><span class="line"><span class="cl">        <span class="n">Node</span> <span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="n">cur</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">,</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">cur</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="n">cur</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">random</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">random</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">random</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">Node</span> <span class="o">*</span><span class="n">newHead</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">cur</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">Node</span><span class="o">*</span> <span class="n">copy</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">copy</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">copy</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">newHead</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h2 id="148">148<a hidden class="anchor" aria-hidden="true" href="#148">#</a></h2>
<ol>
<li>遍历链表，获取链表长度。</li>
<li>自底向上归并排序: 将链表中的每个节点都看作是一个长度为 1 的、已经排好序的子链表。在内部循环每一轮中找到每一对要合并的子链表 head1 和 head2，然后将它们合并，并链接到上一段合并好的链表的末尾。
<ul>
<li>第一轮：将相邻的、长度为 1 的子链表两两合并，形成多个长度为 2 的有序子链表。</li>
<li>第二轮：将相邻的、长度为 2 的子链表两两合并，形成多个长度为 4 的有序子链表。</li>
<li>第三轮：将相邻的、长度为 4 的子链表两两合并，形成多个长度为 8 的有序子链表。</li>
</ul>
</li>
<li>每次从 dummy 节点开始重复这个过程，归并后将子链表的长度 subLen 翻倍 (1, 2, 4, 8, &hellip;)，直到 subLen &gt;= 整个链表的长度。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ListNode</span><span class="o">*</span> <span class="nf">merge</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head1</span><span class="p">,</span> <span class="n">ListNode</span><span class="o">*</span> <span class="n">head2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">ListNode</span> <span class="n">dummy</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">ListNode</span><span class="o">*</span> <span class="n">tail</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dummy</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="n">head1</span> <span class="o">&amp;&amp;</span> <span class="n">head2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">head1</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">head2</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">head1</span> <span class="o">=</span> <span class="n">head1</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">head2</span> <span class="o">=</span> <span class="n">head2</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="n">tail</span> <span class="o">=</span> <span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head1</span> <span class="o">?</span> <span class="nl">head1</span> <span class="p">:</span> <span class="n">head2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">dummy</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">ListNode</span><span class="o">*</span> <span class="n">sortList</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">ListNode</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">len</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">ListNode</span> <span class="nf">dummy</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">subLen</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">subLen</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">subLen</span><span class="o">*=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">ListNode</span><span class="o">*</span> <span class="n">pre</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dummy</span><span class="p">;</span>  <span class="c1">// pre records the tail of last merged 2 segments
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">ListNode</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">dummy</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>  <span class="c1">// cur records the start node to merge
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">            <span class="k">while</span> <span class="p">(</span><span class="n">cur</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// find first segment chainList with subLen
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">ListNode</span><span class="o">*</span> <span class="n">head1</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">subLen</span> <span class="o">&amp;&amp;</span> <span class="n">cur</span> <span class="o">&amp;&amp;</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// find second segment chianList and cut the connection with first segement
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">ListNode</span><span class="o">*</span> <span class="n">head2</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">cur</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">head2</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                    <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="c1">// find the tail of second segment
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">cur</span> <span class="o">=</span> <span class="n">head2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">subLen</span> <span class="o">&amp;&amp;</span> <span class="n">cur</span> <span class="o">&amp;&amp;</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="c1">// record the next round start node to merge and cut the connection with second segement
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">ListNode</span><span class="o">*</span> <span class="n">nextSub</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">cur</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">nextSub</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                    <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="n">ListNode</span><span class="o">*</span> <span class="n">merged</span> <span class="o">=</span> <span class="n">merge</span><span class="p">(</span><span class="n">head1</span><span class="p">,</span> <span class="n">head2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">pre</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">merged</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="c1">// move pre to the end of merged segment
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">while</span> <span class="p">(</span><span class="n">pre</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">pre</span> <span class="o">=</span> <span class="n">pre</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="n">cur</span> <span class="o">=</span> <span class="n">nextSub</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">dummy</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h2 id="23">23<a hidden class="anchor" aria-hidden="true" href="#23">#</a></h2>
<p>直接自底向上合并链表：</p>
<ol>
<li>两两合并：把 lists[0] 和 lists[1] 合并，合并后的链表保存在 lists[0] 中；把 lists[2] 和 lists[3] 合并，合并后的链表保存在 lists[2] 中；依此类推。</li>
<li>四四合并：把 lists[0] 和 lists[2] 合并（相当于合并前四条链表），合并后的链表保存在 lists[0] 中；把 lists[4] 和 lists[6] 合并，合并后的链表保存在 lists[4] 中；依此类推。</li>
<li>八八合并：把 lists[0] 和 lists[4] 合并（相当于合并前八条链表），合并后的链表保存在 lists[0] 中；把 lists[8] 和 lists[12] 合并，合并后的链表保存在 lists[8] 中；依此类推。</li>
<li>依此类推，直到所有链表都合并到 lists[0] 中。最后返回 lists[0].</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ListNode</span><span class="o">*</span> <span class="nf">merge</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head1</span><span class="p">,</span> <span class="n">ListNode</span><span class="o">*</span> <span class="n">head2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">ListNode</span> <span class="n">dummy</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">ListNode</span><span class="o">*</span> <span class="n">tail</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dummy</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="n">head1</span> <span class="o">&amp;&amp;</span> <span class="n">head2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">head1</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">head2</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">head1</span> <span class="o">=</span> <span class="n">head1</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">head2</span> <span class="o">=</span> <span class="n">head2</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="n">tail</span> <span class="o">=</span> <span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head1</span> <span class="o">?</span> <span class="nl">head1</span> <span class="p">:</span> <span class="n">head2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">dummy</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">ListNode</span><span class="o">*</span> <span class="n">mergeKLists</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ListNode</span><span class="o">*&gt;&amp;</span> <span class="n">lists</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">lists</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">lists</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="n">lists</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">step</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">step</span> <span class="o">&lt;</span> <span class="n">lists</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">step</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">lists</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="n">step</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">step</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">lists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">merge</span><span class="p">(</span><span class="n">lists</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">lists</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">step</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">lists</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h2 id="146">146<a hidden class="anchor" aria-hidden="true" href="#146">#</a></h2>
<ul>
<li>
<p>双向链表 (<code>std::list</code>): 维护数据的使用顺序。</p>
<ul>
<li>链表中存储 (key, value) 对。</li>
<li>链表头部 (front)：存放最近访问过的数据。</li>
<li>链表尾部 (back)：存放最久未被访问的数据。</li>
</ul>
</li>
<li>
<p>哈希表 (<code>std::unordered_map</code>): 实现 O(1) 的快速查找。通过 key，我们能立刻定位到它在链表中的位置。</p>
<ul>
<li>key：存储缓存项的键。</li>
<li>value：存储一个指向双向链表中对应节点的指针或迭代器。</li>
</ul>
</li>
<li>
<p><code>get(key)</code>:</p>
<p>通过哈希表查找 key. 如果未找到直接返回 -1.如果找到了:</p>
<ol>
<li>从哈希表中获取到链表节点的指针/迭代器。</li>
<li>通过指针/迭代器获取节点中的 value.</li>
<li>将这个节点从它当前的位置移动到链表的头部（表示它刚刚被访问过）。</li>
<li>返回 value.</li>
</ol>
</li>
<li>
<p>put(key, value) 操作: 通过哈希表查找 key.</p>
<p>如果找到了 (key 已存在)：</p>
<ol>
<li>从哈希表中获取到链表节点的指针/迭代器。</li>
<li>更新该节点中的 value.</li>
<li>将这个节点移动到链表的头部。</li>
</ol>
<p>如果未找到 (key 是新的)：</p>
<ol>
<li>检查缓存是否已满，如果已满:
<ul>
<li>获取链表尾部的节点。</li>
<li>从哈希表中删除尾部节点的 key。</li>
<li>从链表中删除该尾部节点。</li>
</ul>
</li>
<li>在链表头部创建一个新节点，存储 (key, value).</li>
<li>在哈希表中插入新的 key，并让其 value 指向刚创建的链表头节点。</li>
</ol>
</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/tag-1/">Tag 1</a></li>
      <li><a href="http://localhost:1313/tags/tag-2/">Tag 2</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/blogs/sjtu-xflops2024/bithack/">
    <span class="title">« Prev</span>
    <br>
    <span>Bithack</span>
  </a>
  <a class="next" href="http://localhost:1313/blogs/leetcode/09_monotonedeque/">
    <span class="title">Next »</span>
    <br>
    <span>09 Monotone Deque</span>
  </a>
</nav>

  </footer><script src="https://giscus.app/client.js"
        data-repo="jamesnulliu/jamesnulliu.github.io"
        data-repo-id="R_kgDOMPCQIw"
        data-category="Announcements"
        data-category-id="DIC_kwDOMPCQI84Cgb2t"
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="bottom"
        data-theme="preferred_color_scheme"
        data-lang="en"
        crossorigin="anonymous"
        async>
</script>
</article>
    </main>
    
<footer class="footer">
        <span>© 2024-2025 WITHER</span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
