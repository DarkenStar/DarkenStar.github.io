<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>astra-Sim | WITHER</title>
<meta name="keywords" content="astra-sim">
<meta name="description" content="source code reading of astra-sim">
<meta name="author" content="WITHER">
<link rel="canonical" href="http://localhost:1313/blogs/astra-sim/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.dd3b5b907a50db3238b81d49d094cf1c04a091227797dc9cfde4e2fa3f35df49.css" integrity="sha256-3TtbkHpQ2zI4uB1J0JTPHASgkSJ3l9yc/eTi&#43;j8130k=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/blogs/astra-sim/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<script>
  MathJax = {
    tex: {
      displayMath: [['\\[', '\\]'], ['$$', '$$']],  
      inlineMath: [['\\(', '\\)'], ['$', '$']]  
    }
  };
</script>




<script src="https://cdn.bootcdn.net/ajax/libs/mermaid/9.1.6/mermaid.min.js"></script>
<script>
    mermaid.initialize({
        startOnLoad: true,
        theme: localStorage.getItem("pref-theme") === "dark" ? "dark" : "forest" 
    });
</script>

<meta property="og:url" content="http://localhost:1313/blogs/astra-sim/">
  <meta property="og:site_name" content="WITHER">
  <meta property="og:title" content="astra-Sim">
  <meta property="og:description" content="source code reading of astra-sim">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="blogs">
    <meta property="article:published_time" content="2025-06-09T13:34:39+08:00">
    <meta property="article:modified_time" content="2025-06-13T15:12:24+08:00">
    <meta property="article:tag" content="Astra-Sim">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="astra-Sim">
<meta name="twitter:description" content="source code reading of astra-sim">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Blogs",
      "item": "http://localhost:1313/blogs/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "astra-Sim",
      "item": "http://localhost:1313/blogs/astra-sim/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "astra-Sim",
  "name": "astra-Sim",
  "description": "source code reading of astra-sim",
  "keywords": [
    "astra-sim"
  ],
  "articleBody": "Build Analytical Backend build.sh 脚本是构建过程的高级控制器。其核心职责是解析用户意图，执行预构建步骤，并以正确的参数调用底层的 CMake 工具链。\n选项解析: 脚本通过 getopts 处理以下命令行标志：\n-t : 指定编译目标。有效值为 all, congestion_unaware, congestion_aware。此值将作为变量传递给 CMake。 -l: 触发清理 (cleanup) 流程，删除所有构建产物并终止脚本。 -d: 启用调试 (Debug) 模式进行编译。 环境准备 (setup, compile_chakra_et):\nsetup 函数负责创建用于存放中间文件和最终产物的 build 目录，确保源码树的清洁。同时，它会根据系统核心数设置一个上限为 16 的并发编译线程数，以优化编译效率。 compile_chakra_et 函数负责处理 et_def.proto 这一 Protobuf 依赖。它检查目标文件是否存在，若不存在，则调用 protoc 编译器生成相应的 C++ 和 Python 源码。 构建执行 (compile_astrasim_analytical, compile_astrasim_analytical_as_debug):\n这两个函数是脚本与 CMake 交互的核心。它们根据用户是否指定 -d 标志，决定是执行标准 Release 构建还是 Debug 构建。关键在于它们会将用户指定的 build_target 作为 -DBUILDTARGET 参数传递给 CMake。 后处理 (create_symlink_*):\n编译完成后，create_symlink_congestion_unaware 和 create_symlink_congestion_aware 等函数会为生成的二进制文件创建符号链接。此举旨在维持对旧文件路径的向后兼容性。 CMakeLists.txt 文件是项目的构建蓝图，它向 CMake 阐述了项目的结构、依赖关系以及编译规则。\n编译环境设定:\ncmake_minimum_required(VERSION 3.15): 规定了运行此配置所需的最低 CMake 版本。 set(CMAKE_CXX_STANDARD 17) 和 set(CMAKE_CXX_STANDARD_REQUIRED ON): 强制项目必须在支持 C++17 标准的编译环境中构建。 编译标志 (Compiler Flags):\n此文件为不同的构建类型（CMAKE_BUILD_TYPE）定义了不同的编译器标志。 Release (默认模式): set(CMAKE_CXX_FLAGS_RELEASE \"-O3\") 指示编译器进行高等级优化，以追求最大化程序性能。 Debug: set(CMAKE_CXX_FLAGS_DEBUG \"...\") 包含一系列用于调试的标志： -O0: 关闭所有优化，确保编译后的代码与源码行为一致。 -g: 在可执行文件中包含调试符号，这是 GDB 等调试器工作的前提。 -fsanitize=address,undefined,leak: 启用 AddressSanitizer、UndefinedBehaviorSanitizer 和 LeakSanitizer。这些是强大的运行时诊断工具，用于捕获内存访问错误、未定义行为及内存泄漏。 项目结构与依赖:\nproject(AstraSim_Analytical): 声明项目名称。 add_subdirectory(...): 此指令是组织项目的关键。它将 AstraSim 核心库、Analytical 网络后端和 AstraSim_Analytical 前端等多个子模块纳入构建过程。 用户自定义选项:\nset(BUILDTARGET \"all\" CACHE STRING ...): 此行定义了一个名为 BUILDTARGET 的可缓存变量。这使得用户可以通过 cmake -D 命令从外部注入该变量的值。此变量随后会被子目录中的 CMakeLists.txt 文件用来实现条件编译。 Build ns-3 Backend 构建命令为 ./build/astra_ns3/build.sh -c，他会执行该脚本里的 compile 函数\n1 2 3 4 5 6 function compile { cd \"${NS3_DIR}\" ./ns3 configure --enable-mpi ./ns3 build AstraSimNetwork -j 12 cd \"${SCRIPT_DIR:?}\" } ./ns3 configure --enable-mpi 参数解析 (parse_args): 脚本的 argparse 模块会识别出 configure 子命令和 --enable-mpi 选项。--enable-mpi 是一个预定义的\"On-Off\"选项，用于控制 MPI (Message Passing Interface) 分布式仿真功能的支持。 进入配置步骤 (configuration_step): 由于检测到 configure 命令，脚本会调用 configuration_step 函数。 调用 CMake (configure_cmake): configuration_step 函数内部会调用 configure_cmake. 这个函数是会动态地构建一个 cmake 命令。 它会检测到 --enable-mpi 选项，并通过 on_off_condition 函数将其转换为 CMake 变量 -DNS3_MPI=ON. 最终组装出的命令为为 cmake -S . -B cmake-cache -G \"Unix Makefiles\" -DCMAKE_BUILD_TYPE=default -DNS3_ASSERT=ON -DNS3_LOG=ON -DNS3_WARNINGS_AS_ERRORS=OFF -DNS3_MPI=ON --warn-uninitialized 执行配置: 脚本通过 subprocess.run() 执行这条 cmake 命令 ./ns3 build AstraSimNetwork -j 12 参数解析 (parse_args): 脚本识别出 build 子命令，目标 AstraSimNetwork，以及并行任务数 -j 12. 前者会被存入 args.build 列表，后者会被存入 args.jobs. 进入构建步骤 (build_step): 脚本检测到 build 命令，并调用 build_step 函数。 调用 CMake 构建 (cmake_build): build_step 函数会遍历 args.build 列表中的所有目标。在这里，它会为 AstraSimNetwork 这个目标调用 cmake_build 函数。 cmake_build 函数会组装出一条 cmake --build 命令。 将目标 AstraSimNetwork 转换为 --target AstraSimNetwork. 将并行任务数 12 转换为 -j 12. 最终组装出的命令为 cmake --build cmake-cache --target AstraSimNetwork -j 12. Error When Building ns-3 call of overloaded ‘format(…)’ is ambiguous ❌ 问题诊断 🩺 错误信息 call of overloaded ‘format(...)’ is ambiguous 的意思是，编译器在你的代码中遇到了一个名为 format 的函数调用，但它找到了多个同名的、并且参数类型都能匹配的 format 函数定义，导致编译器不知道该选择哪一个，因此产生了“歧义”（ambiguous）。\n这个歧义的来源是：\nstd::format (来自 C++20 标准库): 你的项目很可能正在使用支持 C++20 或更高版本的现代编译器（如 GCC 11+）。C++20 标准库引入了一个新的格式化函数 std::format。 fmt::format (来自 {fmt} 库): spdlog 这个日志库是基于一个非常流行的第三方格式化库 {fmt} 构建的。这个库也提供了一个功能几乎完全相同的 fmt::format 函数。在 spdlog 的上下文中，它通常可以直接以 format 的形式被调用。 当你的代码（这里是 spdlog_setup 的一部分）简单地调用 format(...) 时，如果 C++20 的 头文件被包含，编译器就会同时看到 std::format 和 spdlog 内部的 fmt::format。由于两者都能处理字符串字面量 (const char[]) 和 std::string，编译器无法决定用哪个，从而报错。\n关于 using fmt::format; 为何仍然无效的解释 原因是，除了常规的命名空间查找规则，C++ 还有一个更强大的规则叫做参数依赖查找（Argument-Dependent Lookup, ADL），有时也被称为 Koenig 查找。\n我们来梳理一下编译器在看到 format(...) 这行代码时的“思考过程”：\n在当前作用域查找\n编译器看到了你的 using fmt::format; 声明。很好，它在当前作用域里找到了一个叫做 format 的函数（也就是 fmt::format）。这成为了候选者 A。\n参数依赖查找 (ADL) —— 问题的根源\n接下来，编译器会检查 format(...) 函数的所有参数类型。在你的错误日志里，我们看到了 const std::string\u0026 这样的参数。\nADL 规则规定：如果一个函数的参数是某个命名空间 N 下的类型（比如 std::string 是 std 命名空间下的），那么编译器也必须去那个命名空间 N (这里是 std) 里面去查找同名的函数。 由于 std::string 是 std 命名空间的成员，ADL 规则被触发，编译器自动地去 std 命名空间里寻找名为 format 的函数。 因为你使用了 C++20 编译器，它在 std 命名空间里成功找到了 std::format。这成为了候选者 B。 产生歧义\n现在编译器陷入了困境。它手头有两个同样匹配的候选函数：\n候选者 A: fmt::format (通过 using 声明找到) 候选者 B: std::format (通过 ADL 在参数的命名空间里找到) using 声明只是将一个名字引入当前作用域，它并**没有足够的“特权”**去压制一个通过 ADL 找到的同样优秀的候选者。因为两个函数都能完美处理你传入的参数，编译器无法做出选择，所以它只能放弃并报告“调用是模糊的 (ambiguous)”。\n结论与最终解决方案 ✅ 这个 C++ 的特性意味着，只要你的函数参数中包含了 std 命名空间里的类型（如 std::string, std::vector 等），ADL 就有可能被触发，从而把 std 里的函数（如 std::format, std::to_string 等）也拉入候选列表，造成意想不到的冲突。\n因此，唯一能 100% 消除歧义、让编译器别无选择的方法，就是使用显式的命名空间限定：\n1 2 3 // 这样做，是在直接告诉编译器：“别去猜了，我就是要调用 fmt 命名空间里的这个 format！” // 这会完全绕过 ADL 和其他查找规则，直达目标。 fmt::format(...); Runing Arguments 执行仿真需要传递一些参数，命令模板如下\n1 2 3 4 5 {ASTRA_SIM_BIN} \\ --workload-configuration=${WORKLOAD_CONFIG} \\ --system-configuration=${SYSTEM_CONFIG} \\ --network-configuration=${NETWORK_CONFIG} \\ --remote-memory-configuration=${REMOTE_MEMORY_CONFIG} WORKLOAD_CONFIG astra-sim 使用的是 Chakra (Execution Trace) 作为 workload 层的输入。将 chakra 作为 python package 安装后有几个命令通过 pyproject.toml 对应到 python函数。\nExplanation of toml file pyproject.toml 是一个标准化的配置文件，用于定义 Python 项目的元数据、依赖关系以及构建和开发工具的配置。\n[build-system] 构建系统配置，这部分定义了如何构建你的 Python 包。 **requires**: 列出了构建项目本身所必需的包。这些是构建环境的依赖，而不是你代码运行时的依赖。 setuptools, setuptools-grpc: 表明此项目使用 setuptools 作为其构建工具，并需要 setuptools-grpc 插件。 **build-backend**: 指定了构建工具中实际执行构建过程的 Python 对象（入口点）。 setuptools.build_meta: 这是 setuptools 提供的标准构建后端。 [project]：这部分包含了项目的基本信息，这些信息会展示在 PyPI (Python Package Index) 上。 **name**: 包的名称，即 pip install chakra 中的 chakra。 **requires-python**: 运行此包所需的最低 Python 版本，这里是 3.7 或更高。 **version**: 当前包的版本号。 **readme**: 指向一个文件，该文件的内容将作为项目在 PyPI 上的详细描述。 **license**: 指向包含许可证信息的文件。 **authors**：项目的作者信息。 **dependencies**: 项目运行时的依赖项。当用户 pip install chakra 时，这些包也会被一并安装。 protobuf==5.*: 需要版本为 5.x 的 protobuf 库。 graphviz, networkx, pydot: 其他标准的第三方库依赖。 HolisticTraceAnalysis @ git+...: 这是一个特殊的依赖。它直接从 GitHub 仓库的一个特定 commit (d731cc...) 来安装。这确保了项目依赖于一个稳定且不会意外变动的版本。 [project.urls]：项目相关链接，这些链接会显示在 PyPI 页面的侧边栏，为用户提供更多信息的入口。 **Homepage**, **Documentation**, **Repository**: 分别指向项目主页、文档和代码仓库的 URL。 [tool.setuptools]：这部分是针对构建工具 setuptools 的详细配置。 **package-dir**: 定义了 Python 包名与实际源代码目录之间的映射关系。 例如，\"chakra.src.converter\" = \"src/converter\" 表示当用户 import chakra.src.converter 时，Python 会从 src/converter/ 目录下寻找代码。这使得项目可以使用 src 布局。 **package-data**: 指定需要包含在最终发布包中的非 Python 文件。 \"chakra.schema.protobuf\" = [\"et_def.proto\"]: 表示需要将 et_def.proto 这个文件打包到 chakra.schema.protobuf 这个包里。 [project.scripts]：这部分定义了在安装包时应创建的命令行工具。 **chakra_converter = \"chakra.src.converter.converter:main\"**: 这行配置意味着，当用户安装此包后，他们可以在终端中直接运行 chakra_converter 命令。执行此命令时，系统会调用 chakra.src.converter.converter 模块中的 main 函数。 [tool.ruff]：这部分是用于配置 Ruff 高性能代码检查（Linter）和格式化（Formatter）工具。 **target-version**, **line-length**, **exclude**: 基本配置，如目标 Python 版本、每行最大长度和要排除检查的文件。 **[tool.ruff.lint]**: Linter 的具体配置。 **select**: 启用一系列代码规则集（例如 D 代表文档字符串 pydocstyle，I 代表导入排序 isort）。 **ignore**: 全局禁用的特定规则。注释中解释了忽略它们的原因（例如，规则冲突或待办事项）。 **per-file-ignores**: 针对特定文件或目录禁用规则。例如，\"**/tests/*\" = [\"D\"] 表示在所有测试文件中都禁用文档字符串检查。 **[tool.ruff.format]**: 格式化器的配置，如使用空格作为缩进风格。 [tool.pyright]：这部分配置了 Pyright，一个由微软开发的静态类型检查工具。 **typeCheckingMode**: 类型检查的严格程度，这里是 basic（基础模式）。 **exclude**：在进行类型检查时要忽略的文件和目录。 **report...**：关闭特定的错误或警告报告。 [tool.vulture]：这部分配置了 Vulture，一个用于发现项目中未使用（“死”）代码的工具。 **ignore_names**: 让 Vulture 忽略某些特定的变量名或函数名，即使它们看起来未使用。 **min_confidence**: 设置报告问题的最低置信度阈值。100 表示只有在 Vulture 100% 确定代码是无用的时候才会报告，这可以有效减少误报。 1 2 3 4 5 6 7 [project.scripts] chakra_converter = \"chakra.src.converter.converter:main\" chakra_generator = \"chakra.src.generator.generator:main\" chakra_jsonizer = \"chakra.src.jsonizer.jsonizer:main\" chakra_timeline_visualizer = \"chakra.src.timeline_visualizer.timeline_visualizer:main\" chakra_trace_link = \"chakra.src.trace_link.trace_link:main\" chakra_visualizer = \"chakra.src.visualizer.visualizer:main\" Generate Execution Trace ASTRA-sim 的 ET 命名格式为 {path prefix/trace name}.{npu_id}.et. Chakra ET 的获取流程如下图所示1。\nCollect ET from PyTorch PyTorch ET 负责 CPU 算子，并明确表示它们之间的依赖关系。 Kineto Trace 编码 GPU 算子及其开始和结束时间。 Merge Trace by chkra_trace_link：将它们合并为一个 PyTorch ET+. 该格式本质上遵循 PyTorch ET 的模式，但同时也编码了 GPU 操作符及其依赖关系。 Convert to Chakra ET by chakra_converter Overview of Trace Collection 具体的教程和例子可以在 Conversion Guide 和 Practical Example 找到。\nUsing ET Converter 可以将 astra-sim 1.0 的文本输入转换成 Chakra ET.\n1 2 3 4 5 6 7 cd ./extern/graph_frontend/chakra/ pip3 install . chakra_converter Text \\ --input ../../../examples/text_converter/text_workloads/Resnet50_DataParallel.txt \\ --output ../../../examples/text_converter/text_workloads/Resnet50_DataParallel \\ --num-npus 8 \\ --num-passes 1 workload 文本格式要求如下，其中通信大小单位是字节，计算时间以周期数表示。\n第一行：(DATA/HYBRID_TRANSFORMER/HYBRID_DLRM) 该行指定训练循环的并行化类型。DATA 表示纯数据并行方法，HYBRID_TRANSFORMER 表示专为 Transformer DNN 网络设计的混合并行方法，而 HYBRID_DLRM 表示专为 DLRM DNN 网络优化的混合并行方法。 第二行：(int) 该行表示 DNN 的层数。 后续行：每行描述一层。层的描述格式如下： {(string: 层名称) (int: 保留变量) (int: 前向计算时间) (ALLREDUCE/ALLGATHER/ALLTOALL: 前向通信类型) (int: 前向通信大小) (int: 输入梯度计算时间) (ALLREDUCE/ALLGATHER/ALLTOALL: 输入梯度通信类型) (int: 输入梯度通信大小) (int: 权重梯度计算时间) (ALLREDUCE/ALLGATHER/ALLTOALL: 权重梯度通信类型) (int: 权重梯度通信大小) (集合通信完成后，权重/输入/输出更新的延迟)}` Note\n每一层的参数写要在同一行！！！\nEnable Communicator Groups astra-sim 2.0 支持通信组。可以通过指定 --comm-group-configuration JSON 文件来指定，默认只有一个通信组。\n{ // The first/second communicator group, with ID 0/1, includes GPU IDs from 0-3/4-7. // \"0\": [0, 1, 2, 3], // \"1\": [4, 5, 6, 7] \"\" : [gpu_ids] } SYSTEM_CONFIG System Layer Workload 层会遍历 Chakra ET 中的节点，并为每个节点所指代的操作发出相应的命令。System 层接收这些命令，并将其转换为适合网络、计算或内存后端的格式，从而正确模拟操作。根据操作的类型，系统层的行为会有所不同，具体如下：\n计算操作：向计算后端发出调用，以模拟操作的持续时间。 内存操作： 内存 通信操作：将集合通信分解为点对点的发送和接收消息，并向网络后端发出“发送”或“接收”调用，以模拟消息的传输过程。 Collective Scheduler Collective Scheduler\n每个队列都有许多 StreamBaseline 对象 (图中右上角)，代表了整个集合通信的流程，phase_to_go 是一个用于表示这些阶段的队列，my_current_phase 是指向当前执行阶段的指针。\n1 2 3 4 5 6 7 8 9 10 11 12 class StreamBaseline : public BaseStream { public: StreamBaseline(Sys* owner, DataSet* dataset, int stream_id, std::list\u003cCollectivePhase\u003e phases_to_go, int priority); // my_current_phase[CollectivePhase] is defined in BaseStream void init(); void call(EventType event, CallData* data); void consume(RecvPacketEventHandlerData* message); }; 对于每个 stream proceed_to_next_vnet_baseline (astra-sim/system/Sys.cc) 用于推进通信阶段并且负责在队列之间移动 stream 对象。以下几种情况会调用该函数：\nstream 第一次被移动出 ready_list 并且将被插入到 active_streams. stream 完成了一个通信阶段并且等待下一个阶段。 stream 完成了所有的通信阶段。 (2-1) 到 (2-5) 描述了该函数的行为\n查看当前持有 stream 的队列: 从队列中删除 StreamBaseline 对象 (流的完成顺序可能与它们开始执行的顺序不同)。\n修改 StreamBaseline 对象: 已完成的集合通信阶段从 phases_to_go 中弹出，my_current_phase 现在指向下一个待执行的阶段。\n使用 insert_stream 将 StreamBaseline 对象插入到下一个队列中。\n调用函数 notify_stream_removed 函数查看前一个队列的头部。 stream_pointer 指向队列中第一个未运行的 stream (标记为蓝色)。该函数通过调用 StreamBaseline::init() 来启动 stream 的下一个阶段的执行。\n使用 notify_stream_added 触发新队列头部 stream 的通信阶段执行。\n在其他情况下，proceed_to_next_vnet_baseline 会执行上述步骤的一部分。具体如下：\n刚从 ready_list 中移除：\nproceed_to_next.. 会初始化 stream (1-2)，将其插入到第一个队列中 (1-3)，并触发该队列头部的流执行。\nstream 完成：\n该函数会从之前的队列中删除 stream (3-1)，并触发之前队列头部的 stream 执行。此外，StreamBaseline 对象会被删除，并调用 notify_stream_finished，以通知 Sys 对象 stream 已经结束 (3-6)\nCollective Implementation Overview of Collective Implementation 模拟器将集体通信分解为发送和接收消息的方式有两种。目前最常用的方法是模拟器实现一组预定义的常见算法 (例如 Ring、DoubleBinary、HalvingDoubling 等)。这种“原生”实现逻辑位于模拟器的代码库中，允许用户快速探索一组预定义的算法。\n自 2024 年 8 月以来，ASTRA-sim 支持了一种新的集合通信算法表示方式。System 层通过暴露一个集体 API，可以接收任意集体算法的定义。\n这两种方法都是对 CollectivePhase::Algorithm 对象的实现，该对象是 System 层中的调度单元. generate_collective_phase 会根据不同的算法在创建 CollectivePhase 的时候传入对应的 Algorithm.\nASTRA-Sim Native Implementation 相关的实现都位于该文件夹下, naive 实现的限制是当需要模拟一个新的集合通信算法时算法，必须实现整个集合？随着不规则集合通信 (如 TACOS(Topology Aware CollectiveS), MSCCLang(基于 DSL)) 中工作的增加，快速模拟和迭代各种算法的需求变得越来越多。\nChakra Based Arbitrary Definition Through Collective API 因此一个新的 AP来接受任何集合通信算法的定义，而不局限于预定义的规则通信模式。对于通信表示，使用 Chakra ET 模式作为单独的图。将集合通信算法表示为Chakra ET 模式中 COMM_SEND，COMM_RECV 节点的图。也就是说，System 层不是将集合通信分解为发送和接收消息，而是简单地遵循 Chakra 图中已经表示的分解。由于已经使用 Chakra ET 来表示 workload，使用 Chakra ET 来额外定义集合通信算法提供了一种轻松简单的方式来遍历整个图。\n如上图所示当 workload 层发出 AllReduce 集体操作时，System 层不会运行模拟器代码库中已有的原生实现逻辑，而是会遍历通过 API 提供的 Chakra ET，该 ET 表示集合通信算法。需要注意 workload Chakra 图和集合通信算法的 Chakra 图是解耦的，并通过不同的输入点提供。最终，asytra-sim 模拟器会将通信节点替换为集体实现。\nInput Files for Collective API ASTRA-sim Native // ... \"active-chunks-per-dimension\": 1, \"all-reduce-implementation\": [\"ring\"], \"all-gather-implementation\": [\"ring\", \"doubleBinaryTree\"], \"all-to-all-implementation\": [\"ring\", \"doubleBinaryTree\", \"halvingDoubling\"], // ... all-*-implementation 指定了模拟器将如何将给定的集合通信分解为发送和接收消息。All-Gather 操作列表中的两个条目表示模拟器将按两个维度分解 ——第一个维度使用 Ring 算法，第二个维度使用 doubleBinaryTree 算法。\nNative Implementation Requires That the Dimensions for Collective Algorithms Are Same Across All Collectives.\nWarning\nNative 实现要求所有集体操作的维度必须相同。换句话说，如果一个集合通信算法被定义为二维的，那么其他集合通信算法也必须是二维操作。上述只是一个例子。\nCollective API // ... \"active-chunks-per-dimension\": 1, \"all-reduce-implementation-chakra\": [\"/app/hoti2024/demo5/inputs/custom_ring\"], // ... 需要注意这里要使用 all-*-implementation-chakra，而不是 all-*-implementation. 另外 Chakra ET 文件与传递给 workload 层的文件是不同的，每一项的值是 Chakra ET 文件的绝对路径，不包括最后的 {rank}.et 字符串 (类似于 Workload 层输入)。此外，即使有许多维度，列表也只接受一个值。这是因为跨维度通信的概念已经包含在 ET 中。\nCollective API\r参考该仓库实现\rNetwork Backend Analytical Network Backend Analytical Network 模拟器通过数学方程模拟所有网络行为。因此，该后端最适合于大规模分布式平台的建模和仿真。目前支持两种分析模式\ncongestion_unaware analytical network simulator congestion_aware analytical network simulator TTopology Analytical Network 支持三种拓扑结构: Ring, FullConnected, Switch. 并且可以堆叠来表示多维网络。\nBasic Network Building Block\ntopology: [ Ring, Switch ] # 2D topology topology: [ Ring, Ring, Ring ] # 3D topology Example of 2D \u0026 3D Topologies\nNPUs Count 指定了每个维度上的设备数目\nnpus_count: [ 5 ] # 5 NPUs npus_count: [ 4, 2 ] # 4 × 2 = 8 NPUs npus_count: [ 4, 2, 2 ] # 4 × 2 × 2 = 16 NPUs NPUs Count Example\nBandwidth \u0026 Latency latency 定义了每条单向链路的延迟 (ns). bandwidth 定义了每条单向链路的带宽 (GB/s).\nNote\n$1 GB = 2^{30} B$ and $1 s = 10^9 ns$\nns3 backend 下面是用 ns3 后端进行方针的一个执行命令。这里使用了 --network-backend 和 --logical-topology 这两个参数。需要说明的是，Analytical Backend 中仅使用了--network-backend 参数，这是因为分析型后端的逻辑拓扑与物理拓扑是相同的，而 ns3 则允许我们将逻辑拓扑与物理拓扑分离。\n# {NS3_DIR} is the directory of the ns-3 backend. That is, '{ASTRA_SIM_ROOT_DIRECTORY}/extern/network_backend/ns-3' cd \"${NS3_DIR}/build/scratch\" ./ns3.42-AstraSimNetwork-default \\ --workload-configuration=\"${SCRIPT_DIR:?}\"/../../extern/graph_frontend/chakra/one_comm_coll_node_allgather \\ --system-configuration=\"${SCRIPT_DIR:?}\"/../../inputs/system/Switch.json \\ --network-configuration=\"../../../ns-3/scratch/config/config.txt\" \\ --remote-memory-configuration=\"${SCRIPT_DIR:?}\"/../../inputs/remote_memory/analytical/no_memory_expansion.json \\ --logical-topology-configuration=\"${SCRIPT_DIR:?}\"/../../inputs/network/ns3/sample_8nodes_1D.json \\ --comm-group-configuration=\\\"empty\\\" Overview of Trace Collection ↩︎\n",
  "wordCount" : "6842",
  "inLanguage": "en",
  "datePublished": "2025-06-09T13:34:39+08:00",
  "dateModified": "2025-06-13T15:12:24+08:00",
  "author":[{
    "@type": "Person",
    "name": "WITHER"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/blogs/astra-sim/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "WITHER",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="WITHER (Alt + H)">WITHER</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="http://localhost:1313/zh/" title="简体中文"
                            aria-label="简体中文">简体中文</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/" title="🏠 Home">
                    <span>🏠 Home</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/about_me/" title="🙋🏻‍♂️ Me">
                    <span>🙋🏻‍♂️ Me</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/blogs/" title="📚 Blogs">
                    <span>📚 Blogs</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/categories/" title="🧩 Categories">
                    <span>🧩 Categories</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="🔖 Tags">
                    <span>🔖 Tags</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/archives/" title="⏱ Archive">
                    <span>⏱ Archive</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="🔍 Search (Alt &#43; /)" accesskey=/>
                    <span>🔍 Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/friends/" title="🤝 Friends">
                    <span>🤝 Friends</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/blogs/">Blogs</a></div>
    <h1 class="post-title entry-hint-parent">
      astra-Sim
    </h1>
    <div class="post-description">
      source code reading of astra-sim
    </div>
    <div class="post-meta"><span title='2025-06-09 13:34:39 +0800 CST'>Jun-09-2025</span>&nbsp;·&nbsp;14 min&nbsp;·&nbsp;6842 words&nbsp;·&nbsp;WITHER

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">Table of Contents</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#build-analytical-backend" aria-label="Build Analytical Backend">Build Analytical Backend</a></li>
                    <li>
                        <a href="#build-ns-3-backend" aria-label="Build ns-3 Backend">Build ns-3 Backend</a><ul>
                            
                    <li>
                        <a href="#ns3-configure---enable-mpi" aria-label="./ns3 configure --enable-mpi"><code>./ns3 configure --enable-mpi</code></a></li>
                    <li>
                        <a href="#ns3-build-astrasimnetwork--j-12" aria-label="./ns3 build AstraSimNetwork -j 12"><code>./ns3 build AstraSimNetwork -j 12</code></a></li></ul>
                    </li>
                    <li>
                        <a href="#error-when-building-ns-3" aria-label="Error When Building ns-3">Error When Building ns-3</a><ul>
                            
                    <li>
                        <a href="#call-of-overloaded-format-is-ambiguous-" aria-label="call of overloaded ‘format(&hellip;)’ is ambiguous ❌">call of overloaded ‘format(&hellip;)’ is ambiguous ❌</a><ul>
                            
                    <li>
                        <a href="#%e9%97%ae%e9%a2%98%e8%af%8a%e6%96%ad-" aria-label="问题诊断 🩺">问题诊断 🩺</a></li>
                    <li>
                        <a href="#%e5%85%b3%e4%ba%8e-using-fmtformat-%e4%b8%ba%e4%bd%95%e4%bb%8d%e7%84%b6%e6%97%a0%e6%95%88%e7%9a%84%e8%a7%a3%e9%87%8a" aria-label="关于 using fmt::format; 为何仍然无效的解释">关于 <code>using fmt::format;</code> 为何仍然无效的解释</a></li>
                    <li>
                        <a href="#%e7%bb%93%e8%ae%ba%e4%b8%8e%e6%9c%80%e7%bb%88%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88-" aria-label="结论与最终解决方案 ✅">结论与最终解决方案 ✅</a></li></ul>
                    </li></ul>
                    </li>
                    <li>
                        <a href="#runing-arguments" aria-label="Runing Arguments">Runing Arguments</a><ul>
                            
                    <li>
                        <a href="#workload_config" aria-label="WORKLOAD_CONFIG">WORKLOAD_CONFIG</a><ul>
                            
                    <li>
                        <a href="#generate-execution-trace" aria-label="Generate Execution Trace">Generate Execution Trace</a></li>
                    <li>
                        <a href="#using-et-converter" aria-label="Using ET Converter">Using ET Converter</a></li>
                    <li>
                        <a href="#enable-communicator-groups" aria-label="Enable Communicator Groups">Enable Communicator Groups</a></li></ul>
                    </li>
                    <li>
                        <a href="#system_config" aria-label="SYSTEM_CONFIG">SYSTEM_CONFIG</a></li></ul>
                    </li>
                    <li>
                        <a href="#system-layer" aria-label="System Layer">System Layer</a><ul>
                            
                    <li>
                        <a href="#collective-scheduler" aria-label="Collective Scheduler">Collective Scheduler</a></li>
                    <li>
                        <a href="#collective-implementation" aria-label="Collective Implementation">Collective Implementation</a><ul>
                            
                    <li>
                        <a href="#astra-sim-native-implementation" aria-label="ASTRA-Sim Native Implementation">ASTRA-Sim Native Implementation</a></li>
                    <li>
                        <a href="#chakra-based-arbitrary-definition-through-collective-api" aria-label="Chakra Based Arbitrary Definition Through Collective API">Chakra Based Arbitrary Definition Through Collective API</a></li></ul>
                    </li>
                    <li>
                        <a href="#input-files-for-collective-api" aria-label="Input Files for Collective API">Input Files for Collective API</a><ul>
                            
                    <li>
                        <a href="#astra-sim-native" aria-label="ASTRA-sim Native">ASTRA-sim Native</a></li>
                    <li>
                        <a href="#collective-api" aria-label="Collective API">Collective API</a></li></ul>
                    </li></ul>
                    </li>
                    <li>
                        <a href="#network-backend" aria-label="Network Backend">Network Backend</a><ul>
                            
                    <li>
                        <a href="#analytical-network-backend" aria-label="Analytical Network Backend">Analytical Network Backend</a></li>
                    <li>
                        <a href="#ns3-backend" aria-label="ns3 backend">ns3 backend</a>
                    </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    
    document.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();
    
        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
        if (elements.length > 0) {
            
            activeElement = elements[0];
            const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
            document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
        }
    
        
        const topLink = document.getElementById('top-link');
        if (topLink) {
            topLink.addEventListener('click', (event) => {
                
                event.preventDefault();
    
                
                window.scrollTo({ top: 0, behavior: 'smooth' });
            });
        }
    }, false);
    
    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);
    
    window.addEventListener('scroll', () => {
        
        const scrollPosition = window.pageYOffset || document.documentElement.scrollTop;
    
        
        if (scrollPosition === 0) {
            return;
        }
    
        
        if (elements && elements.length > 0) {
            
            activeElement = Array.from(elements).find((element) => {
                if ((getOffsetTop(element) - scrollPosition) > 0 && 
                    (getOffsetTop(element) - scrollPosition) < window.innerHeight / 2) {
                    return element;
                }
            }) || activeElement;
    
            elements.forEach(element => {
                const id = encodeURI(element.getAttribute('id')).toLowerCase();
                const tocLink = document.querySelector(`.inner ul li a[href="#${id}"]`);
                if (element === activeElement){
                    tocLink.classList.add('active');
    
                    
                    const tocContainer = document.querySelector('.toc .inner');
                    const linkOffsetTop = tocLink.offsetTop;
                    const containerHeight = tocContainer.clientHeight;
                    const linkHeight = tocLink.clientHeight;
    
                    
                    const scrollPosition = linkOffsetTop - (containerHeight / 2) + (linkHeight / 2);
                    tocContainer.scrollTo({ top: scrollPosition, behavior: 'smooth' });
                } else {
                    tocLink.classList.remove('active');
                }
            });
        }
    }, false);
    
    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);
    
    function checkTocPosition() {
        const width = document.body.scrollWidth;
    
        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }
    
    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
    
</script>

  <div class="post-content"><h1 id="build-analytical-backend">Build Analytical Backend<a hidden class="anchor" aria-hidden="true" href="#build-analytical-backend">#</a></h1>
<p><code>build.sh</code> 脚本是构建过程的高级控制器。其核心职责是解析用户意图，执行预构建步骤，并以正确的参数调用底层的 CMake 工具链。</p>
<ol>
<li>
<p><strong>选项解析</strong>: 脚本通过 <code>getopts</code> 处理以下命令行标志：</p>
<ul>
<li><code>-t &lt;target&gt;</code>: 指定编译目标。有效值为 <code>all</code>, <code>congestion_unaware</code>, <code>congestion_aware</code>。此值将作为变量传递给 CMake。</li>
<li><code>-l</code>: 触发清理 (<code>cleanup</code>) 流程，删除所有构建产物并终止脚本。</li>
<li><code>-d</code>: 启用调试 (<code>Debug</code>) 模式进行编译。</li>
</ul>
</li>
<li>
<p><strong>环境准备 (<code>setup</code>, <code>compile_chakra_et</code>)</strong>:</p>
<ul>
<li><code>setup</code> 函数负责创建用于存放中间文件和最终产物的 <code>build</code> 目录，确保源码树的清洁。同时，它会根据系统核心数设置一个上限为 16 的并发编译线程数，以优化编译效率。</li>
<li><code>compile_chakra_et</code> 函数负责处理 <code>et_def.proto</code> 这一 Protobuf 依赖。它检查目标文件是否存在，若不存在，则调用 <code>protoc</code> 编译器生成相应的 C++ 和 Python 源码。</li>
</ul>
</li>
<li>
<p><strong>构建执行 (<code>compile_astrasim_analytical</code>, <code>compile_astrasim_analytical_as_debug</code>)</strong>:</p>
<ul>
<li>这两个函数是脚本与 CMake 交互的核心。它们根据用户是否指定 <code>-d</code> 标志，决定是执行标准 <code>Release</code> 构建还是 <code>Debug</code> 构建。关键在于它们会将用户指定的 <code>build_target</code> 作为 <code>-DBUILDTARGET</code> 参数传递给 CMake。</li>
</ul>
</li>
<li>
<p><strong>后处理 (<code>create_symlink_*</code>)</strong>:</p>
<ul>
<li>编译完成后，<code>create_symlink_congestion_unaware</code> 和 <code>create_symlink_congestion_aware</code> 等函数会为生成的二进制文件创建符号链接。此举旨在维持对旧文件路径的向后兼容性。</li>
</ul>
</li>
</ol>
<hr>
<p><code>CMakeLists.txt</code> 文件是项目的构建蓝图，它向 CMake 阐述了项目的结构、依赖关系以及编译规则。</p>
<ol>
<li>
<p><strong>编译环境设定</strong>:</p>
<ul>
<li><code>cmake_minimum_required(VERSION 3.15)</code>: 规定了运行此配置所需的最低 CMake 版本。</li>
<li><code>set(CMAKE_CXX_STANDARD 17)</code> 和 <code>set(CMAKE_CXX_STANDARD_REQUIRED ON)</code>: 强制项目必须在支持 C++17 标准的编译环境中构建。</li>
</ul>
</li>
<li>
<p><strong>编译标志 (Compiler Flags)</strong>:</p>
<ul>
<li>此文件为不同的构建类型（<code>CMAKE_BUILD_TYPE</code>）定义了不同的编译器标志。</li>
<li><strong><code>Release</code></strong> (默认模式): <code>set(CMAKE_CXX_FLAGS_RELEASE &quot;-O3&quot;)</code> 指示编译器进行高等级优化，以追求最大化程序性能。</li>
<li><strong><code>Debug</code></strong>: <code>set(CMAKE_CXX_FLAGS_DEBUG &quot;...&quot;)</code> 包含一系列用于调试的标志：
<ul>
<li><code>-O0</code>: 关闭所有优化，确保编译后的代码与源码行为一致。</li>
<li><code>-g</code>: 在可执行文件中包含调试符号，这是 GDB 等调试器工作的前提。</li>
<li><code>-fsanitize=address,undefined,leak</code>: 启用 AddressSanitizer、UndefinedBehaviorSanitizer 和 LeakSanitizer。这些是强大的运行时诊断工具，用于捕获内存访问错误、未定义行为及内存泄漏。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>项目结构与依赖</strong>:</p>
<ul>
<li><code>project(AstraSim_Analytical)</code>: 声明项目名称。</li>
<li><code>add_subdirectory(...)</code>: 此指令是组织项目的关键。它将 <code>AstraSim</code> 核心库、<code>Analytical</code> 网络后端和 <code>AstraSim_Analytical</code> 前端等多个子模块纳入构建过程。</li>
</ul>
</li>
<li>
<p><strong>用户自定义选项</strong>:</p>
<ul>
<li><code>set(BUILDTARGET &quot;all&quot; CACHE STRING ...)</code>: 此行定义了一个名为 <code>BUILDTARGET</code> 的可缓存变量。这使得用户可以通过 <code>cmake -D</code> 命令从外部注入该变量的值。此变量随后会被子目录中的 <code>CMakeLists.txt</code> 文件用来实现条件编译。</li>
</ul>
</li>
</ol>
<h1 id="build-ns-3-backend">Build ns-3 Backend<a hidden class="anchor" aria-hidden="true" href="#build-ns-3-backend">#</a></h1>
<p>构建命令为 <code>./build/astra_ns3/build.sh -c</code>，他会执行该脚本里的 compile 函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="k">function</span> compile <span class="o">{</span>
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> <span class="s2">&#34;</span><span class="si">${</span><span class="nv">NS3_DIR</span><span class="si">}</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl">./ns3 configure --enable-mpi
</span></span><span class="line"><span class="cl">./ns3 build AstraSimNetwork -j <span class="m">12</span>
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> <span class="s2">&#34;</span><span class="si">${</span><span class="nv">SCRIPT_DIR</span><span class="p">:?</span><span class="si">}</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="ns3-configure---enable-mpi"><code>./ns3 configure --enable-mpi</code><a hidden class="anchor" aria-hidden="true" href="#ns3-configure---enable-mpi">#</a></h2>
<ol>
<li>参数解析 (<code>parse_args</code>): 脚本的 <code>argparse</code> 模块会识别出 <code>configure</code> 子命令和 <code>--enable-mpi</code> 选项。<code>--enable-mpi</code> 是一个预定义的&quot;On-Off&quot;选项，用于控制 MPI (Message Passing Interface) 分布式仿真功能的支持。</li>
<li>进入配置步骤 (<code>configuration_step</code>): 由于检测到 configure 命令，脚本会调用 <code>configuration_step</code> 函数。</li>
<li>调用 CMake (<code>configure_cmake</code>): <code>configuration_step</code> 函数内部会调用 <code>configure_cmake</code>. 这个函数是会动态地构建一个 cmake 命令。
<ul>
<li>它会检测到 <code>--enable-mpi</code> 选项，并通过 <code>on_off_condition</code> 函数将其转换为 CMake 变量 <code>-DNS3_MPI=ON</code>.</li>
<li>最终组装出的命令为为 <code>cmake -S . -B cmake-cache -G &quot;Unix Makefiles&quot; -DCMAKE_BUILD_TYPE=default -DNS3_ASSERT=ON -DNS3_LOG=ON -DNS3_WARNINGS_AS_ERRORS=OFF -DNS3_MPI=ON --warn-uninitialized</code></li>
</ul>
</li>
<li>执行配置: 脚本通过 <code>subprocess.run()</code> 执行这条 cmake 命令</li>
</ol>
<h2 id="ns3-build-astrasimnetwork--j-12"><code>./ns3 build AstraSimNetwork -j 12</code><a hidden class="anchor" aria-hidden="true" href="#ns3-build-astrasimnetwork--j-12">#</a></h2>
<ol>
<li>参数解析 (<code>parse_args</code>): 脚本识别出 <code>build</code> 子命令，目标 <code>AstraSimNetwork</code>，以及并行任务数 <code>-j 12</code>. 前者会被存入 <code>args.build</code> 列表，后者会被存入 <code>args.jobs</code>.</li>
<li>进入构建步骤 (<code>build_step</code>): 脚本检测到 <code>build</code> 命令，并调用 <code>build_step</code> 函数。</li>
<li>调用 CMake 构建 (<code>cmake_build</code>): <code>build_step</code> 函数会遍历 <code>args.build</code> 列表中的所有目标。在这里，它会为 <code>AstraSimNetwork</code> 这个目标调用 <code>cmake_build</code> 函数。
<ul>
<li>cmake_build 函数会组装出一条 <code>cmake --build</code> 命令。</li>
<li>将目标 AstraSimNetwork 转换为 <code>--target AstraSimNetwork</code>.</li>
<li>将并行任务数 12 转换为 <code>-j 12</code>.</li>
<li>最终组装出的命令为 <code>cmake --build cmake-cache --target AstraSimNetwork -j 12</code>.</li>
</ul>
</li>
</ol>
<h1 id="error-when-building-ns-3">Error When Building ns-3<a hidden class="anchor" aria-hidden="true" href="#error-when-building-ns-3">#</a></h1>
<h2 id="call-of-overloaded-format-is-ambiguous-">call of overloaded ‘format(&hellip;)’ is ambiguous ❌<a hidden class="anchor" aria-hidden="true" href="#call-of-overloaded-format-is-ambiguous-">#</a></h2>
<h3 id="问题诊断-">问题诊断 🩺<a hidden class="anchor" aria-hidden="true" href="#问题诊断-">#</a></h3>
<p>错误信息 <code>call of overloaded ‘format(...)’ is ambiguous</code> 的意思是，编译器在你的代码中遇到了一个名为 <code>format</code> 的函数调用，但它找到了多个同名的、并且参数类型都能匹配的 <code>format</code> 函数定义，导致编译器不知道该选择哪一个，因此产生了“歧义”（ambiguous）。</p>
<p><strong>这个歧义的来源是：</strong></p>
<ol>
<li><strong><code>std::format</code> (来自 C++20 标准库)</strong>: 你的项目很可能正在使用支持 C++20 或更高版本的现代编译器（如 GCC 11+）。C++20 标准库引入了一个新的格式化函数 <code>std::format</code>。</li>
<li><strong><code>fmt::format</code> (来自 {fmt} 库)</strong>: <code>spdlog</code> 这个日志库是基于一个非常流行的第三方格式化库 <code>{fmt}</code> 构建的。这个库也提供了一个功能几乎完全相同的 <code>fmt::format</code> 函数。在 <code>spdlog</code> 的上下文中，它通常可以直接以 <code>format</code> 的形式被调用。</li>
</ol>
<p>当你的代码（这里是 <code>spdlog_setup</code> 的一部分）简单地调用 <code>format(...)</code> 时，如果 C++20 的 <code>&lt;format&gt;</code> 头文件被包含，编译器就会同时看到 <code>std::format</code> 和 <code>spdlog</code> 内部的 <code>fmt::format</code>。由于两者都能处理字符串字面量 (<code>const char[]</code>) 和 <code>std::string</code>，编译器无法决定用哪个，从而报错。</p>
<hr>
<h3 id="关于-using-fmtformat-为何仍然无效的解释">关于 <code>using fmt::format;</code> 为何仍然无效的解释<a hidden class="anchor" aria-hidden="true" href="#关于-using-fmtformat-为何仍然无效的解释">#</a></h3>
<p>原因是，除了常规的命名空间查找规则，C++ 还有一个更强大的规则叫做<strong>参数依赖查找（Argument-Dependent Lookup, ADL）</strong>，有时也被称为 Koenig 查找。</p>
<hr>
<p>我们来梳理一下编译器在看到 <code>format(...)</code> 这行代码时的“思考过程”：</p>
<ol>
<li>
<p><strong>在当前作用域查找</strong></p>
<p>编译器看到了你的 <code>using fmt::format;</code> 声明。很好，它在当前作用域里找到了一个叫做 <code>format</code> 的函数（也就是 <code>fmt::format</code>）。这成为了<strong>候选者 A</strong>。</p>
</li>
<li>
<p><strong>参数依赖查找 (ADL) —— 问题的根源</strong></p>
<p>接下来，编译器会检查 <code>format(...)</code> 函数的所有参数类型。在你的错误日志里，我们看到了 <code>const std::string&amp;</code> 这样的参数。</p>
<ul>
<li>ADL 规则规定：如果一个函数的参数是某个命名空间 <code>N</code> 下的类型（比如 <code>std::string</code> 是 <code>std</code> 命名空间下的），那么编译器<strong>也必须</strong>去那个命名空间 <code>N</code> (这里是 <code>std</code>) 里面去查找同名的函数。</li>
<li>由于 <code>std::string</code> 是 <code>std</code> 命名空间的成员，ADL 规则被触发，编译器自动地去 <code>std</code> 命名空间里寻找名为 <code>format</code> 的函数。</li>
<li>因为你使用了 C++20 编译器，它在 <code>std</code> 命名空间里成功找到了 <code>std::format</code>。这成为了<strong>候选者 B</strong>。</li>
</ul>
</li>
<li>
<p><strong>产生歧义</strong></p>
<p>现在编译器陷入了困境。它手头有两个同样匹配的候选函数：</p>
<ul>
<li><strong>候选者 A</strong>: <code>fmt::format</code> (通过 <code>using</code> 声明找到)</li>
<li><strong>候选者 B</strong>: <code>std::format</code> (通过 ADL 在参数的命名空间里找到)</li>
</ul>
<p><code>using</code> 声明只是将一个名字引入当前作用域，它并**没有足够的“特权”**去压制一个通过 ADL 找到的同样优秀的候选者。因为两个函数都能完美处理你传入的参数，编译器无法做出选择，所以它只能放弃并报告“调用是模糊的 (ambiguous)”。</p>
</li>
</ol>
<h3 id="结论与最终解决方案-">结论与最终解决方案 ✅<a hidden class="anchor" aria-hidden="true" href="#结论与最终解决方案-">#</a></h3>
<p>这个 C++ 的特性意味着，只要你的函数参数中包含了 <code>std</code> 命名空间里的类型（如 <code>std::string</code>, <code>std::vector</code> 等），ADL 就有可能被触发，从而把 <code>std</code> 里的函数（如 <code>std::format</code>, <code>std::to_string</code> 等）也拉入候选列表，造成意想不到的冲突。</p>
<p>因此，唯一能 100% 消除歧义、让编译器别无选择的方法，就是使用<strong>显式的命名空间限定</strong>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 这样做，是在直接告诉编译器：“别去猜了，我就是要调用 fmt 命名空间里的这个 format！”
</span></span></span><span class="line"><span class="cl"><span class="c1">// 这会完全绕过 ADL 和其他查找规则，直达目标。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">fmt</span><span class="o">::</span><span class="n">format</span><span class="p">(...);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="runing-arguments">Runing Arguments<a hidden class="anchor" aria-hidden="true" href="#runing-arguments">#</a></h1>
<p>执行仿真需要传递一些参数，命令模板如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">{</span>ASTRA_SIM_BIN<span class="o">}</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  --workload-configuration<span class="o">=</span><span class="si">${</span><span class="nv">WORKLOAD_CONFIG</span><span class="si">}</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  --system-configuration<span class="o">=</span><span class="si">${</span><span class="nv">SYSTEM_CONFIG</span><span class="si">}</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  --network-configuration<span class="o">=</span><span class="si">${</span><span class="nv">NETWORK_CONFIG</span><span class="si">}</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  --remote-memory-configuration<span class="o">=</span><span class="si">${</span><span class="nv">REMOTE_MEMORY_CONFIG</span><span class="si">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="workload_config">WORKLOAD_CONFIG<a hidden class="anchor" aria-hidden="true" href="#workload_config">#</a></h2>
<p>astra-sim 使用的是 Chakra (Execution Trace) 作为 workload 层的输入。将 chakra 作为 python package 安装后有几个命令通过 pyproject.toml 对应到 python函数。</p>
<details class="custom-details">
    <summary class="custom-summary">Explanation of toml file</summary>
    <div><p><code>pyproject.toml</code> 是一个标准化的配置文件，用于定义 Python 项目的元数据、依赖关系以及构建和开发工具的配置。</p>
<hr>
<ol>
<li><code>[build-system]</code> 构建系统配置，这部分定义了如何构建你的 Python 包。</li>
</ol>
<ul>
<li><code>**requires**</code>: 列出了构建项目本身所必需的包。这些是构建环境的依赖，而不是你代码运行时的依赖。
<ul>
<li><code>setuptools</code>, <code>setuptools-grpc</code>: 表明此项目使用 <code>setuptools</code> 作为其构建工具，并需要 <code>setuptools-grpc</code> 插件。</li>
</ul>
</li>
<li><code>**build-backend**</code>: 指定了构建工具中实际执行构建过程的 Python 对象（入口点）。
<ul>
<li><code>setuptools.build_meta</code>: 这是 <code>setuptools</code> 提供的标准构建后端。</li>
</ul>
</li>
</ul>
<hr>
<ol start="2">
<li><code>[project]</code>：这部分包含了项目的基本信息，这些信息会展示在 PyPI (Python Package Index) 上。</li>
</ol>
<ul>
<li><code>**name**</code>: 包的名称，即 <code>pip install chakra</code> 中的 <code>chakra</code>。</li>
<li><code>**requires-python**</code>: 运行此包所需的最低 Python 版本，这里是 <code>3.7</code> 或更高。</li>
<li><code>**version**</code>: 当前包的版本号。</li>
<li><code>**readme**</code>: 指向一个文件，该文件的内容将作为项目在 PyPI 上的详细描述。</li>
<li><code>**license**</code>: 指向包含许可证信息的文件。</li>
<li><code>**authors**</code>：项目的作者信息。</li>
<li><code>**dependencies**</code>: <strong>项目运行时的依赖项</strong>。当用户 <code>pip install chakra</code> 时，这些包也会被一并安装。
<ul>
<li><code>protobuf==5.*</code>: 需要版本为 5.x 的 <code>protobuf</code> 库。</li>
<li><code>graphviz</code>, <code>networkx</code>, <code>pydot</code>: 其他标准的第三方库依赖。</li>
<li><code>HolisticTraceAnalysis @ git+...</code>: 这是一个特殊的依赖。它直接从 GitHub 仓库的一个<strong>特定 commit</strong> (<code>d731cc...</code>) 来安装。这确保了项目依赖于一个稳定且不会意外变动的版本。</li>
</ul>
</li>
</ul>
<hr>
<ol start="3">
<li><code>[project.urls]</code>：项目相关链接，这些链接会显示在 PyPI 页面的侧边栏，为用户提供更多信息的入口。</li>
</ol>
<ul>
<li><code>**Homepage**</code>, <code>**Documentation**</code>, <code>**Repository**</code>: 分别指向项目主页、文档和代码仓库的 URL。</li>
</ul>
<hr>
<ol start="4">
<li><code>[tool.setuptools]</code>：这部分是针对构建工具 <code>setuptools</code> 的详细配置。</li>
</ol>
<ul>
<li><code>**package-dir**</code>: 定义了 Python 包名与实际源代码目录之间的映射关系。
<ul>
<li>例如，<code>&quot;chakra.src.converter&quot; = &quot;src/converter&quot;</code> 表示当用户 <code>import chakra.src.converter</code> 时，Python 会从 <code>src/converter/</code> 目录下寻找代码。这使得项目可以使用 <code>src</code> 布局。</li>
</ul>
</li>
<li><code>**package-data**</code>: 指定需要包含在最终发布包中的非 Python 文件。
<ul>
<li><code>&quot;chakra.schema.protobuf&quot; = [&quot;et_def.proto&quot;]</code>: 表示需要将 <code>et_def.proto</code> 这个文件打包到 <code>chakra.schema.protobuf</code> 这个包里。</li>
</ul>
</li>
</ul>
<hr>
<ol start="5">
<li><code>[project.scripts]</code>：这部分定义了在安装包时应创建的命令行工具。</li>
</ol>
<ul>
<li><code>**chakra_converter = &quot;chakra.src.converter.converter:main&quot;**</code>: 这行配置意味着，当用户安装此包后，他们可以在终端中直接运行 <code>chakra_converter</code> 命令。执行此命令时，系统会调用 <code>chakra.src.converter.converter</code> 模块中的 <code>main</code> 函数。</li>
</ul>
<hr>
<ol start="6">
<li><code>[tool.ruff]</code>：这部分是用于配置 <code>Ruff</code> 高性能代码检查（Linter）和格式化（Formatter）工具。</li>
</ol>
<ul>
<li><code>**target-version**</code>, <code>**line-length**</code>, <code>**exclude**</code>: 基本配置，如目标 Python 版本、每行最大长度和要排除检查的文件。</li>
<li><code>**[tool.ruff.lint]**</code>: Linter 的具体配置。
<ul>
<li><code>**select**</code>: 启用一系列代码规则集（例如 <code>D</code> 代表文档字符串 <code>pydocstyle</code>，<code>I</code> 代表导入排序 <code>isort</code>）。</li>
<li><code>**ignore**</code>: 全局禁用的特定规则。注释中解释了忽略它们的原因（例如，规则冲突或待办事项）。</li>
<li><code>**per-file-ignores**</code>: 针对特定文件或目录禁用规则。例如，<code>&quot;**/tests/*&quot; = [&quot;D&quot;]</code> 表示在所有测试文件中都禁用文档字符串检查。</li>
</ul>
</li>
<li><code>**[tool.ruff.format]**</code>: 格式化器的配置，如使用空格作为缩进风格。</li>
</ul>
<hr>
<ol start="7">
<li><code>[tool.pyright]</code>：这部分配置了 <code>Pyright</code>，一个由微软开发的静态类型检查工具。</li>
</ol>
<ul>
<li><code>**typeCheckingMode**</code>: 类型检查的严格程度，这里是 <code>basic</code>（基础模式）。</li>
<li><code>**exclude**</code>：在进行类型检查时要忽略的文件和目录。</li>
<li><code>**report...**</code>：关闭特定的错误或警告报告。</li>
</ul>
<hr>
<ol start="8">
<li><code>[tool.vulture]</code>：这部分配置了 <code>Vulture</code>，一个用于发现项目中未使用（&ldquo;死&rdquo;）代码的工具。</li>
</ol>
<ul>
<li><code>**ignore_names**</code>: 让 Vulture 忽略某些特定的变量名或函数名，即使它们看起来未使用。</li>
<li><code>**min_confidence**</code>: 设置报告问题的最低置信度阈值。<code>100</code> 表示只有在 Vulture 100% 确定代码是无用的时候才会报告，这可以有效减少误报。</li>
</ul></div>
</details><br>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-toml" data-lang="toml"><span class="line"><span class="cl"><span class="p">[</span><span class="nx">project</span><span class="p">.</span><span class="nx">scripts</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">chakra_converter</span> <span class="p">=</span> <span class="s2">&#34;chakra.src.converter.converter:main&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nx">chakra_generator</span> <span class="p">=</span> <span class="s2">&#34;chakra.src.generator.generator:main&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nx">chakra_jsonizer</span> <span class="p">=</span> <span class="s2">&#34;chakra.src.jsonizer.jsonizer:main&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nx">chakra_timeline_visualizer</span> <span class="p">=</span> <span class="s2">&#34;chakra.src.timeline_visualizer.timeline_visualizer:main&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nx">chakra_trace_link</span> <span class="p">=</span> <span class="s2">&#34;chakra.src.trace_link.trace_link:main&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nx">chakra_visualizer</span> <span class="p">=</span> <span class="s2">&#34;chakra.src.visualizer.visualizer:main&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="generate-execution-trace">Generate Execution Trace<a hidden class="anchor" aria-hidden="true" href="#generate-execution-trace">#</a></h3>
<p>ASTRA-sim 的 ET 命名格式为 <code>{path prefix/trace name}.{npu_id}.et</code>. Chakra ET 的获取流程如下图所示<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>。</p>
<ol>
<li>Collect ET from PyTorch
<ul>
<li>PyTorch ET 负责 CPU 算子，并明确表示它们之间的依赖关系。</li>
<li>Kineto Trace 编码 GPU 算子及其开始和结束时间。</li>
</ul>
</li>
<li>Merge Trace by <code>chkra_trace_link</code>：将它们合并为一个 PyTorch ET+. 该格式本质上遵循 PyTorch ET 的模式，但同时也编码了 GPU 操作符及其依赖关系。</li>
<li>Convert to Chakra ET by <code>chakra_converter</code>

<figure class="post-figure">
    <a href="https://private-user-images.githubusercontent.com/7621438/294028976-67228699-cec5-4a4d-b03e-e76647a80ce8.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3NDk1NDQxNDUsIm5iZiI6MTc0OTU0Mzg0NSwicGF0aCI6Ii83NjIxNDM4LzI5NDAyODk3Ni02NzIyODY5OS1jZWM1LTRhNGQtYjAzZS1lNzY2NDdhODBjZTgucG5nP1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9QUtJQVZDT0RZTFNBNTNQUUs0WkElMkYyMDI1MDYxMCUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyNTA2MTBUMDgyNDA1WiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9OWE4NzAyMGQ0NWQ0MDA2MzIzMmY1MmNhYWU4YWUzNTJiNjI3OTAzZDk2ZDU3NDIwMWJhZTFlMjNjZDhjN2JmMyZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QifQ.-DDH2mackHVASqoCbmyvN2xl8vZemaa73OiLmBER1o0" target="_blank" rel="noopener">
        <img loading="lazy" src="https://private-user-images.githubusercontent.com/7621438/294028976-67228699-cec5-4a4d-b03e-e76647a80ce8.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3NDk1NDQxNDUsIm5iZiI6MTc0OTU0Mzg0NSwicGF0aCI6Ii83NjIxNDM4LzI5NDAyODk3Ni02NzIyODY5OS1jZWM1LTRhNGQtYjAzZS1lNzY2NDdhODBjZTgucG5nP1gtQW16LUFsZ29yaXRobT1BV1M0LUhNQUMtU0hBMjU2JlgtQW16LUNyZWRlbnRpYWw9QUtJQVZDT0RZTFNBNTNQUUs0WkElMkYyMDI1MDYxMCUyRnVzLWVhc3QtMSUyRnMzJTJGYXdzNF9yZXF1ZXN0JlgtQW16LURhdGU9MjAyNTA2MTBUMDgyNDA1WiZYLUFtei1FeHBpcmVzPTMwMCZYLUFtei1TaWduYXR1cmU9OWE4NzAyMGQ0NWQ0MDA2MzIzMmY1MmNhYWU4YWUzNTJiNjI3OTAzZDk2ZDU3NDIwMWJhZTFlMjNjZDhjN2JmMyZYLUFtei1TaWduZWRIZWFkZXJzPWhvc3QifQ.-DDH2mackHVASqoCbmyvN2xl8vZemaa73OiLmBER1o0" alt="Overview of Trace Collection">
    </a><figcaption>Overview of Trace Collection</figcaption></figure></li>
</ol>
<p>具体的教程和例子可以在 <a href="https://github.com/mlcommons/chakra/wiki/Chakra-Execution-Trace-Collection-%E2%80%90-A-Comprehensive-Guide-on-Merging-PyTorch-and-Kineto-Traces#3-from-raw-traces-to-chakra-a-step-by-step-conversion-guide">Conversion Guide</a> 和 <a href="https://github.com/mlcommons/chakra/wiki/Chakra-Execution-Trace-Collection-%E2%80%90-A-Comprehensive-Guide-on-Merging-PyTorch-and-Kineto-Traces#3-from-raw-traces-to-chakra-a-step-by-step-conversion-guide">Practical Example</a> 找到。</p>
<h3 id="using-et-converter">Using ET Converter<a hidden class="anchor" aria-hidden="true" href="#using-et-converter">#</a></h3>
<p>可以将 astra-sim 1.0 的文本输入转换成 Chakra ET.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nb">cd</span> ./extern/graph_frontend/chakra/
</span></span><span class="line"><span class="cl">pip3 install .
</span></span><span class="line"><span class="cl">chakra_converter Text <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --input ../../../examples/text_converter/text_workloads/Resnet50_DataParallel.txt <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --output ../../../examples/text_converter/text_workloads/Resnet50_DataParallel <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --num-npus <span class="m">8</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    --num-passes <span class="m">1</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>workload 文本格式要求如下，其中通信大小单位是字节，计算时间以周期数表示。</p>
<ul>
<li>第一行：(DATA/HYBRID_TRANSFORMER/HYBRID_DLRM)
<ul>
<li>该行指定训练循环的并行化类型。DATA 表示纯数据并行方法，HYBRID_TRANSFORMER 表示专为 Transformer DNN 网络设计的混合并行方法，而 HYBRID_DLRM 表示专为 DLRM DNN 网络优化的混合并行方法。</li>
</ul>
</li>
<li>第二行：(int)
<ul>
<li>该行表示 DNN 的层数。</li>
</ul>
</li>
<li>后续行：每行描述一层。层的描述格式如下：
<ul>
<li>{(string: 层名称)</li>
<li>(int: 保留变量)</li>
<li>(int: 前向计算时间)</li>
<li>(ALLREDUCE/ALLGATHER/ALLTOALL: 前向通信类型)</li>
<li>(int: 前向通信大小)</li>
<li>(int: 输入梯度计算时间)</li>
<li>(ALLREDUCE/ALLGATHER/ALLTOALL: 输入梯度通信类型)</li>
<li>(int: 输入梯度通信大小)</li>
<li>(int: 权重梯度计算时间)</li>
<li>(ALLREDUCE/ALLGATHER/ALLTOALL: 权重梯度通信类型)</li>
<li>(int: 权重梯度通信大小)</li>
<li>(集合通信完成后，权重/输入/输出更新的延迟)}`</li>
</ul>
</li>
</ul>
<style type="text/css">
     
    .notice {
        --title-color: #fff;
        --title-background-color: #6be;
        --content-color: #444;
        --content-background-color: #e7f2fa;
    }

    .notice.info {
        --title-background-color: #fb7;
        --content-background-color: #fec;
    }

    .notice.tip {
        --title-background-color: #5a5;
        --content-background-color: #efe;
    }

    .notice.warning {
        --title-background-color: #c33;
        --content-background-color: #fee;
    }

     
    @media (prefers-color-scheme:dark) {
        .notice {
            --title-color: #fff;
            --title-background-color: #069;
            --content-color: #ddd;
            --content-background-color: #023;
        }

        .notice.info {
            --title-background-color: #a50;
            --content-background-color: #420;
        }

        .notice.tip {
            --title-background-color: #363;
            --content-background-color: #121;
        }

        .notice.warning {
            --title-background-color: #800;
            --content-background-color: #400;
        }
    }

    body.dark .notice {
        --title-color: #fff;
        --title-background-color: #069;
        --content-color: #ddd;
        --content-background-color: #023;
    }

    body.dark .notice.info {
        --title-background-color: #a50;
        --content-background-color: #420;
    }

    body.dark .notice.tip {
        --title-background-color: #363;
        --content-background-color: #121;
    }

    body.dark .notice.warning {
        --title-background-color: #800;
        --content-background-color: #400;
    }

     
    .notice {
        padding: 18px;
        line-height: 24px;
        margin-bottom: 24px;
        border-radius: 4px;
        color: var(--content-color);
        background: var(--content-background-color);
    }

    .notice p:last-child {
        margin-bottom: 0
    }

     
    .notice-title {
        margin: -18px -18px 12px;
        padding: 4px 18px;
        border-radius: 4px 4px 0 0;
        font-weight: 700;
        color: var(--title-color);
        background: var(--title-background-color);
    }

     
    .icon-notice {
        display: inline-flex;
        align-self: center;
        margin-right: 8px;
    }

    .icon-notice img,
    .icon-notice svg {
        height: 1em;
        width: 1em;
        fill: currentColor;
    }

    .icon-notice img,
    .icon-notice.baseline svg {
        top: .125em;
        position: relative;
    }
</style><div class="notice note" >
    <p class="notice-title">
        <span class="icon-notice baseline">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 128 300 300">
  <path d="M150 128c82.813 0 150 67.188 150 150 0 82.813-67.188 150-150 150C67.187 428 0 360.812 0 278c0-82.813 67.188-150 150-150Zm25 243.555v-37.11c0-3.515-2.734-6.445-6.055-6.445h-37.5c-3.515 0-6.445 2.93-6.445 6.445v37.11c0 3.515 2.93 6.445 6.445 6.445h37.5c3.32 0 6.055-2.93 6.055-6.445Zm-.39-67.188 3.515-121.289c0-1.367-.586-2.734-1.953-3.516-1.172-.976-2.93-1.562-4.688-1.562h-42.968c-1.758 0-3.516.586-4.688 1.563-1.367.78-1.953 2.148-1.953 3.515l3.32 121.29c0 2.734 2.93 4.882 6.64 4.882h36.134c3.515 0 6.445-2.148 6.64-4.883Z"/>
</svg>

        </span>Note</p><p>每一层的参数写要在同一行！！！</p></div>

<h3 id="enable-communicator-groups">Enable Communicator Groups<a hidden class="anchor" aria-hidden="true" href="#enable-communicator-groups">#</a></h3>
<p>astra-sim 2.0 支持<a href="https://docs.nvidia.com/deeplearning/nccl/user-guide/docs/usage/communicators.html">通信组</a>。可以通过指定 <code>--comm-group-configuration</code> JSON 文件来指定，默认只有一个通信组。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">// The first/second communicator group, with ID 0/1, includes GPU IDs from 0-3/4-7. 
</span></span></span><span class="line"><span class="cl"><span class="c1">//   &#34;0&#34;: [0, 1, 2, 3],
</span></span></span><span class="line"><span class="cl"><span class="c1">//   &#34;1&#34;: [4, 5, 6, 7]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nt">&#34;&lt;communicator_group_id&gt;&#34;</span> <span class="p">:</span> <span class="p">[</span><span class="err">gpu_ids</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="system_config">SYSTEM_CONFIG<a hidden class="anchor" aria-hidden="true" href="#system_config">#</a></h2>
<h1 id="system-layer">System Layer<a hidden class="anchor" aria-hidden="true" href="#system-layer">#</a></h1>
<p>Workload 层会遍历 Chakra ET 中的节点，并为每个节点所指代的操作发出相应的命令。System 层接收这些命令，并将其转换为适合网络、计算或内存后端的格式，从而正确模拟操作。根据操作的类型，系统层的行为会有所不同，具体如下：</p>
<ul>
<li>计算操作：向计算后端发出调用，以模拟操作的持续时间。</li>
<li>内存操作：  内存</li>
<li>通信操作：将集合通信分解为点对点的发送和接收消息，并向网络后端发出“发送”或“接收”调用，以模拟消息的传输过程。</li>
</ul>
<h2 id="collective-scheduler">Collective Scheduler<a hidden class="anchor" aria-hidden="true" href="#collective-scheduler">#</a></h2>
<p>
<figure class="post-figure">
    <a href="https://astra-sim.github.io/astra-sim-docs/_images/system_overview_queue.svg" target="_blank" rel="noopener">
        <img loading="lazy" src="https://astra-sim.github.io/astra-sim-docs/_images/system_overview_queue.svg" alt="Collective Scheduler">
    </a><figcaption>Collective Scheduler</figcaption></figure></p>
<p>每个队列都有许多 <code>StreamBaseline</code> 对象 (图中右上角)，代表了整个集合通信的流程，<code>phase_to_go</code> 是一个用于表示这些阶段的队列，<code>my_current_phase</code> 是指向当前执行阶段的指针。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">StreamBaseline</span> <span class="o">:</span> <span class="k">public</span> <span class="n">BaseStream</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">StreamBaseline</span><span class="p">(</span><span class="n">Sys</span><span class="o">*</span> <span class="n">owner</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                   <span class="n">DataSet</span><span class="o">*</span> <span class="n">dataset</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                   <span class="kt">int</span> <span class="n">stream_id</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                   <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">CollectivePhase</span><span class="o">&gt;</span> <span class="n">phases_to_go</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                   <span class="kt">int</span> <span class="n">priority</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// my_current_phase[CollectivePhase] is defined in BaseStream
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="nf">init</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">call</span><span class="p">(</span><span class="n">EventType</span> <span class="n">event</span><span class="p">,</span> <span class="n">CallData</span><span class="o">*</span> <span class="n">data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">consume</span><span class="p">(</span><span class="n">RecvPacketEventHandlerData</span><span class="o">*</span> <span class="n">message</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>对于每个 stream <code>proceed_to_next_vnet_baseline</code> (astra-sim/system/Sys.cc) 用于推进通信阶段并且负责在队列之间移动 stream 对象。以下几种情况会调用该函数：</p>
<ol>
<li>stream 第一次被移动出 ready_list 并且将被插入到 <code>active_streams</code>.</li>
<li>stream 完成了一个通信阶段并且等待下一个阶段。</li>
<li>stream 完成了所有的通信阶段。</li>
</ol>
<p>(2-1) 到 (2-5) 描述了该函数的行为</p>
<ol>
<li>
<p>查看当前持有 stream 的队列: 从队列中删除 <code>StreamBaseline</code> 对象 (流的完成顺序可能与它们开始执行的顺序不同)。</p>
</li>
<li>
<p>修改 <code>StreamBaseline</code> 对象: 已完成的集合通信阶段从 <code>phases_to_go</code> 中弹出，<code>my_current_phase</code> 现在指向下一个待执行的阶段。</p>
</li>
<li>
<p>使用 <code>insert_stream</code> 将 <code>StreamBaseline</code> 对象插入到下一个队列中。</p>
</li>
<li>
<p>调用函数 <code>notify_stream_removed</code> 函数查看前一个队列的头部。 <code>stream_pointer</code> 指向队列中第一个未运行的 stream (标记为蓝色)。该函数通过调用 <code>StreamBaseline::init()</code> 来启动 stream 的下一个阶段的执行。</p>
</li>
<li>
<p>使用 <code>notify_stream_added</code> 触发新队列头部 stream 的通信阶段执行。</p>
</li>
</ol>
<p>在其他情况下，<code>proceed_to_next_vnet_baseline</code> 会执行上述步骤的一部分。具体如下：</p>
<ol>
<li>
<p>刚从 <code>ready_list</code> 中移除：<br>
<code>proceed_to_next..</code> 会初始化 stream (1-2)，将其插入到第一个队列中 (1-3)，并触发该队列头部的流执行。</p>
</li>
<li>
<p>stream 完成：<br>
该函数会从之前的队列中删除 stream (3-1)，并触发之前队列头部的 stream 执行。此外，<code>StreamBaseline</code> 对象会被删除，并调用 <code>notify_stream_finished</code>，以通知 <code>Sys</code> 对象 stream 已经结束 (3-6)</p>
</li>
</ol>
<h2 id="collective-implementation">Collective Implementation<a hidden class="anchor" aria-hidden="true" href="#collective-implementation">#</a></h2>
<p>
<figure class="post-figure">
    <a href="https://astra-sim.github.io/astra-sim-docs/_images/coll_implementation.svg" target="_blank" rel="noopener">
        <img loading="lazy" src="https://astra-sim.github.io/astra-sim-docs/_images/coll_implementation.svg" alt="Overview of Collective Implementation">
    </a><figcaption>Overview of Collective Implementation</figcaption></figure>
模拟器将集体通信分解为发送和接收消息的方式有两种。目前最常用的方法是模拟器实现一组预定义的常见算法 (例如 Ring、DoubleBinary、HalvingDoubling 等)。这种“原生”实现逻辑位于模拟器的代码库中，允许用户快速探索一组预定义的算法。</p>
<p>自 2024 年 8 月以来，ASTRA-sim 支持了一种新的集合通信算法表示方式。System 层通过暴露一个集体 API，可以接收任意集体算法的定义。</p>
<p>这两种方法都是对 <code>CollectivePhase::Algorithm</code> 对象的实现，该对象是 System 层中的调度单元. <a href="https://github.com/astra-sim/astra-sim/blob/15a4334ade00fe1040fd00495cd13fd1ea5177e4/astra-sim/system/Sys.cc#L1037">generate_collective_phase</a> 会根据不同的算法在创建 <a href="https://github.com/astra-sim/astra-sim/blob/15a4334ade00fe1040fd00495cd13fd1ea5177e4/astra-sim/system/CollectivePhase.hh#L17">CollectivePhase</a> 的时候传入对应的 Algorithm.</p>
<h3 id="astra-sim-native-implementation">ASTRA-Sim Native Implementation<a hidden class="anchor" aria-hidden="true" href="#astra-sim-native-implementation">#</a></h3>
<p>相关的实现都位于<a href="https://github.com/astra-sim/astra-sim/tree/master/astra-sim/system/collective">该文件夹</a>下, naive 实现的限制是当需要模拟一个新的集合通信算法时算法，必须实现整个集合？随着不规则集合通信 (如 TACOS(Topology Aware CollectiveS), MSCCLang(基于 DSL)) 中工作的增加，快速模拟和迭代各种算法的需求变得越来越多。</p>
<h3 id="chakra-based-arbitrary-definition-through-collective-api">Chakra Based Arbitrary Definition Through Collective API<a hidden class="anchor" aria-hidden="true" href="#chakra-based-arbitrary-definition-through-collective-api">#</a></h3>
<p>因此一个新的 AP来接受任何集合通信算法的定义，而不局限于预定义的规则通信模式。对于通信表示，使用 Chakra ET 模式作为单独的图。将集合通信算法表示为Chakra ET 模式中 COMM_SEND，COMM_RECV 节点的图。也就是说，System 层不是将集合通信分解为发送和接收消息，而是简单地遵循 Chakra 图中已经表示的分解。由于已经使用 Chakra ET 来表示 workload，使用 Chakra ET 来额外定义集合通信算法提供了一种轻松简单的方式来遍历整个图。</p>
<p>如上图所示当 workload 层发出 AllReduce 集体操作时，System 层不会运行模拟器代码库中已有的原生实现逻辑，而是会遍历通过 API 提供的 Chakra ET，该 ET 表示集合通信算法。需要注意 workload Chakra 图和集合通信算法的 Chakra 图是解耦的，并通过不同的输入点提供。最终，asytra-sim 模拟器会将通信节点替换为集体实现。</p>
<h2 id="input-files-for-collective-api">Input Files for Collective API<a hidden class="anchor" aria-hidden="true" href="#input-files-for-collective-api">#</a></h2>
<h3 id="astra-sim-native">ASTRA-sim Native<a hidden class="anchor" aria-hidden="true" href="#astra-sim-native">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="s2">&#34;active-chunks-per-dimension&#34;</span><span class="err">:</span> <span class="mi">1</span><span class="err">,</span>
</span></span><span class="line"><span class="cl">  <span class="s2">&#34;all-reduce-implementation&#34;</span><span class="err">:</span> <span class="p">[</span><span class="s2">&#34;ring&#34;</span><span class="p">]</span><span class="err">,</span>
</span></span><span class="line"><span class="cl">  <span class="s2">&#34;all-gather-implementation&#34;</span><span class="err">:</span> <span class="p">[</span><span class="s2">&#34;ring&#34;</span><span class="p">,</span> <span class="s2">&#34;doubleBinaryTree&#34;</span><span class="p">]</span><span class="err">,</span>
</span></span><span class="line"><span class="cl">  <span class="s2">&#34;all-to-all-implementation&#34;</span><span class="err">:</span> <span class="p">[</span><span class="s2">&#34;ring&#34;</span><span class="p">,</span> <span class="s2">&#34;doubleBinaryTree&#34;</span><span class="p">,</span> <span class="s2">&#34;halvingDoubling&#34;</span><span class="p">]</span><span class="err">,</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span></code></pre></div><p><code>all-*-implementation</code> 指定了模拟器将如何将给定的集合通信分解为发送和接收消息。All-Gather 操作列表中的两个条目表示模拟器将按两个维度分解 ——第一个维度使用 Ring 算法，第二个维度使用 doubleBinaryTree 算法。</p>
<blockquote class="quote"><p>Native Implementation Requires That the Dimensions for Collective Algorithms Are Same Across All Collectives.</p></blockquote>
<div class="notice warning" >
    <p class="notice-title">
        <span class="icon-notice baseline">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="126 76.5 300 300">
  <path d="M297.431 324.397v-34.255c0-3.245-2.344-5.95-5.358-5.95h-32.146c-3.014 0-5.358 2.705-5.358 5.95v34.255c0 3.245 2.344 5.95 5.358 5.95h32.146c3.014 0 5.358-2.705 5.358-5.95Zm-.335-67.428 3.014-82.753c0-1.081-.502-2.524-1.674-3.425-1.005-.902-2.512-1.983-4.019-1.983h-36.834c-1.507 0-3.014 1.081-4.019 1.983-1.172.901-1.674 2.704-1.674 3.786l2.846 82.392c0 2.344 2.512 4.146 5.693 4.146h30.975c3.013 0 5.525-1.803 5.692-4.146Zm-2.344-168.39L423.34 342.425c3.683 7.032 3.516 15.686-.335 22.717-3.85 7.031-10.883 11.358-18.417 11.358H147.413c-7.534 0-14.566-4.327-18.417-11.358-3.85-7.031-4.018-15.685-.335-22.716L257.248 88.578C260.93 81.188 268.13 76.5 276 76.5c7.87 0 15.069 4.688 18.752 12.08Z"/>
</svg>

        </span>Warning</p><p><strong>Native 实现要求所有集体操作的维度必须相同</strong>。换句话说，如果一个集合通信算法被定义为二维的，那么其他集合通信算法也必须是二维操作。上述只是一个例子。</p></div>

<h3 id="collective-api">Collective API<a hidden class="anchor" aria-hidden="true" href="#collective-api">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="s2">&#34;active-chunks-per-dimension&#34;</span><span class="err">:</span> <span class="mi">1</span><span class="err">,</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;all-reduce-implementation-chakra&#34;</span><span class="err">:</span> <span class="p">[</span><span class="s2">&#34;/app/hoti2024/demo5/inputs/custom_ring&#34;</span><span class="p">]</span><span class="err">,</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span></code></pre></div><p>需要注意这里要使用 <code>all-*-implementation-chakra</code>，而不是 <code>all-*-implementation</code>. 另外  Chakra ET 文件与传递给 workload 层的文件是不同的，每一项的值是 Chakra ET 文件的绝对路径，不包括最后的 <code>{rank}.et</code> 字符串 (类似于 Workload 层输入)。此外，即使有许多维度，列表也只接受一个值。这是因为跨维度通信的概念已经包含在 ET 中。</p>
<div class="github">
    <div class="github_bar">
        <svg xmlns="http://www.w3.org/2000/svg" width="50" height="50" viewBox="0 0 50 50"><path d="M17.791,46.836C18.502,46.53,19,45.823,19,45v-5.4c0-0.197,0.016-0.402,0.041-0.61C19.027,38.994,19.014,38.997,19,39 c0,0-3,0-3.6,0c-1.5,0-2.8-0.6-3.4-1.8c-0.7-1.3-1-3.5-2.8-4.7C8.9,32.3,9.1,32,9.7,32c0.6,0.1,1.9,0.9,2.7,2c0.9,1.1,1.8,2,3.4,2 c2.487,0,3.82-0.125,4.622-0.555C21.356,34.056,22.649,33,24,33v-0.025c-5.668-0.182-9.289-2.066-10.975-4.975 c-3.665,0.042-6.856,0.405-8.677,0.707c-0.058-0.327-0.108-0.656-0.151-0.987c1.797-0.296,4.843-0.647,8.345-0.714 c-0.112-0.276-0.209-0.559-0.291-0.849c-3.511-0.178-6.541-0.039-8.187,0.097c-0.02-0.332-0.047-0.663-0.051-0.999 c1.649-0.135,4.597-0.27,8.018-0.111c-0.079-0.5-0.13-1.011-0.13-1.543c0-1.7,0.6-3.5,1.7-5c-0.5-1.7-1.2-5.3,0.2-6.6 c2.7,0,4.6,1.3,5.5,2.1C21,13.4,22.9,13,25,13s4,0.4,5.6,1.1c0.9-0.8,2.8-2.1,5.5-2.1c1.5,1.4,0.7,5,0.2,6.6c1.1,1.5,1.7,3.2,1.6,5 c0,0.484-0.045,0.951-0.11,1.409c3.499-0.172,6.527-0.034,8.204,0.102c-0.002,0.337-0.033,0.666-0.051,0.999 c-1.671-0.138-4.775-0.28-8.359-0.089c-0.089,0.336-0.197,0.663-0.325,0.98c3.546,0.046,6.665,0.389,8.548,0.689 c-0.043,0.332-0.093,0.661-0.151,0.987c-1.912-0.306-5.171-0.664-8.879-0.682C35.112,30.873,31.557,32.75,26,32.969V33 c2.6,0,5,3.9,5,6.6V45c0,0.823,0.498,1.53,1.209,1.836C41.37,43.804,48,35.164,48,25C48,12.318,37.683,2,25,2S2,12.318,2,25 C2,35.164,8.63,43.804,17.791,46.836z"></path></svg>
        <a class="github_name" href="https://github.com/astra-sim/collectiveapi" target="_blank">Collective API</a>
    </div>
    <div class="github_description">参考该仓库实现</div>
    <div class="github_language">
        
    </div>
</div>

<h1 id="network-backend">Network Backend<a hidden class="anchor" aria-hidden="true" href="#network-backend">#</a></h1>
<h2 id="analytical-network-backend">Analytical Network Backend<a hidden class="anchor" aria-hidden="true" href="#analytical-network-backend">#</a></h2>
<p>Analytical Network 模拟器通过数学方程模拟所有网络行为。因此，该后端最适合于大规模分布式平台的建模和仿真。目前支持两种分析模式</p>
<ul>
<li>congestion_<strong>unaware</strong> analytical network simulator</li>
<li>congestion_<strong>aware</strong> analytical network simulator</li>
</ul>
<hr>
<ul>
<li>T<strong>Topology</strong></li>
</ul>
<p>Analytical Network 支持三种拓扑结构: Ring, FullConnected, Switch. 并且可以堆叠来表示多维网络。</p>
<p>
<figure class="post-figure">
    <a href="https://astra-sim.github.io/astra-network-analytical-docs/_images/network-building-blocks.svg" target="_blank" rel="noopener">
        <img loading="lazy" src="https://astra-sim.github.io/astra-network-analytical-docs/_images/network-building-blocks.svg" alt="Basic Network Building Block">
    </a><figcaption>Basic Network Building Block</figcaption></figure></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">topology</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="l">Ring, Switch ] </span><span class="w"> </span><span class="c"># 2D topology</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">topology</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="l">Ring, Ring, Ring ] </span><span class="w"> </span><span class="c"># 3D topology</span><span class="w">
</span></span></span></code></pre></div><p>
<figure class="post-figure">
    <a href="https://astra-sim.github.io/astra-network-analytical-docs/_images/multidim-network-example.svg" target="_blank" rel="noopener">
        <img loading="lazy" src="https://astra-sim.github.io/astra-network-analytical-docs/_images/multidim-network-example.svg" alt="Example of 2D &amp; 3D Topologies">
    </a><figcaption>Example of 2D &amp; 3D Topologies</figcaption></figure></p>
<hr>
<ul>
<li><strong>NPUs Count</strong></li>
</ul>
<p>指定了每个维度上的设备数目</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">npus_count</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="m">5</span><span class="w"> </span><span class="p">]</span><span class="w">  </span><span class="c"># 5 NPUs</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">npus_count</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="m">4</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="p">]</span><span class="w">  </span><span class="c"># 4 × 2 = 8 NPUs</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">npus_count</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="m">4</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="p">]</span><span class="w">  </span><span class="c"># 4 × 2 × 2 = 16 NPUs</span><span class="w">
</span></span></span></code></pre></div><p>
<figure class="post-figure">
    <a href="https://astra-sim.github.io/astra-network-analytical-docs/_images/npus-count-example.svg" target="_blank" rel="noopener">
        <img loading="lazy" src="https://astra-sim.github.io/astra-network-analytical-docs/_images/npus-count-example.svg" alt="NPUs Count Example">
    </a><figcaption>NPUs Count Example</figcaption></figure></p>
<hr>
<ul>
<li><strong>Bandwidth</strong> &amp; <strong>Latency</strong></li>
</ul>
<p><code>latency</code> 定义了每条单向链路的延迟 (ns).
<code>bandwidth</code> 定义了每条单向链路的带宽 (GB/s).</p>
<div class="notice note" >
    <p class="notice-title">
        <span class="icon-notice baseline">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 128 300 300">
  <path d="M150 128c82.813 0 150 67.188 150 150 0 82.813-67.188 150-150 150C67.187 428 0 360.812 0 278c0-82.813 67.188-150 150-150Zm25 243.555v-37.11c0-3.515-2.734-6.445-6.055-6.445h-37.5c-3.515 0-6.445 2.93-6.445 6.445v37.11c0 3.515 2.93 6.445 6.445 6.445h37.5c3.32 0 6.055-2.93 6.055-6.445Zm-.39-67.188 3.515-121.289c0-1.367-.586-2.734-1.953-3.516-1.172-.976-2.93-1.562-4.688-1.562h-42.968c-1.758 0-3.516.586-4.688 1.563-1.367.78-1.953 2.148-1.953 3.515l3.32 121.29c0 2.734 2.93 4.882 6.64 4.882h36.134c3.515 0 6.445-2.148 6.64-4.883Z"/>
</svg>

        </span>Note</p><p>$1 GB = 2^{30} B$ and $1 s = 10^9 ns$</p></div>

<h2 id="ns3-backend">ns3 backend<a hidden class="anchor" aria-hidden="true" href="#ns3-backend">#</a></h2>
<p>下面是用 ns3 后端进行方针的一个执行命令。这里使用了 <code>--network-backend</code> 和 <code>--logical-topology</code> 这两个参数。需要说明的是，Analytical Backend 中仅使用了-<code>-network-backend</code> 参数，这是因为分析型后端的逻辑拓扑与物理拓扑是相同的，而 ns3 则允许我们将逻辑拓扑与物理拓扑分离。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">   <span class="c1"># {NS3_DIR} is the directory of the ns-3 backend. That is, &#39;{ASTRA_SIM_ROOT_DIRECTORY}/extern/network_backend/ns-3&#39;</span>
</span></span><span class="line"><span class="cl">    <span class="nb">cd</span> <span class="s2">&#34;</span><span class="si">${</span><span class="nv">NS3_DIR</span><span class="si">}</span><span class="s2">/build/scratch&#34;</span>
</span></span><span class="line"><span class="cl">    ./ns3.42-AstraSimNetwork-default <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>        --workload-configuration<span class="o">=</span><span class="s2">&#34;</span><span class="si">${</span><span class="nv">SCRIPT_DIR</span><span class="p">:?</span><span class="si">}</span><span class="s2">&#34;</span>/../../extern/graph_frontend/chakra/one_comm_coll_node_allgather  <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>        --system-configuration<span class="o">=</span><span class="s2">&#34;</span><span class="si">${</span><span class="nv">SCRIPT_DIR</span><span class="p">:?</span><span class="si">}</span><span class="s2">&#34;</span>/../../inputs/system/Switch.json  <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>        --network-configuration<span class="o">=</span><span class="s2">&#34;../../../ns-3/scratch/config/config.txt&#34;</span>   <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>        --remote-memory-configuration<span class="o">=</span><span class="s2">&#34;</span><span class="si">${</span><span class="nv">SCRIPT_DIR</span><span class="p">:?</span><span class="si">}</span><span class="s2">&#34;</span>/../../inputs/remote_memory/analytical/no_memory_expansion.json <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>        --logical-topology-configuration<span class="o">=</span><span class="s2">&#34;</span><span class="si">${</span><span class="nv">SCRIPT_DIR</span><span class="p">:?</span><span class="si">}</span><span class="s2">&#34;</span>/../../inputs/network/ns3/sample_8nodes_1D.json   <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>        --comm-group-configuration<span class="o">=</span><span class="se">\&#34;</span>empty<span class="se">\&#34;</span>
</span></span></code></pre></div><hr>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p><a href="https://github.com/mlcommons/chakra/wiki/Chakra-Execution-Trace-Collection-%E2%80%90-A-Comprehensive-Guide-on-Merging-PyTorch-and-Kineto-Traces#2-overview-of-trace-collection-and-simulation-methodology">Overview of Trace Collection</a>&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/astra-sim/">Astra-Sim</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/blogs/tx8read/">
    <span class="title">« Prev</span>
    <br>
    <span>Tx8read</span>
  </a>
  <a class="next" href="http://localhost:1313/blogs/transformerfamily/">
    <span class="title">Next »</span>
    <br>
    <span>Transformer Family</span>
  </a>
</nav>

  </footer><script src="https://giscus.app/client.js"
        data-repo="jamesnulliu/jamesnulliu.github.io"
        data-repo-id="R_kgDOMPCQIw"
        data-category="Announcements"
        data-category-id="DIC_kwDOMPCQI84Cgb2t"
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="bottom"
        data-theme="preferred_color_scheme"
        data-lang="en"
        crossorigin="anonymous"
        async>
</script>
</article>
    </main>
    
<footer class="footer">
        <span>© 2024-2025 WITHER</span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
