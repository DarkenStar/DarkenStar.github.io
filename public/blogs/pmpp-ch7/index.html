<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>PMPP Learning-Chapter 7 Convolution-An Introduction to Constant Memory and Caching | WITHER</title>
<meta name="keywords" content="CUDA">
<meta name="description" content="Personal notebook 7 of Programming Massively Parallel Processors.">
<meta name="author" content="WITHER">
<link rel="canonical" href="http://localhost:1313/blogs/pmpp-ch7/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.57fd86fa03777cde771f7b2a41cf80559337875129cb3387f67260e81f43454c.css" integrity="sha256-V/2G&#43;gN3fN53H3sqQc&#43;AVZM3h1EpyzOH9nJg6B9DRUw=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/blogs/pmpp-ch7/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<script>
  MathJax = {
    tex: {
      displayMath: [['\\[', '\\]'], ['$$', '$$']],  
      inlineMath: [['\\(', '\\)'], ['$', '$']]  
    }
  };
</script>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.google.com/share?selection.family=Cascadia+Code:ital,wght@0,200..700;1,200..700" rel="stylesheet"><meta property="og:url" content="http://localhost:1313/blogs/pmpp-ch7/">
  <meta property="og:site_name" content="WITHER">
  <meta property="og:title" content="PMPP Learning-Chapter 7 Convolution-An Introduction to Constant Memory and Caching">
  <meta property="og:description" content="Personal notebook 7 of Programming Massively Parallel Processors.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="blogs">
    <meta property="article:published_time" content="2024-09-06T10:50:42+08:00">
    <meta property="article:modified_time" content="2024-09-06T10:50:42+08:00">
    <meta property="article:tag" content="PMPP Learning">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="PMPP Learning-Chapter 7 Convolution-An Introduction to Constant Memory and Caching">
<meta name="twitter:description" content="Personal notebook 7 of Programming Massively Parallel Processors.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Blogs",
      "item": "http://localhost:1313/blogs/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "PMPP Learning-Chapter 7 Convolution-An Introduction to Constant Memory and Caching",
      "item": "http://localhost:1313/blogs/pmpp-ch7/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "PMPP Learning-Chapter 7 Convolution-An Introduction to Constant Memory and Caching",
  "name": "PMPP Learning-Chapter 7 Convolution-An Introduction to Constant Memory and Caching",
  "description": "Personal notebook 7 of Programming Massively Parallel Processors.",
  "keywords": [
    "CUDA"
  ],
  "articleBody": "7 Convolution-An Introduction to Constant Memory and Caching 卷积的每个输出数据元素可以相互独立地计算，这是并行计算的理想特性。另一方面，在处理具有边界条件的输出数据元素时，有大量的输入数据共享。这使得卷积可以实现复杂的 tiling 方法和输入数据分段方法。\n7.1 Background 输入数据向量 $[x_0, x_1, \\cdots, x_{n-1}]$ 和包含 2r+1 个元素的 filter 数组 $[f_0, f_1, \\cdots, f_{2r}]$， 1D卷积计算公式为 $$y_i=\\sum_{j=-r}^rf_{i+j}\\times x_i$$ 同样对于 n*n 大小的二维输入，和 r*r 大小的 filter，2D 卷积计算公式为 $$P_{y,x}=\\sum_{j=-r_y}^{r_y}\\sum_{k=-r_x}^{r_x}f_{y+j,x+k}\\times N_{y,x}$$7.2 Parallel Convolution: a Basic Algorithm 假设二维卷积内核接收五个参数: 输入数组 N 的指针; 滤波器 F 的指针; 输出数组 P 的指针; 方形滤波器的半径 r; 输入输出数组的宽度; 输入和输出数组的高度。如下图所示，一个简单的并行方式是网格中的每个线程计算与自身坐标相同的输出像素。对应的内核函数代码如下，浮点计算与全局内存访问的比仅为 0.25 OP/B (每加载 8 字节执行 2 次运算)\n__global__ void convolution_2D_basic_kernel (float *N, float *F, float *P, int r, int width, int height) { int outCol = blockIdx.x * blockDim.x + threadIdx.x; int outRow = blockIdx.y * blockDim.y + threadIdx.y; int Pvalue = 0.0f; for (int fRow = 0; fRow \u003c 2*r+1; fRow++) { for (int fCol = 0; fCol \u003c 2 * r + 1; fCol++) { int inRow = outRow - r + fRow; int inCol = outCol - r + fCol; if (inRow \u003e 0 \u0026\u0026 inRow \u003c height \u0026\u0026 inCol \u003e 0 \u0026\u0026 inCol \u003c width) { Pvalue += P[inRow * width + inCol] * F[fRow * r + fCol]; } } } P[outRow * width + outCol] = Pvalue; } 7.3 Constant Memory and Caching 可以发现卷积核 F 通常很小，在整个卷积内核的执行过程中不会改变，所有线程都以相同的顺序访问其元素。因此我们可以考虑将其存储在常量内存里，之前说过它和全局内存的区别是线程不能修改常量内存变量的值并且常量内存非常小，目前为 64 KB. 假设已经在主机代码里分配好 F_h 的内存，可以通过 cudaMemcpyToSymbol() 将其从主机内存传输到设备常量内存中。内核函数以全局变量的形式访问常量内存变量。因此，它们的指针不需要作为参数传递给内核函数。\n如果主机代码和内核代码位于不同的文件中，内核代码文件必须包含相关的外部声明的头文件，以确保声明对内核可见。\nCUDA runtime 知道常量内存变量在内核执行期间不会被修改，因此会让硬件在内核执行期间直接缓存常量内存变量。在不需要支持写的情况下，可以在减小芯片面积和降低功耗的情况下设计用于常量内存变量的专用缓存，被称为常量缓存 (constant caching).\n7.4 Tiled Convolution with Halo Cells 我们定义输出 tile 为每个块处理的输出元素，输入 tile 为计算输出 tile 中元素所需的输入元素的集合。下图给出了一个例子，可以看到输入 tile 大小和输出 tile 大小之间的差异使 tile 卷积核的设计变得复杂。有两种线程组织可以处理这种差异。\n启动与输入 tile 具有相同维度的线程块。这样因为每个线程只需要加载一个输入元素。但由于输入 tile 比对应的输出 tile 大，在计算输出元素时需要禁用一些线程，降低了资源利用率。 启动与输出 tile 具有相同维度的线程块。这样线程需要迭代以确保加载所有输入 tile 元素。但简化了输出元素的计算。 第一种线程组织方式的内核如下。现在每个块中的线程共同执行 OUT_TILE_DIM^2*(2*FILTER_RADIUS+1) 次浮点运算。分配给输入 tile 元素的每个线程加载一个4字节的输入值。因此每个block加载 IN_TILE_DIM^2*4=(OUT_TILE_DIM+2*FILTER_RADIUS)^2*4\n#define IN_TILE_DIM 32 #define FILTER_RADIUS 5 #define OUT_TILE_DIM (IN_TILE_DIM - 2*(FILTER_RADIUS)) __constant__ float F_c[2 * FILTER_RADIUS + 1][FILTER_RADIUS + 1]; __global__ void convolution_tiled_2D_constant_mem_kernel_1( float* N, float* P, int width, int height) { // Upper left input tile coord int col = blockIdx.x * OUT_TILE_DIM + threadIdx.x - FILTER_RADIUS; int row = blockIdx.y * OUT_TILE_DIM + threadIdx.y - FILTER_RADIUS; // Loading input tile __shared__ float N_s[IN_TILE_DIM][IN_TILE_DIM]; if (row \u003e= 0 \u0026\u0026 row \u003c height \u0026\u0026 col \u003e= 0 \u0026\u0026 col \u003c width) { N_s[threadIdx.y][threadIdx.x] = N[row * width + col]; } else { N_s[threadIdx.y][threadIdx.x] = 0.0f; } __syncthreads(); // Calculate output elements int tileCol = threadIdx.x - FILTER_RADIUS; int tileRow = threadIdx.y - FILTER_RADIUS; if (row \u003e= 0 \u0026\u0026 row \u003c height \u0026\u0026 col \u003e= 0 \u0026\u0026 col \u003c width \u0026\u0026 tileCol \u003e= 0 \u0026\u0026 tileCol \u003c OUT_TILE_DIM \u0026\u0026 tileRow \u003e= 0 \u0026\u0026 tileRow \u003c OUT_TILE_DIM) { float Pvalue = 0.0f; for (int fRow = 0; fRow \u003c 2 * FILTER_RADIUS + 1; fRow++) { for (int fCol = 0; fCol \u003c 2 * FILTER_RADIUS + 1; fCol++) { Pvalue += F_c[fRow][fCol] * N_s[tileRow + fRow][tileCol + fCol]; } } P[row * width + col] = Pvalue; } } 第二种线程组织方式的内核如下，每个线程现在可能需要加载多个输入 tile 的元素。\n__global__ void convolution_tiled_2D_constant_mem_kernel_2( // OUT_TILE_DIM^2 threads per block float* N, float* P, int width, int height) { // Upper left output tile coord int col = blockIdx.x * OUT_TILE_DIM + threadIdx.x; int row = blockIdx.y * OUT_TILE_DIM + threadIdx.y; // Each thread may need to load multiple elements into shared memory __shared__ float N_s[IN_TILE_DIM][IN_TILE_DIM]; for (int i = threadIdx.y; i \u003c IN_TILE_DIM; i += OUT_TILE_DIM) { for (int j = threadIdx.x; j \u003c IN_TILE_DIM; j += OUT_TILE_DIM) { int in_col = blockIdx.x * OUT_TILE_DIM + j - FILTER_RADIUS; int in_row = blockIdx.y * OUT_TILE_DIM + i - FILTER_RADIUS; if (in_row \u003e= 0 \u0026\u0026 in_row \u003c height \u0026\u0026 in_col \u003e= 0 \u0026\u0026 in_col \u003c width) { N_s[i][j] = N[in_row * width + in_col]; } else { N_s[i][j] = 0.0f; } } } __syncthreads(); // Calculate output elements if (threadIdx.x \u003c OUT_TILE_DIM \u0026\u0026 threadIdx.y \u003c OUT_TILE_DIM \u0026\u0026 row \u003c height \u0026\u0026 col \u003c width) { float Pvalue = 0.0f; for (int fRow = 0; fRow \u003c 2 * FILTER_RADIUS + 1; fRow++) { for (int fCol = 0; fCol \u003c 2 * FILTER_RADIUS + 1; fCol++) { Pvalue += F_c[fRow][fCol] * N_s[threadIdx.y + fRow][threadIdx.x + fCol]; } } P[row * width + col] = Pvalue; } } 7.5 Tiled Convolution Using Caches for Halo Cells 当一个块需要它的 halo cell 时，由于相邻块的访问，它们已经在二级缓存中了。因此，对这些 halo cell 的内存访问可以从 L2 缓存提供，而不会造成额外的 DRAM 流量。我们可以对原来的 N 进行这些 halo cell 的访问，而不是将它们加载到 N_ds 中。代码如下，加载 N_s 变得更简单，因为每个线程可以简单地加载与其分配的输出元素具有相同坐标的输入元素。然而，计算P个元素的循环体变得更加复杂。它需要添加条件来检查 helo cell 和 ghost cell.\n__global__ void convolution_tiled_cached_2D_shared_mem_kernel( // OUT_TILE_DIM^2 threads per block float* N, float* P, int width, int height) { int col =blockIdx.x * OUT_TILE_DIM + threadIdx.x; int row =blockIdx.y * OUT_TILE_DIM + threadIdx.y; // loading input tile __shared__ float N_s[IN_TILE_DIM][IN_TILE_DIM]; if (row \u003c height \u0026\u0026 col \u003c width) { N_s[threadIdx.y][threadIdx.x] = N[row * width + col]; } else { N_s[threadIdx.y][threadIdx.x] = 0.0f; } __syncthreads(); // Calculate output elements if (col \u003c width \u0026\u0026 row \u003c height) { float Pvalue = 0.0f; // turning off the threads at the edge of the block for (int fRow = 0; fRow \u003c 2 * FILTER_RADIUS + 1; fRow++) { for (int fCol = 0; fCol \u003c 2 * FILTER_RADIUS + 1; fCol++) { if (threadIdx.x + fCol - FILTER_RADIUS \u003e= 0 \u0026\u0026 threadIdx.x + fCol - FILTER_RADIUS \u003c IN_TILE_DIM \u0026\u0026 threadIdx.x + fRow - FILTER_RADIUS \u003e= 0 \u0026\u0026 threadIdx.x + fRow - FILTER_RADIUS \u003c IN_TILE_DIM) { Pvalue += F_c[fRow][fCol] * N_s[threadIdx.y + fRow][threadIdx.x + fCol]; } else { if (row - FILTER_RADIUS + fRow \u003e= 0 \u0026\u0026 row - FILTER_RADIUS + fRow \u003c height \u0026\u0026 col - FILTER_RADIUS + fCol \u003e= 0 \u0026\u0026 col - FILTER_RADIUS + fCol \u003c width) { Pvalue += F_c[fRow][fCol] * N[(row - FILTER_RADIUS + fRow) * width + (col - FILTER_RADIUS + fCol)]; } } } } N[row * width + col] = Pvalue; } } Halo Cell: 实际计算区域周围添加的一圈额外的单元格。本质上是 “虚拟” 单元格，存在于不直接关注的区域之外。 Ghost Cell: 存储来自相邻 tile 的数据副本，使得 block 在无需直接访问彼此的内存的情况下访问相邻的必要数据。 ",
  "wordCount" : "2077",
  "inLanguage": "en",
  "datePublished": "2024-09-06T10:50:42+08:00",
  "dateModified": "2024-09-06T10:50:42+08:00",
  "author":[{
    "@type": "Person",
    "name": "WITHER"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/blogs/pmpp-ch7/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "WITHER",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="WITHER (Alt + H)">WITHER</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="http://localhost:1313/zh/" title="简体中文"
                            aria-label="简体中文">简体中文</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/" title="🏠 Home">
                    <span>🏠 Home</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/about_me/" title="🙋🏻‍♂️ Me">
                    <span>🙋🏻‍♂️ Me</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/blogs/" title="📚 Blogs">
                    <span>📚 Blogs</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/categories/" title="🧩 Categories">
                    <span>🧩 Categories</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="🔖 Tags">
                    <span>🔖 Tags</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/archives/" title="⏱ Archive">
                    <span>⏱ Archive</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="🔍 Search (Alt &#43; /)" accesskey=/>
                    <span>🔍 Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/friends/" title="🤝 Friends">
                    <span>🤝 Friends</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/blogs/">Blogs</a></div>
    <h1 class="post-title entry-hint-parent">
      PMPP Learning-Chapter 7 Convolution-An Introduction to Constant Memory and Caching
    </h1>
    <div class="post-description">
      Personal notebook 7 of Programming Massively Parallel Processors.
    </div>
    <div class="post-meta"><span title='2024-09-06 10:50:42 +0800 CST'>Sep-06-2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;2077 words&nbsp;·&nbsp;WITHER

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">Table of Contents</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#7-convolution-an-introduction-to-constant-memory-and-caching" aria-label="7 Convolution-An Introduction to Constant Memory and Caching">7 Convolution-An Introduction to Constant Memory and Caching</a><ul>
                            
                    <li>
                        <a href="#71-background" aria-label="7.1 Background">7.1 Background</a></li>
                    <li>
                        <a href="#72-parallel-convolution-a-basic-algorithm" aria-label="7.2 Parallel Convolution: a Basic Algorithm">7.2 Parallel Convolution: a Basic Algorithm</a></li>
                    <li>
                        <a href="#73-constant-memory-and-caching" aria-label="7.3 Constant Memory and Caching">7.3 Constant Memory and Caching</a></li>
                    <li>
                        <a href="#74-tiled-convolution-with-halo-cells" aria-label="7.4 Tiled Convolution with Halo Cells">7.4 Tiled Convolution with Halo Cells</a></li>
                    <li>
                        <a href="#75-tiled-convolution-using-caches-for-halo-cells" aria-label="7.5 Tiled Convolution Using Caches for Halo Cells">7.5 Tiled Convolution Using Caches for Halo Cells</a>
                    </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>
  <div class="post-content"><h1 id="7-convolution-an-introduction-to-constant-memory-and-caching">7 Convolution-An Introduction to Constant Memory and Caching<a hidden class="anchor" aria-hidden="true" href="#7-convolution-an-introduction-to-constant-memory-and-caching">#</a></h1>
<p>卷积的每个输出数据元素可以相互独立地计算，这是并行计算的理想特性。另一方面，在处理具有边界条件的输出数据元素时，有大量的输入数据共享。这使得卷积可以实现复杂的 tiling 方法和输入数据分段方法。</p>
<h2 id="71-background">7.1 Background<a hidden class="anchor" aria-hidden="true" href="#71-background">#</a></h2>
<p>输入数据向量 $[x_0, x_1, \cdots, x_{n-1}]$ 和包含 2r+1 个元素的 filter 数组 $[f_0, f_1, \cdots, f_{2r}]$， 1D卷积计算公式为
</p>
$$y_i=\sum_{j=-r}^rf_{i+j}\times x_i$$<p>
同样对于 <code>n*n</code> 大小的二维输入，和 <code>r*r</code> 大小的 filter，2D 卷积计算公式为
</p>
$$P_{y,x}=\sum_{j=-r_y}^{r_y}\sum_{k=-r_x}^{r_x}f_{y+j,x+k}\times N_{y,x}$$<h2 id="72-parallel-convolution-a-basic-algorithm">7.2 Parallel Convolution: a Basic Algorithm<a hidden class="anchor" aria-hidden="true" href="#72-parallel-convolution-a-basic-algorithm">#</a></h2>
<p>假设二维卷积内核接收五个参数: 输入数组 N 的指针; 滤波器 F 的指针; 输出数组 P 的指针; 方形滤波器的半径 r; 输入输出数组的宽度; 输入和输出数组的高度。如下图所示，一个简单的并行方式是网格中的每个线程计算与自身坐标相同的输出像素。对应的内核函数代码如下，浮点计算与全局内存访问的比仅为 0.25 OP/B (每加载 8 字节执行 2 次运算)</p>
<p><img alt="Parallelization and Thread Organization for 2D Convolution" loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEBb705cd006867704636e9e5261467570f?method=download&shareKey=d5710b7dee0a3c91d67011d92b623557" title="Parallelization and Thread Organization for 2D Convolution"></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">__global__</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">convolution_2D_basic_kernel</span> <span class="p">(</span><span class="kt">float</span> <span class="o">*</span><span class="n">N</span><span class="p">,</span> <span class="kt">float</span> <span class="o">*</span><span class="n">F</span><span class="p">,</span> <span class="kt">float</span> <span class="o">*</span><span class="n">P</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">									<span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">outCol</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">outRow</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">Pvalue</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">fRow</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">fRow</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">*</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">fRow</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">fCol</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">fCol</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">fCol</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="kt">int</span> <span class="n">inRow</span> <span class="o">=</span> <span class="n">outRow</span> <span class="o">-</span> <span class="n">r</span> <span class="o">+</span> <span class="n">fRow</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="kt">int</span> <span class="n">inCol</span> <span class="o">=</span> <span class="n">outCol</span> <span class="o">-</span> <span class="n">r</span> <span class="o">+</span> <span class="n">fCol</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="n">inRow</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">inRow</span> <span class="o">&lt;</span> <span class="n">height</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">				<span class="n">inCol</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">inCol</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="n">Pvalue</span> <span class="o">+=</span> <span class="n">P</span><span class="p">[</span><span class="n">inRow</span> <span class="o">*</span> <span class="n">width</span> <span class="o">+</span> <span class="n">inCol</span><span class="p">]</span> <span class="o">*</span> <span class="n">F</span><span class="p">[</span><span class="n">fRow</span> <span class="o">*</span> <span class="n">r</span> <span class="o">+</span> <span class="n">fCol</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">P</span><span class="p">[</span><span class="n">outRow</span> <span class="o">*</span> <span class="n">width</span> <span class="o">+</span> <span class="n">outCol</span><span class="p">]</span> <span class="o">=</span> <span class="n">Pvalue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="73-constant-memory-and-caching">7.3 Constant Memory and Caching<a hidden class="anchor" aria-hidden="true" href="#73-constant-memory-and-caching">#</a></h2>
<p>可以发现卷积核 F 通常很小，在整个卷积内核的执行过程中不会改变，所有线程都以相同的顺序访问其元素。因此我们可以考虑将其存储在常量内存里，之前说过它和全局内存的区别是线程不能修改常量内存变量的值并且常量内存非常小，目前为 64 KB.
假设已经在主机代码里分配好 F_h 的内存，可以通过 <code>cudaMemcpyToSymbol()</code> 将其从主机内存传输到设备常量内存中。内核函数以全局变量的形式访问常量内存变量。因此，它们的指针不需要作为参数传递给内核函数。</p>
<p><strong>如果主机代码和内核代码位于不同的文件中，内核代码文件必须包含相关的外部声明的头文件，以确保声明对内核可见。</strong></p>
<p>CUDA runtime 知道常量内存变量在内核执行期间不会被修改，因此会让硬件在内核执行期间直接缓存常量内存变量。在不需要支持写的情况下，可以在减小芯片面积和降低功耗的情况下设计用于常量内存变量的专用缓存，被称为常量缓存 (<code>constant caching</code>).</p>
<h2 id="74-tiled-convolution-with-halo-cells">7.4 Tiled Convolution with Halo Cells<a hidden class="anchor" aria-hidden="true" href="#74-tiled-convolution-with-halo-cells">#</a></h2>
<p>我们定义输出 tile 为每个块处理的输出元素，输入 tile 为计算输出 tile 中元素所需的输入元素的集合。下图给出了一个例子，可以看到输入 tile 大小和输出 tile 大小之间的差异使 tile 卷积核的设计变得复杂。有两种线程组织可以处理这种差异。</p>
<ul>
<li>启动与输入 tile 具有相同维度的线程块。这样因为每个线程只需要加载一个输入元素。但由于输入 tile 比对应的输出 tile 大，在计算输出元素时需要禁用一些线程，降低了资源利用率。</li>
<li>启动与输出 tile 具有相同维度的线程块。这样线程需要迭代以确保加载所有输入 tile 元素。但简化了输出元素的计算。</li>
</ul>
<p><img alt="Input Tile vs. Output Tile in 2D Convolution" loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEBda4dfd50e011362c0cc68caaf130a16d?method=download&shareKey=b534279430a6d88b51d9523c3cdf486b" title="Input Tile vs. Output Tile in 2D Convolution"></p>
<p>第一种线程组织方式的内核如下。现在每个块中的线程共同执行 <code>OUT_TILE_DIM^2*(2*FILTER_RADIUS+1)</code> 次浮点运算。分配给输入 tile 元素的每个线程加载一个4字节的输入值。因此每个block加载 <code>IN_TILE_DIM^2*4=(OUT_TILE_DIM+2*FILTER_RADIUS)^2*4</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#define IN_TILE_DIM 32
</span></span></span><span class="line"><span class="cl"><span class="cp">#define FILTER_RADIUS 5
</span></span></span><span class="line"><span class="cl"><span class="cp">#define OUT_TILE_DIM (IN_TILE_DIM - 2*(FILTER_RADIUS))
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="n">__constant__</span> <span class="kt">float</span> <span class="n">F_c</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">FILTER_RADIUS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">FILTER_RADIUS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">__global__</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">convolution_tiled_2D_constant_mem_kernel_1</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="kt">float</span><span class="o">*</span> <span class="n">N</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">P</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Upper left input tile coord
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">OUT_TILE_DIM</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">FILTER_RADIUS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">OUT_TILE_DIM</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">FILTER_RADIUS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Loading input tile
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">__shared__</span> <span class="kt">float</span> <span class="n">N_s</span><span class="p">[</span><span class="n">IN_TILE_DIM</span><span class="p">][</span><span class="n">IN_TILE_DIM</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">row</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">height</span> <span class="o">&amp;&amp;</span> <span class="n">col</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">N_s</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">][</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">N</span><span class="p">[</span><span class="n">row</span> <span class="o">*</span> <span class="n">width</span> <span class="o">+</span> <span class="n">col</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">N_s</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">][</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">__syncthreads</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Calculate output elements
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">int</span> <span class="n">tileCol</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">FILTER_RADIUS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">tileRow</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">FILTER_RADIUS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">row</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">height</span> <span class="o">&amp;&amp;</span> <span class="n">col</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">width</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">		<span class="n">tileCol</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">tileCol</span> <span class="o">&lt;</span> <span class="n">OUT_TILE_DIM</span> <span class="o">&amp;&amp;</span> <span class="n">tileRow</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">tileRow</span> <span class="o">&lt;</span> <span class="n">OUT_TILE_DIM</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="kt">float</span> <span class="n">Pvalue</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">fRow</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">fRow</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">FILTER_RADIUS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">fRow</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">fCol</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">fCol</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">FILTER_RADIUS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">fCol</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="n">Pvalue</span> <span class="o">+=</span> <span class="n">F_c</span><span class="p">[</span><span class="n">fRow</span><span class="p">][</span><span class="n">fCol</span><span class="p">]</span> <span class="o">*</span> <span class="n">N_s</span><span class="p">[</span><span class="n">tileRow</span> <span class="o">+</span> <span class="n">fRow</span><span class="p">][</span><span class="n">tileCol</span> <span class="o">+</span> <span class="n">fCol</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="n">P</span><span class="p">[</span><span class="n">row</span> <span class="o">*</span> <span class="n">width</span> <span class="o">+</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">Pvalue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>第二种线程组织方式的内核如下，每个线程现在可能需要加载多个输入 tile 的元素。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">__global__</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">convolution_tiled_2D_constant_mem_kernel_2</span><span class="p">(</span>  <span class="c1">// OUT_TILE_DIM^2 threads per block
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">float</span><span class="o">*</span> <span class="n">N</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">P</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Upper left output tile coord
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">OUT_TILE_DIM</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">OUT_TILE_DIM</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Each thread may need to load multiple elements into shared memory
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">__shared__</span> <span class="kt">float</span> <span class="n">N_s</span><span class="p">[</span><span class="n">IN_TILE_DIM</span><span class="p">][</span><span class="n">IN_TILE_DIM</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">IN_TILE_DIM</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">OUT_TILE_DIM</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">IN_TILE_DIM</span><span class="p">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="n">OUT_TILE_DIM</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="kt">int</span> <span class="n">in_col</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">OUT_TILE_DIM</span> <span class="o">+</span> <span class="n">j</span> <span class="o">-</span> <span class="n">FILTER_RADIUS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="kt">int</span> <span class="n">in_row</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">OUT_TILE_DIM</span> <span class="o">+</span> <span class="n">i</span> <span class="o">-</span> <span class="n">FILTER_RADIUS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="n">in_row</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">in_row</span> <span class="o">&lt;</span> <span class="n">height</span> <span class="o">&amp;&amp;</span> <span class="n">in_col</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">in_col</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="n">N_s</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">N</span><span class="p">[</span><span class="n">in_row</span> <span class="o">*</span> <span class="n">width</span> <span class="o">+</span> <span class="n">in_col</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="n">N_s</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">__syncthreads</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Calculate output elements
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">OUT_TILE_DIM</span> <span class="o">&amp;&amp;</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">OUT_TILE_DIM</span> <span class="o">&amp;&amp;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">height</span> <span class="o">&amp;&amp;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kt">float</span> <span class="n">Pvalue</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">fRow</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">fRow</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">FILTER_RADIUS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">fRow</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">fCol</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">fCol</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">FILTER_RADIUS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">fCol</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="n">Pvalue</span> <span class="o">+=</span> <span class="n">F_c</span><span class="p">[</span><span class="n">fRow</span><span class="p">][</span><span class="n">fCol</span><span class="p">]</span> <span class="o">*</span> <span class="n">N_s</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">fRow</span><span class="p">][</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">fCol</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="n">P</span><span class="p">[</span><span class="n">row</span> <span class="o">*</span> <span class="n">width</span> <span class="o">+</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">Pvalue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="75-tiled-convolution-using-caches-for-halo-cells">7.5 Tiled Convolution Using Caches for Halo Cells<a hidden class="anchor" aria-hidden="true" href="#75-tiled-convolution-using-caches-for-halo-cells">#</a></h2>
<p>当一个块需要它的 halo cell 时，由于相邻块的访问，它们已经在二级缓存中了。因此，对这些  halo cell 的内存访问可以从 L2 缓存提供，而不会造成额外的 DRAM 流量。我们可以对原来的 N 进行这些 halo cell 的访问，而不是将它们加载到 <code>N_ds</code> 中。代码如下，加载 N_s 变得更简单，因为每个线程可以简单地加载与其分配的输出元素具有相同坐标的输入元素。然而，计算P个元素的循环体变得更加复杂。它需要添加条件来检查 helo cell 和 ghost cell.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">__global__</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">convolution_tiled_cached_2D_shared_mem_kernel</span><span class="p">(</span>  <span class="c1">// OUT_TILE_DIM^2 threads per block
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">float</span><span class="o">*</span> <span class="n">N</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">P</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">col</span> <span class="o">=</span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">OUT_TILE_DIM</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">row</span> <span class="o">=</span><span class="n">blockIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">OUT_TILE_DIM</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// loading input tile
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">__shared__</span> <span class="kt">float</span> <span class="n">N_s</span><span class="p">[</span><span class="n">IN_TILE_DIM</span><span class="p">][</span><span class="n">IN_TILE_DIM</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">row</span> <span class="o">&lt;</span> <span class="n">height</span> <span class="o">&amp;&amp;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">N_s</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">][</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">N</span><span class="p">[</span><span class="n">row</span> <span class="o">*</span> <span class="n">width</span> <span class="o">+</span> <span class="n">col</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">N_s</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span><span class="p">][</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">__syncthreads</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Calculate output elements
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">col</span> <span class="o">&lt;</span> <span class="n">width</span> <span class="o">&amp;&amp;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">float</span> <span class="n">Pvalue</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// turning off the threads at the edge of the block
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">fRow</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">fRow</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">FILTER_RADIUS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">fRow</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">fCol</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">fCol</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">FILTER_RADIUS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">fCol</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">fCol</span> <span class="o">-</span> <span class="n">FILTER_RADIUS</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">                    <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">fCol</span> <span class="o">-</span> <span class="n">FILTER_RADIUS</span> <span class="o">&lt;</span> <span class="n">IN_TILE_DIM</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">                    <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">fRow</span> <span class="o">-</span> <span class="n">FILTER_RADIUS</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">                    <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">fRow</span> <span class="o">-</span> <span class="n">FILTER_RADIUS</span> <span class="o">&lt;</span> <span class="n">IN_TILE_DIM</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                    <span class="n">Pvalue</span> <span class="o">+=</span> <span class="n">F_c</span><span class="p">[</span><span class="n">fRow</span><span class="p">][</span><span class="n">fCol</span><span class="p">]</span> <span class="o">*</span> <span class="n">N_s</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">fRow</span><span class="p">][</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">fCol</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="k">if</span> <span class="p">(</span><span class="n">row</span> <span class="o">-</span> <span class="n">FILTER_RADIUS</span> <span class="o">+</span> <span class="n">fRow</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">                        <span class="n">row</span> <span class="o">-</span> <span class="n">FILTER_RADIUS</span> <span class="o">+</span> <span class="n">fRow</span> <span class="o">&lt;</span> <span class="n">height</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">                        <span class="n">col</span> <span class="o">-</span> <span class="n">FILTER_RADIUS</span> <span class="o">+</span> <span class="n">fCol</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">                        <span class="n">col</span> <span class="o">-</span> <span class="n">FILTER_RADIUS</span> <span class="o">+</span> <span class="n">fCol</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                        <span class="n">Pvalue</span> <span class="o">+=</span> <span class="n">F_c</span><span class="p">[</span><span class="n">fRow</span><span class="p">][</span><span class="n">fCol</span><span class="p">]</span> <span class="o">*</span> <span class="n">N</span><span class="p">[(</span><span class="n">row</span> <span class="o">-</span> <span class="n">FILTER_RADIUS</span> <span class="o">+</span> <span class="n">fRow</span><span class="p">)</span> <span class="o">*</span> <span class="n">width</span> <span class="o">+</span> <span class="p">(</span><span class="n">col</span> <span class="o">-</span> <span class="n">FILTER_RADIUS</span> <span class="o">+</span> <span class="n">fCol</span><span class="p">)];</span>
</span></span><span class="line"><span class="cl">                    <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">N</span><span class="p">[</span><span class="n">row</span> <span class="o">*</span> <span class="n">width</span> <span class="o">+</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">Pvalue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>Halo Cell: 实际计算区域周围添加的一圈额外的单元格。本质上是 &ldquo;虚拟&rdquo; 单元格，存在于不直接关注的区域之外。</li>
<li>Ghost Cell: 存储来自相邻 tile 的数据副本，使得 block 在无需直接访问彼此的内存的情况下访问相邻的必要数据。</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/pmpp-learning/">PMPP Learning</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/blogs/pmpp-ch9/">
    <span class="title">« Prev</span>
    <br>
    <span>PMPP Learning-Chapter 9 Parallel Histogram-An Introduction to Atomic Operations and Privatization</span>
  </a>
  <a class="next" href="http://localhost:1313/blogs/pmpp-ch6/">
    <span class="title">Next »</span>
    <br>
    <span>PMPP Learning-Chapter 6 Performance Considerations</span>
  </a>
</nav>

  </footer><script src="https://giscus.app/client.js"
        data-repo="jamesnulliu/jamesnulliu.github.io"
        data-repo-id="R_kgDOMPCQIw"
        data-category="Announcements"
        data-category-id="DIC_kwDOMPCQI84Cgb2t"
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="bottom"
        data-theme="preferred_color_scheme"
        data-lang="en"
        crossorigin="anonymous"
        async>
</script>
</article>
    </main>
    
<footer class="footer">
        <span>© 2024-2025 WITHER</span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
