<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Engineering Development Skills🔧 on WITHER</title>
    <link>http://localhost:1313/blogs/productivity/</link>
    <description>Recent content in Engineering Development Skills🔧 on WITHER</description>
    <generator>Hugo -- 0.148.1</generator>
    <language>en</language>
    <copyright>2024-2025 WITHER</copyright>
    <atom:link href="http://localhost:1313/blogs/productivity/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Cpp Lambda Expression</title>
      <link>http://localhost:1313/blogs/productivity/cpplambdaexpression/</link>
      <pubDate>Fri, 15 Aug 2025 12:16:48 +0800</pubDate>
      <guid>http://localhost:1313/blogs/productivity/cpplambdaexpression/</guid>
      <description>Lambda Expression in CPP.</description>
      <content:encoded><![CDATA[<p>C++ Lambda 表达式（也称为 Lambda 函数）是一种在代码中定义匿名函数的便捷方式。它特别适用于需要一个简短、临时的函数对象的场景，例如作为标准库算法的参数。</p>
<p>一个完整的 Lambda 表达式的通用语法如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="p">[</span><span class="n">capture</span><span class="o">-</span><span class="n">list</span><span class="p">](</span><span class="n">parameters</span><span class="p">)</span> <span class="k">mutable</span> <span class="n">exception</span> <span class="o">-&gt;</span> <span class="n">return_type</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 函数体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">statement</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ol>
<li>
<p>捕获列表 <code>[capture_list]</code> 用于控制 Lambda 函数如何从其所在的父作用域“捕获”变量。</p>
<ul>
<li><code>[]</code>：空捕获列表。表示不捕获任何外部变量。Lambda 函数体内不能访问父作用域中的任何变量。</li>
<li><code>[=]</code>：以值（by value）的方式捕获所有外部变量。在 Lambda 函数体内，你只能读取这些变量的值，不能修改它们（除非使用 mutable 关键字）。这相当于创建了外部变量的一份拷贝。</li>
<li><code>[&amp;]</code>：以引用（by reference）的方式捕获所有外部变量。在 Lambda 函数体内，你可以修改这些外部变量，并且修改会影响到原始变量。</li>
<li><code>[this]</code>：以值的方式捕获当前对象的 this 指针。这使得你可以在 Lambda 函数体内访问当前对象的成员变量和成员函数。</li>
<li><code>[a, &amp;b]</code>：指定捕获列表。这里 a 以值的方式捕获，而 b 以引用的方式捕获。你可以混合使用值捕获和引用捕获。</li>
<li><code>[=, &amp;b]</code>：以值的方式捕获所有变量，但变量 b 除外，它以引用的方式捕获。</li>
<li><code>[&amp;, a]</code>：以引用的方式捕获所有变量，但变量 a 除外，它以值的方式捕获。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 不捕获任何变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">f1</span> <span class="o">=</span> <span class="p">[]()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">5</span><span class="p">;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 以值的方式捕获 x 和 y
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">f2</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">]()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 以引用的方式捕获 x 和 y
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">f3</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">]()</span> <span class="p">{</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">25</span><span class="p">;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 混合捕获
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">f4</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">]()</span> <span class="p">{</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span> <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span> <span class="p">};</span>
</span></span></code></pre></div></li>
<li>
<p>参数列表 (parameters): 和普通函数的参数列表一样，这部分是可选的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 没有参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">greet</span> <span class="o">=</span> <span class="p">[]()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Hello, World!&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 接收两个 int 参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">add</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// C++14 以后，可以使用 auto 进行泛型参数声明
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">generic_add</span> <span class="o">=</span> <span class="p">[](</span><span class="k">auto</span> <span class="n">a</span><span class="p">,</span> <span class="k">auto</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span> <span class="p">};</span>
</span></span></code></pre></div></li>
<li>
<p>mutable 关键字 (可选): 默认情况下，通过值捕获的变量在 Lambda 函数体内是 const 的，不能修改它们。如果希望能够修改这些按值捕获的变量的拷贝（注意，这不会影响原始变量），需要使用 mutable 关键字。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">counter</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span><span class="p">]()</span> <span class="k">mutable</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">value</span><span class="o">++</span><span class="p">;</span> <span class="c1">// 如果没有 mutable，这里会编译错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">counter</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// 输出 101
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">counter</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// 输出 102
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>     <span class="c1">// 原始 value 仍然是 100
</span></span></span></code></pre></div></li>
<li>
<p>异常规范 exception (可选):可以使用 noexcept 来指明该 Lambda 函数不会抛出任何异常。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">safe_divide</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div></li>
<li>
<p>返回类型 <code>-&gt; return_type</code> (可选):
在大多数情况下，编译器可以自动推断出 Lambda 表达式的返回类型。但如果函数体包含多个 return 语句，或者希望明确指定返回类型，就可以使用这个语法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 编译器可以自动推断返回类型为 int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">add</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 明确指定返回类型为 double
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">divide</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">double</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div></li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>Regular Expression Rules</title>
      <link>http://localhost:1313/blogs/productivity/regularexpression/</link>
      <pubDate>Fri, 04 Jul 2025 10:02:17 +0800</pubDate>
      <guid>http://localhost:1313/blogs/productivity/regularexpression/</guid>
      <description>Regular Expression note.</description>
      <content:encoded><![CDATA[<h1 id="regular-expression-rules-detailed-explanation">Regular Expression Rules Detailed Explanation</h1>
<p>正则表达式 (Regular Expression，简称 regex) 是一种用于匹配和操作文本的强大工具。它通过定义特定的模式来查找、验证或替换字符串。本文档详细介绍正则表达式的规则，包括基本语法、常用元字符、量词、捕获组等，并提供示例。</p>
<h2 id="1-regular-expression-basics">1. Regular Expression Basics</h2>
<p>正则表达式由普通字符和元字符组成：</p>
<ul>
<li><strong>普通字符</strong>：如字母、数字、符号 (如 <code>a</code>、<code>1</code>、<code>@</code>)，直接匹配自身。</li>
<li><strong>元字符</strong>：具有特殊意义的字符，如 <code>.</code>、<code>^</code>、<code>*</code> 等，用于定义匹配规则。</li>
</ul>
<p>正则表达式通常用斜杠 <code>/</code> 包裹 (如 <code>/abc/</code>)，但在不同语言中可能有所不同 (例如 Python 用字符串表示，JavaScript 用 <code>/.../</code>) 。</p>
<h2 id="2-common-metacharacters">2. Common Metacharacters</h2>
<p>以下是正则表达式中常用的元字符及其含义：</p>
<table>
  <thead>
      <tr>
          <th>元字符</th>
          <th>描述</th>
          <th>示例</th>
          <th>匹配结果</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>.</code></td>
          <td>匹配除换行符 (<code>\n</code>) 外的任意单个字符</td>
          <td><code>a.c</code></td>
          <td><code>abc</code>, <code>a1c</code>, <code>a@c</code></td>
      </tr>
      <tr>
          <td><code>^</code></td>
          <td>匹配字符串的开头</td>
          <td><code>^abc</code></td>
          <td><code>abc</code> (仅在字符串开头)</td>
      </tr>
      <tr>
          <td><code>$</code></td>
          <td>匹配字符串的结尾</td>
          <td><code>abc$</code></td>
          <td><code>abc</code> (仅在字符串结尾)</td>
      </tr>
      <tr>
          <td><code>*</code></td>
          <td>匹配前面的字符或子表达式 0 次或多次</td>
          <td><code>ab*c</code></td>
          <td><code>ac</code>, <code>abc</code>, <code>abbc</code></td>
      </tr>
      <tr>
          <td><code>+</code></td>
          <td>匹配前面的字符或子表达式 1 次或多次</td>
          <td><code>ab+c</code></td>
          <td><code>abc</code>, <code>abbc</code> (不匹配 <code>ac</code>)</td>
      </tr>
      <tr>
          <td><code>?</code></td>
          <td>匹配前面的字符或子表达式 0 次或 1 次</td>
          <td><code>ab?c</code></td>
          <td><code>ac</code>, <code>abc</code></td>
      </tr>
      <tr>
          <td>`</td>
          <td>`</td>
          <td>或运算，匹配左侧或右侧的模式</td>
          <td>`a</td>
      </tr>
      <tr>
          <td><code>[]</code></td>
          <td>匹配方括号内的任意一个字符</td>
          <td><code>[abc]</code></td>
          <td><code>a</code>, <code>b</code>, 或 <code>c</code></td>
      </tr>
      <tr>
          <td><code>[^]</code></td>
          <td>匹配不在方括号内的任意字符</td>
          <td><code>[^abc]</code></td>
          <td>非 <code>a</code>、<code>b</code>、<code>c</code> 的字符</td>
      </tr>
      <tr>
          <td><code>()</code></td>
          <td>定义子表达式或捕获组</td>
          <td><code>(abc)</code></td>
          <td>匹配 <code>abc</code> 作为一个整体</td>
      </tr>
      <tr>
          <td><code>{n}</code></td>
          <td>精确匹配前面的字符或子表达式 n 次</td>
          <td><code>a{3}</code></td>
          <td><code>aaa</code></td>
      </tr>
      <tr>
          <td><code>{n,}</code></td>
          <td>匹配前面的字符或子表达式至少 n 次</td>
          <td><code>a{2,}</code></td>
          <td><code>aa</code>, <code>aaa</code>, <code>aaaa</code></td>
      </tr>
      <tr>
          <td><code>{n,m}</code></td>
          <td>匹配前面的字符或子表达式 n 到 m 次</td>
          <td><code>a{2,3}</code></td>
          <td><code>aa</code>, <code>aaa</code></td>
      </tr>
  </tbody>
</table>
<h2 id="3-character-classes">3. Character Classes</h2>
<p>字符类用于匹配特定范围或类型的字符：</p>
<ul>
<li><strong>预定义字符类</strong>：
<ul>
<li><code>\d</code>：匹配任意数字，等价于 <code>[0-9]</code>.</li>
<li><code>\D</code>：匹配非数字，等价于 <code>[^0-9]</code>.</li>
<li><code>\w</code>：匹配任意字母、数字或下划线，等价于 <code>[a-zA-Z0-9_]</code> dissuades</li>
<li><code>\W</code>：匹配非字母、数字或下划线，等价于 <code>[^a-zA-Z0-9_]</code>.</li>
<li><code>\s</code>：匹配任意空白字符 (如空格、制表符、换行符) 。</li>
<li><code>\S</code>：匹配非空白字符。</li>
</ul>
</li>
<li><strong>自定义字符类</strong>：
<ul>
<li><code>[a-z]</code>：匹配小写字母 <code>a</code> 到 <code>z</code>.</li>
<li><code>[A-Z]</code>：匹配大写字母 <code>A</code> 到 <code>Z</code>.</li>
<li><code>[0-9]</code>：匹配数字 <code>0</code> 到 <code>9</code>.</li>
<li><code>[a-zA-Z]</code>：匹配任意字母。</li>
<li><code>[a-dm-p]</code>：匹配 <code>a</code> 到 <code>d</code> 或 <code>m</code> 到 <code>p</code> 的字符。</li>
</ul>
</li>
</ul>
<p>示例：</p>
<ul>
<li><code>\d{3}</code>：匹配三个数字，如 <code>123</code>.</li>
<li><code>[a-zA-Z]+</code>：匹配一个或多个字母，如 <code>hello</code>.</li>
</ul>
<h2 id="4-quantifiers">4. Quantifiers</h2>
<p>量词控制前面的字符或子表达式的重复次数：</p>
<ul>
<li><code>*</code>：0 次或多次。</li>
<li><code>+</code>：1 次或多次。</li>
<li><code>?</code>：0 次或 1 次。</li>
<li><code>{n}</code>：精确 n 次。</li>
<li><code>{n,}</code>：至少 n 次。</li>
<li><code>{n,m}</code>：n 到 m 次。</li>
</ul>
<p><strong>贪婪模式与非贪婪模式</strong>：</p>
<ul>
<li>默认情况下，量词是<strong>贪婪模式</strong>，匹配尽可能多的字符。例如，<code>a.*b</code> 匹配 <code>a123b456b</code> 中的 <code>a123b456b</code>.</li>
<li>添加 <code>?</code> 后变为<strong>非贪婪模式</strong>，匹配尽可能少的字符。例如，<code>a.*?b</code> 匹配 <code>a123b456b</code> 中的 <code>a123b</code>.</li>
</ul>
<h2 id="5-capture-groups-and-non-capture-groups">5. Capture Groups and Non-Capture Groups</h2>
<ul>
<li><strong>捕获组</strong>：用 <code>()</code> 包裹的子表达式，可以提取匹配的内容或进行反向引用。
<ul>
<li>示例：<code>(\d{2})-(\d{2})</code> 匹配 <code>12-34</code>，捕获组 1 为 <code>12</code>，捕获组 2 为 <code>34</code>.</li>
<li>反向引用：使用 <code>\n</code> (n 为组编号) 引用捕获组。例如，<code>(a)\1</code> 匹配 <code>aa</code> (两个相同的 <code>a</code>) 。</li>
</ul>
</li>
<li><strong>非捕获组</strong>：用 <code>(?:...)</code> 定义，不保存匹配内容，仅用于分组。
<ul>
<li>示例：<code>(?:abc)</code> 匹配 <code>abc</code>，但不捕获。</li>
</ul>
</li>
</ul>
<h2 id="6-boundaries-and-assertions">6. Boundaries and Assertions</h2>
<ul>
<li><strong>单词边界</strong>：
<ul>
<li><code>\b</code>：匹配单词边界。例如，<code>\bcat\b</code> 匹配 <code>cat</code>，但不匹配 <code>category</code> 中的 <code>cat</code>.</li>
<li><code>\B</code>：匹配非单词边界。</li>
</ul>
</li>
<li><strong>前瞻与后顾断言</strong>：
<ul>
<li><code>(?=...)</code>：正向前瞻，匹配后面跟着某模式的情况。例如，<code>a(?=b)</code> 匹配 <code>ab</code> 中的 <code>a</code>.</li>
<li><code>(?!...)</code>：负向前瞻，匹配后面不跟某模式的情况。例如，<code>a(?!b)</code> 匹配 <code>ac</code> 中的 <code>a</code>.</li>
<li><code>(?&lt;=...)</code>：正向后顾，匹配前面是某模式的情况。例如，<code>(?&lt;=b)a</code> 匹配 <code>ba</code> 中的 <code>a</code>.</li>
<li><code>(?&lt;!...)</code>：负向后顾，匹配前面不是某模式的情况。例如，<code>(?&lt;!b)a</code> 匹配 <code>ca</code> 中的 <code>a</code>.</li>
</ul>
</li>
</ul>
<h2 id="7-modifiers-flags">7. Modifiers (Flags)</h2>
<p>修饰符控制正则表达式的行为，常见修饰符包括：</p>
<ul>
<li><code>i</code>：忽略大小写。例如，<code>/abc/i</code> 匹配 <code>ABC</code>.</li>
<li><code>g</code>：全局匹配，查找所有匹配项。</li>
<li><code>m</code>：多行模式，<code>^</code> 和 <code>$</code> 匹配每行的开头和结尾。</li>
<li>注意：
<ul>
<li>修饰符的写法因语言而异。例如，在 JavaScript 中，修饰符写在正则表达式后 (如 <code>/abc/gi</code>) ，而在 Python 中通过 <code>re.compile(pattern, re.IGNORECASE)</code> 指定。</li>
</ul>
</li>
</ul>
<h2 id="8-common-application-examples">8. Common Application Examples</h2>
<p>以下是一些常见的正则表达式应用场景及其示例：</p>
<ol>
<li><strong>验证邮箱格式</strong>:
<pre tabindex="0"><code class="language-regex" data-lang="regex">^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$
</code></pre></li>
<li><strong>提取 URL</strong>:
<pre tabindex="0"><code class="language-regex" data-lang="regex">https?://[^\s]+
</code></pre></li>
<li><strong>验证密码</strong> (至少 8 位，包含字母、数字、特殊字符):
<pre tabindex="0"><code class="language-regex" data-lang="regex">^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&amp;])[A-Za-z\d@$!%*?&amp;]{8,}$
</code></pre></li>
<li><strong>匹配日期格式</strong> (YYYY-MM-DD):
<pre tabindex="0"><code class="language-regex" data-lang="regex">\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[12]\d|3[01])
</code></pre></li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>🔑 Useful VSCode Shortcut keys</title>
      <link>http://localhost:1313/blogs/productivity/vscode_commands/</link>
      <pubDate>Sat, 28 Jun 2025 10:28:14 +0800</pubDate>
      <guid>http://localhost:1313/blogs/productivity/vscode_commands/</guid>
      <description>Useful VSCode Shortcut keys</description>
      <content:encoded><![CDATA[<h1 id="visual-studio-code-vscode-common-shortcut-keys">Visual Studio Code (VSCode) Common Shortcut Keys</h1>
<p>以下快捷键涵盖 <strong>文件操作、代码编辑、导航、搜索、调试</strong> 等高频场景。</p>
<hr>
<h2 id="file--editor-operations">File &amp; Editor Operations</h2>
<table>
  <thead>
      <tr>
          <th>功能</th>
          <th>Windows/Linux</th>
          <th>macOS</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>新建文件</td>
          <td><code>Ctrl + N</code></td>
          <td><code>Cmd + N</code></td>
      </tr>
      <tr>
          <td>打开文件</td>
          <td><code>Ctrl + O</code></td>
          <td><code>Cmd + O</code></td>
      </tr>
      <tr>
          <td>保存文件</td>
          <td><code>Ctrl + S</code></td>
          <td><code>Cmd + S</code></td>
      </tr>
      <tr>
          <td>另存为</td>
          <td><code>Ctrl + Shift + S</code></td>
          <td><code>Cmd + Shift + S</code></td>
      </tr>
      <tr>
          <td>关闭当前标签</td>
          <td><code>Ctrl + W</code></td>
          <td><code>Cmd + W</code></td>
      </tr>
      <tr>
          <td>重新打开已关闭文件</td>
          <td><code>Ctrl + Shift + T</code></td>
          <td><code>Cmd + Shift + T</code></td>
      </tr>
      <tr>
          <td>拆分编辑器 (分屏)</td>
          <td><code>Ctrl + \</code></td>
          <td><code>Cmd + \</code></td>
      </tr>
      <tr>
          <td>切换编辑器组</td>
          <td><code>Ctrl + 1/2/3</code></td>
          <td><code>Cmd + 1/2/3</code></td>
      </tr>
  </tbody>
</table>
<hr>
<h2 id="code-edition">Code Edition</h2>
<table>
  <thead>
      <tr>
          <th>功能</th>
          <th>Windows/Linux</th>
          <th>macOS</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>复制当前行</strong></td>
          <td><code>Ctrl + C</code> (不选中内容时)</td>
          <td><code>Cmd + C</code></td>
      </tr>
      <tr>
          <td><strong>剪切当前行</strong></td>
          <td><code>Ctrl + X</code> (不选中内容时)</td>
          <td><code>Cmd + X</code></td>
      </tr>
      <tr>
          <td><strong>删除当前行</strong></td>
          <td><code>Ctrl + Shift + K</code></td>
          <td><code>Cmd + Shift + K</code></td>
      </tr>
      <tr>
          <td><strong>上下移动行</strong></td>
          <td><code>Alt + ↑/↓</code></td>
          <td><code>Option + ↑/↓</code></td>
      </tr>
      <tr>
          <td><strong>快速复制行</strong></td>
          <td><code>Shift + Alt + ↑/↓</code></td>
          <td><code>Shift + Option + ↑/↓</code></td>
      </tr>
      <tr>
          <td><strong>跳转到匹配括号</strong></td>
          <td><code>Ctrl + Shift + \</code></td>
          <td><code>Cmd + Shift + \</code></td>
      </tr>
      <tr>
          <td><strong>代码格式化</strong></td>
          <td><code>Shift + Alt + F</code></td>
          <td><code>Shift + Option + F</code></td>
      </tr>
      <tr>
          <td><strong>行注释/取消注释</strong></td>
          <td><code>Ctrl + /</code></td>
          <td><code>Cmd + /</code></td>
      </tr>
      <tr>
          <td><strong>块注释</strong></td>
          <td><code>Shift + Alt + A</code></td>
          <td><code>Shift + Option + A</code></td>
      </tr>
  </tbody>
</table>
<hr>
<h2 id="cusor-operations">Cusor Operations</h2>
<table>
  <thead>
      <tr>
          <th>功能</th>
          <th>Windows/Linux</th>
          <th>macOS</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>多光标编辑</strong></td>
          <td><code>Alt + 单击</code></td>
          <td><code>Option + 单击</code></td>
      </tr>
      <tr>
          <td><strong>向下多光标</strong></td>
          <td><code>Ctrl + Alt + ↓</code></td>
          <td><code>Cmd + Option + ↓</code></td>
      </tr>
      <tr>
          <td><strong>向上多光标</strong></td>
          <td><code>Ctrl + Alt + ↑</code></td>
          <td><code>Cmd + Option + ↑</code></td>
      </tr>
      <tr>
          <td><strong>选中当前单词</strong></td>
          <td><code>Ctrl + D</code></td>
          <td><code>Cmd + D</code></td>
      </tr>
      <tr>
          <td><strong>选中所有匹配项</strong></td>
          <td><code>Ctrl + Shift + L</code></td>
          <td><code>Cmd + Shift + L</code></td>
      </tr>
      <tr>
          <td><strong>跳转到行首/行尾</strong></td>
          <td><code>Home</code> / <code>End</code></td>
          <td><code>Cmd + ←</code> / <code>Cmd + →</code></td>
      </tr>
  </tbody>
</table>
<hr>
<h2 id="search--substitution">Search &amp; Substitution</h2>
<table>
  <thead>
      <tr>
          <th>功能</th>
          <th>Windows/Linux</th>
          <th>macOS</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>全局搜索</strong></td>
          <td><code>Ctrl + Shift + F</code></td>
          <td><code>Cmd + Shift + F</code></td>
      </tr>
      <tr>
          <td><strong>文件内搜索</strong></td>
          <td><code>Ctrl + F</code></td>
          <td><code>Cmd + F</code></td>
      </tr>
      <tr>
          <td><strong>文件内替换</strong></td>
          <td><code>Ctrl + H</code></td>
          <td><code>Cmd + Option + F</code></td>
      </tr>
      <tr>
          <td><strong>跳转到符号 (函数/类)</strong></td>
          <td><code>Ctrl + Shift + O</code></td>
          <td><code>Cmd + Shift + O</code></td>
      </tr>
      <tr>
          <td><strong>跳转到行号</strong></td>
          <td><code>Ctrl + G</code></td>
          <td><code>Ctrl + G</code></td>
      </tr>
  </tbody>
</table>
<hr>
<h2 id="debug--terminal">Debug &amp; Terminal</h2>
<table>
  <thead>
      <tr>
          <th>功能</th>
          <th>Windows/Linux</th>
          <th>macOS</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>启动调试</strong></td>
          <td><code>F5</code></td>
          <td><code>F5</code></td>
      </tr>
      <tr>
          <td><strong>切换断点</strong></td>
          <td><code>F9</code></td>
          <td><code>F9</code></td>
      </tr>
      <tr>
          <td><strong>打开终端</strong></td>
          <td><code>Ctrl + `` </code></td>
          <td><code>Ctrl + `` </code></td>
      </tr>
      <tr>
          <td><strong>切换终端面板</strong></td>
          <td><code>Ctrl + J</code></td>
          <td><code>Cmd + J</code></td>
      </tr>
  </tbody>
</table>
<hr>
<h2 id="other-efficient-operation">Other Efficient Operation</h2>
<table>
  <thead>
      <tr>
          <th>功能</th>
          <th>Windows/Linux</th>
          <th>macOS</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>命令面板</strong> (万能快捷键)</td>
          <td><code>Ctrl + Shift + P</code></td>
          <td><code>Cmd + Shift + P</code></td>
      </tr>
      <tr>
          <td><strong>快速打开文件</strong></td>
          <td><code>Ctrl + P</code></td>
          <td><code>Cmd + P</code></td>
      </tr>
      <tr>
          <td><strong>重命名符号 (变量/函数)</strong></td>
          <td><code>F2</code></td>
          <td><code>F2</code></td>
      </tr>
      <tr>
          <td><strong>折叠/展开代码块</strong></td>
          <td><code>Ctrl + Shift + [ / ]</code></td>
          <td><code>Cmd + Option + [ / ]</code></td>
      </tr>
      <tr>
          <td><strong>折叠所有区域</strong></td>
          <td><code>Ctrl + K, Ctrl + 0</code></td>
          <td><code>Cmd + K, Cmd + 0</code></td>
      </tr>
      <tr>
          <td><strong>展开所有区域</strong></td>
          <td><code>Ctrl + K, Ctrl + J</code></td>
          <td><code>Cmd + K, Cmd + J</code></td>
      </tr>
  </tbody>
</table>
<hr>
<h2 id="customized-shortcut-keys">Customized Shortcut Keys</h2>
<ol>
<li>打开命令面板：<code>Ctrl + Shift + P</code> (Win/Linux) / <code>Cmd + Shift + P</code> (Mac).</li>
<li>搜索 <code>Preferences: Open Keyboard Shortcuts</code>.</li>
<li>修改或绑定任意快捷键。</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>A Simple Cmake Example</title>
      <link>http://localhost:1313/blogs/productivity/simple_cmake/</link>
      <pubDate>Fri, 06 Jun 2025 18:32:00 +0800</pubDate>
      <guid>http://localhost:1313/blogs/productivity/simple_cmake/</guid>
      <description>A Simple Cmake Example</description>
      <content:encoded><![CDATA[<p>CMake 入门教程：从项目结构到链接库</p>
<ol>
<li>核心理念：源码外构建 (Out-of-Source Builds)</li>
</ol>
<p>在开始之前，最重要的一点是理解 CMake 的核心哲学：源码外构建。这意味着所有由构建过程产生的文件（例如 Makefiles、Visual Studio 项目文件、目标文件 .o、可执行文件 .exe、库文件 .a 或 .so）都应该与你的源代码完全分离开。这样做最大的好处是能保持你的源码目录永远干净整洁。我们将创建一个 build 目录来存放所有这些生成的文件。</p>
<ol start="2">
<li>推荐的项目目录结构 📂</li>
</ol>
<p>一个良好组织的 C++ 项目结构不仅清晰，也让 CMake 的配置工作事半功倍。这是一个推荐的、可扩展的目录结构：my_project/</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-plaintext" data-lang="plaintext"><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── build/                  # 构建目录 (初始为空，所有生成文件都在此)
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── include/                # 存放项目全局头文件
</span></span><span class="line"><span class="cl">│   └── my_app/
</span></span><span class="line"><span class="cl">│       └── my_lib.h
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">├── src/                    # 存放所有源文件 (.cpp)
</span></span><span class="line"><span class="cl">│   │
</span></span><span class="line"><span class="cl">│   ├── main.cpp            # 主程序入口
</span></span><span class="line"><span class="cl">│   │
</span></span><span class="line"><span class="cl">│   └── my_lib/             # 一个独立的库模块
</span></span><span class="line"><span class="cl">│       ├── CMakeLists.txt  # 这个库自己的 CMake 配置文件
</span></span><span class="line"><span class="cl">│       └── my_lib.cpp
</span></span><span class="line"><span class="cl">│
</span></span><span class="line"><span class="cl">└── CMakeLists.txt          # 整个项目的顶层 CMake 配置文件
</span></span></code></pre></div><ul>
<li>build/: 这个目录用于执行所有构建命令，源码不会被污染。include/: 存放可以被项目内其他部分（或被其他项目）引用的头文件。按模块组织可以避免头文件名冲突。src/: 存放所有 .cpp 源文件。</li>
<li>src/my_lib/: 将项目按功能模块化是一种好习惯。每个模块（比如一个库）可以有自己的 CMakeLists.txt 文件，负责管理自身的编译。</li>
<li>CMakeLists.txt (顶层): 这是整个项目的入口，负责设置全局配置、找到并构建所有子模块，最后生成主程序。</li>
</ul>
<ol start="3">
<li>编写各层级的 CMakeLists.txt 📝我们将采用“自下而上”的方式来编写配置文件，先从底层的库开始，再到顶层的项目。
第 1 步: 库的 CMakeLists.txt (src/my_lib/CMakeLists.txt</li>
</ol>
<p>)这个文件只负责一件事：将 my_lib.cpp 和相关的头文件编译成一个库。# 文件位置: src/my_lib/CMakeLists.txt</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cmake" data-lang="cmake"><span class="line"><span class="cl"><span class="c"># 使用 add_library 命令创建一个库。
</span></span></span><span class="line"><span class="cl"><span class="c"># 语法: add_library(&lt;库名称&gt; [STATIC | SHARED] &lt;源文件...&gt;)
</span></span></span><span class="line"><span class="cl"><span class="c">#
</span></span></span><span class="line"><span class="cl"><span class="c"># &lt;库名称&gt;: 我们称之为 my_lib，这是其他部分链接此库时使用的名字。
</span></span></span><span class="line"><span class="cl"><span class="c"># STATIC:   生成静态链接库 (.a, .lib)。
</span></span></span><span class="line"><span class="cl"><span class="c"># SHARED:   生成动态/共享链接库 (.so, .dll)。
</span></span></span><span class="line"><span class="cl"><span class="c">#           如果不指定，默认是 STATIC。
</span></span></span><span class="line"><span class="cl"><span class="c"># &lt;源文件&gt;:  用于编译这个库的源文件列表。
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">add_library</span><span class="p">(</span><span class="s">my_lib</span> <span class="s">STATIC</span> <span class="s">my_lib.cpp</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 为这个库目标指定它需要包含的头文件目录。
</span></span></span><span class="line"><span class="cl"><span class="c"># 语法: target_include_directories(&lt;目标&gt; &lt;PUBLIC|PRIVATE|INTERFACE&gt; &lt;路径...&gt;)
</span></span></span><span class="line"><span class="cl"><span class="c">#
</span></span></span><span class="line"><span class="cl"><span class="c"># &lt;目标&gt;:    就是我们上面用 add_library 创建的 my_lib。
</span></span></span><span class="line"><span class="cl"><span class="c"># PUBLIC:   表示此头文件路径不仅 my_lib 自己需要，任何链接了 my_lib 的目标也需要。
</span></span></span><span class="line"><span class="cl"><span class="c">#           这是最关键的设置，它实现了依赖的自动传递。
</span></span></span><span class="line"><span class="cl"><span class="c"># PRIVATE:  表示此头文件路径只有 my_lib 内部编译时需要，不会传递给链接它的目标。
</span></span></span><span class="line"><span class="cl"><span class="c"># INTERFACE:表示此头文件路径只有链接它的目标需要，my_lib 自己编译时不需要。
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">target_include_directories</span><span class="p">(</span><span class="s">my_lib</span>
</span></span><span class="line"><span class="cl">  <span class="s">PUBLIC</span>
</span></span><span class="line"><span class="cl">    <span class="c"># ${PROJECT_SOURCE_DIR} 是一个非常有用的内置变量，指向顶层 CMakeLists.txt 所在的目录。
</span></span></span><span class="line"><span class="cl"><span class="c"></span>    <span class="c"># 我们将项目的全局 include 目录暴露出去。
</span></span></span><span class="line"><span class="cl"><span class="c"></span>    <span class="o">${</span><span class="nv">PROJECT_SOURCE_DIR</span><span class="o">}</span><span class="s">/include</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span></code></pre></div><ul>
<li><code>add_library()</code> 定义了一个编译目标——一个库。</li>
<li><code>target_include_directories()</code> 为这个目标指定了头文件搜索路径。使用 <code>PUBLIC </code>关键字至关重要使得任何链接到 <code>my_lib</code> 的程序都能自动找到 my_lib.h，无需在链接方再次手动添加头文件路径。</li>
</ul>
<p>第 2 步: 顶层的 CMakeLists.txt 这个文件是整个项目的总指挥，负责设置全局配置、调用子模块，并生成最终的可执行文件。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cmake" data-lang="cmake"><span class="line"><span class="cl"><span class="c"># 文件位置: my_project/CMakeLists.txt
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 1. 指定 CMake 的最低版本要求。这是每个顶层文件都应该有的第一行。
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.10</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 2. 定义项目信息。
</span></span></span><span class="line"><span class="cl"><span class="c"># 语法: project(&lt;项目名称&gt; VERSION &lt;版本号&gt; LANGUAGES &lt;语言&gt;)
</span></span></span><span class="line"><span class="cl"><span class="c"># 这会创建一些有用的变量，比如 PROJECT_NAME, PROJECT_SOURCE_DIR。
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">project</span><span class="p">(</span><span class="s">MyApp</span> <span class="s">VERSION</span> <span class="s">1.0</span> <span class="s">LANGUAGES</span> <span class="s">CXX</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 3. 设置 C++ 标准 (这是现代 CMake 推荐的方式)。
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_CXX_STANDARD</span> <span class="s">17</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_CXX_STANDARD_REQUIRED</span> <span class="s">ON</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_CXX_EXTENSIONS</span> <span class="s">OFF</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 4. 打印一条消息，方便调试时查看变量值 (可选)。
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">message</span><span class="p">(</span><span class="s">STATUS</span> <span class="s2">&#34;Project source directory is: ${PROJECT_SOURCE_DIR}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 5. 添加子目录。
</span></span></span><span class="line"><span class="cl"><span class="c"># 这个命令会告诉 CMake 去处理 src/my_lib 目录下的 CMakeLists.txt 文件。
</span></span></span><span class="line"><span class="cl"><span class="c"># 当执行到这里时，上面定义的 my_lib 库目标就会被创建出来。
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">add_subdirectory</span><span class="p">(</span><span class="s">src/my_lib</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 6. 添加可执行文件。
</span></span></span><span class="line"><span class="cl"><span class="c"># 语法: add_executable(&lt;可执行文件名&gt; &lt;源文件...&gt;)
</span></span></span><span class="line"><span class="cl"><span class="c"># 我们将主程序命名为 app，它由 src/main.cpp 编译而来。
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">add_executable</span><span class="p">(</span><span class="s">app</span> <span class="s">src/main.cpp</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 7. 链接库！这是将所有部分组合在一起的关键步骤。
</span></span></span><span class="line"><span class="cl"><span class="c"># 语法: target_link_libraries(&lt;目标&gt; &lt;PUBLIC|PRIVATE|INTERFACE&gt; &lt;要链接的库...&gt;)
</span></span></span><span class="line"><span class="cl"><span class="c">#
</span></span></span><span class="line"><span class="cl"><span class="c"># &lt;目标&gt;: 我们要链接的目标，即 app。
</span></span></span><span class="line"><span class="cl"><span class="c"># PRIVATE: 表示 app 的编译需要 my_lib，但这个依赖关系不会继续传递。
</span></span></span><span class="line"><span class="cl"><span class="c">#          对于可执行文件，通常使用 PRIVATE。
</span></span></span><span class="line"><span class="cl"><span class="c"># &lt;要链接的库&gt;: 我们在子目录中定义的库目标 my_lib。
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">target_link_libraries</span><span class="p">(</span><span class="s">app</span> <span class="s">PRIVATE</span> <span class="s">my_lib</span><span class="p">)</span><span class="err">
</span></span></span></code></pre></div><ul>
<li>add_subdirectory() 使得顶层文件保持简洁，只负责“指挥”，具体实现则交给各个子模块。</li>
<li>target_link_libraries() 负责将不同的编译目标（库和可执行文件）链接在一起，形成依赖关系。</li>
</ul>
<ol start="4">
<li>如何构建项目 🚀
现在已经写好了所有的 CMakeLists.txt 文件，可以开始构建了。整个过程都在终端中完成。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># 1. 确保你位于项目的根目录 (my_project)</span>
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> path/to/my_project
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 2. 创建并进入我们规划好的 build 目录</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">mkdir build
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> build
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 3. 运行 CMake 来生成构建系统。</span>
</span></span><span class="line"><span class="cl"><span class="c1"># &#39;..&#39; 指向上一级目录，也就是 my_project/ 根目录，CMake 会在那里寻找顶层的 CMakeLists.txt。</span>
</span></span><span class="line"><span class="cl"><span class="c1"># -DCMAKE_BUILD_TYPE=Debug 指定了构建类型为 Debug，会包含调试信息。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">cmake -DCMAKE_BUILD_TYPE<span class="o">=</span>Debug ..
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># CMake 会扫描你的系统，找到 C++ 编译器，然后根据 CMakeLists.txt 的内容</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 生成特定平台的构建文件（在 Linux/macOS 上是 Makefile，在 Windows 上是 Visual Studio sln 文件）。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 4. 编译项目</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 这个命令会调用底层的构建工具（如 make 或 msbuild）来执行真正的编译和链接工作。</span>
</span></span><span class="line"><span class="cl"><span class="c1"># &#39;--build .&#39; 是一个平台无关的命令，告诉 CMake 在当前目录执行构建。</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">cmake --build .
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 或者在 Linux/macOS 上，你可以直接运行:</span>
</span></span><span class="line"><span class="cl"><span class="c1"># make</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 编译完成后，你会在 build 目录（或其子目录）下找到你的可执行文件 `app` 和库文件 `libmy_lib.a`。</span>
</span></span></code></pre></div>]]></content:encoded>
    </item>
    <item>
      <title>How to Use git rebase</title>
      <link>http://localhost:1313/blogs/productivity/git-rebase-flow/</link>
      <pubDate>Fri, 06 Jun 2025 17:38:00 +0800</pubDate>
      <guid>http://localhost:1313/blogs/productivity/git-rebase-flow/</guid>
      <description>Use of git rebase</description>
      <content:encoded><![CDATA[<h1 id="what-can-git-rebase-do">What Can git rebase Do</h1>
<p><code>rebase</code> 的字面意思是“变基”——也就是改变一个分支的“基础”提交点。它的主要目标是：将一系列的提交以更整洁、线性的方式应用到另一个分支上，从而创造一个干净、没有多余合并记录的项目历史。</p>
<p>假设你的项目历史是这样的：你在 main 分支上切出了一个 feature 分支，之后 main 分支和你自己的 feature 分支都有了新的 commits.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-plaintext" data-lang="plaintext"><span class="line"><span class="cl">      A---B---C   &lt;-- feature
</span></span><span class="line"><span class="cl">     /
</span></span><span class="line"><span class="cl">D---E---F---G   &lt;-- main
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果你在 feature 分支上运行 git rebase main，Git 会做一件非常神奇的事：</p>
<ol>
<li>Git 会暂时“收起” feature 分支上的所有提交 (A, B, C).</li>
<li>将 feature 分支的起点移动到 main 分支的最新提交 G 上。</li>
<li>把刚才收起的提交 (A, B, C) 依次重新应用到新的起点上，形成新的提交 A&rsquo;, B&rsquo;, C'</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-plaintext" data-lang="plaintext"><span class="line"><span class="cl">              A&#39;--B&#39;--C&#39;  &lt;-- feature
</span></span><span class="line"><span class="cl">             /
</span></span><span class="line"><span class="cl">D---E---F---G   &lt;-- main
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>A&rsquo; 和 A 的内容虽然一样，但它们的 Commit ID 是不同的，因为它们的父提交变了。rebase 相当于重写了历史。</strong></p>
<p>现在，再切换回 main 分支，执行 <code>git merge feature</code>，由于 main 分支的所有历史现在是 feature 分支历史的子集，Git 只会进行一次 Fast-forward 合并，不会产生新的合并提交。最终结果如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-plaintext" data-lang="plaintext"><span class="line"><span class="cl">D---E---F---G---A&#39;--B&#39;--C&#39;  &lt;-- main, feature
</span></span></code></pre></td></tr></table>
</div>
</div><p>最终的项目历史是一条完美的直线，非常清晰，就像所有开发都是按顺序发生的一样。rebase 重写了历史，抹去了分支开发的“并行”痕迹。</p>
<h1 id="compared-to-merge">Compared to merge</h1>
<p>要理解 rebase，最好的方法就是和 merge 对比。如果在 main 分支上运行 <code>git merge feature</code>，结果会是这样</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-plaintext" data-lang="plaintext"><span class="line"><span class="cl">      A---B---C
</span></span><span class="line"><span class="cl">     /         \
</span></span><span class="line"><span class="cl">D---E---F---G---H   &lt;-- main (H 是一个合并提交)
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>merge</code> 做的事情是：</p>
<ol>
<li>找到两个分支的共同祖先 E.</li>
<li>将两个分支的修改整合起来，创建一个全新的 Merge Commit，也就是 H. 该提交有两个父提交点 C 和 G.</li>
</ol>
<p>merge 完全全保留了历史的真实性。它清楚地记录了“在某个时间点，我们把一个分支合并了进来”。但如果项目频繁合并，历史记录会充满大量的合并提交，形成一个复杂的“菱形”或“意大利面条”式的网状结构，难以阅读。</p>
<h1 id="how-to-use-rebase">How to use rebase</h1>
<p>假设你正在 feature-login 分支上开发，同时主分支 main 也有了新的更新。</p>
<ol>
<li>确保 main 分支处于最新的状态</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">git checkout main
</span></span><span class="line"><span class="cl">git pull origin main
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>切换到你正在开发的分支 <code>git checkout feature-login</code></li>
<li>把 main 分支上的最新修改 rebase 到你当前的 feature-login 分支上 <code>git rebase main</code></li>
<li>解决冲突 (如果有的话). 因为 rebase 是逐个应用提交，所以可能会在某个提交应用时发生冲突。此时，rebase 会暂停。
<ul>
<li>打开冲突文件，手动解决冲突（和 merge 冲突一样）。</li>
<li>解决后，使用 <code>git add &lt;filename&gt;</code> 将文件标记为已解决。</li>
<li>然后，继续 rebase 过程 <code>git rebase --continue</code></li>
<li>如果中途想放弃，可以回到 rebase 开始前的状态 <code>git rebase --abort</code></li>
</ul>
</li>
<li>合并到主分支
rebase 成功后，你的 feature-login 分支就已经包含了 main 的所有更新，并且<strong>你的提交都在最前面</strong>。现在可以进行一次干净的快进合并。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">git checkout main
</span></span><span class="line"><span class="cl">git merge feature-login
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="when-not-to-use-rebase">When NOT to Use rebase</h1>
<p>**永远不要对一个已经推送到 remote，并且可能被团队其他人使用的公共分支 (如 main, develop)进行 rebase！**因为 rebase 会重写历史。如果你 rebase 了一个公共分支并强制推送 (<code>git push --force</code>)，那么所有团队成员的本地历史记录都将与远程的“新历史”产生严重分歧。</p>
<p>正确用法是只在你自己的、还未与他人分享的本地分支上使用 rebase，用来整理你自己的提交记录，以便在合并到公共分支前有一个干净的历史。</p>
<h1 id="advanced-use-git-rebase--i">Advanced Use git rebase -i</h1>
<p><code>git rebase -i</code> 允许你在 rebase 的过程中，对你的提交进行编辑、合并、拆分或删除。这常用于在合并到 main 分支前，将自己本地凌乱的提交（如 &ldquo;修复拼写错误&rdquo;, &ldquo;临时提交&rdquo;, &ldquo;又改了一点&rdquo;）整理成几个有意义的提交。</p>
<p>假设你的 feature-login 分支有 3 个凌乱的提交，你想把它们合并成一个。</p>
<ol>
<li>启动交互式 rebase <code>git rebase -i HEAD~3</code>. 其中 <code>HEAD~3</code> 表示从当前提交 (HEAD) 往前数 3 个提交。</li>
<li>编辑 Rebase 脚本
Git 会打开一个文本编辑器，列出这 3 个提交：</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-plaintext" data-lang="plaintext"><span class="line"><span class="cl">pick a31ab34 complete login UI
</span></span><span class="line"><span class="cl">pick 58c34bb fix a button bug
</span></span><span class="line"><span class="cl">pick 948f2cb add backend verify logic
</span></span></code></pre></td></tr></table>
</div>
</div><p>在文件下方会有指令说明。你可以修改每一行前面的 pick 命令。比如，我们想把后两个提交合并到第一个里面：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-plaintext" data-lang="plaintext"><span class="line"><span class="cl">pick a31ab34 complete login UI
</span></span><span class="line"><span class="cl">squash 58c34bb fix a button bug
</span></span><span class="line"><span class="cl">squash 948f2cb add backend verify logic
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="3">
<li>保存并退出编辑器
Git 会开始合并提交，并弹出另一个编辑器，让你为这个合并后的新提交编写一个新的 commit message. 整理好后保存退出。现在再用 <code>git log</code> 查看，你会发现原来 3 个凌乱的提交已经变成了一个干净、完整的提交。</li>
</ol>
]]></content:encoded>
    </item>
  </channel>
</rss>
