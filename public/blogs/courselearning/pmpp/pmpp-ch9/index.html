<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=57770&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>PMPP Learning-Chapter 9 Parallel Histogram-An Introduction to Atomic Operations and Privatization | WITHER</title>
<meta name="keywords" content="CUDA">
<meta name="description" content="Personal notebook 9 of Programming Massively Parallel Processors.">
<meta name="author" content="WITHER">
<link rel="canonical" href="http://localhost:57770/blogs/courselearning/pmpp/pmpp-ch9/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5989807471fe399ba380d3b1501334cf52bf92768fffdd44127d22f5eeae9f42.css" integrity="sha256-WYmAdHH&#43;OZujgNOxUBM0z1K/knaP/91EEn0i9e6un0I=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:57770/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:57770/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:57770/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:57770/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:57770/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:57770/blogs/courselearning/pmpp/pmpp-ch9/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<script>
  MathJax = {
    tex: {
      displayMath: [['\\[', '\\]'], ['$$', '$$']],  
      inlineMath: [['\\(', '\\)'], ['$', '$']]  
    }
  };
</script>


<meta property="og:url" content="http://localhost:57770/blogs/courselearning/pmpp/pmpp-ch9/">
  <meta property="og:site_name" content="WITHER">
  <meta property="og:title" content="PMPP Learning-Chapter 9 Parallel Histogram-An Introduction to Atomic Operations and Privatization">
  <meta property="og:description" content="Personal notebook 9 of Programming Massively Parallel Processors.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="blogs">
    <meta property="article:published_time" content="2024-09-09T10:27:42+08:00">
    <meta property="article:modified_time" content="2025-06-07T23:40:58+08:00">
    <meta property="article:tag" content="PMPP Learning">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="PMPP Learning-Chapter 9 Parallel Histogram-An Introduction to Atomic Operations and Privatization">
<meta name="twitter:description" content="Personal notebook 9 of Programming Massively Parallel Processors.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Blogs",
      "item": "http://localhost:57770/blogs/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Course Learning",
      "item": "http://localhost:57770/blogs/courselearning/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Programming Massive Parallel",
      "item": "http://localhost:57770/blogs/courselearning/pmpp/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "PMPP Learning-Chapter 9 Parallel Histogram-An Introduction to Atomic Operations and Privatization",
      "item": "http://localhost:57770/blogs/courselearning/pmpp/pmpp-ch9/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "PMPP Learning-Chapter 9 Parallel Histogram-An Introduction to Atomic Operations and Privatization",
  "name": "PMPP Learning-Chapter 9 Parallel Histogram-An Introduction to Atomic Operations and Privatization",
  "description": "Personal notebook 9 of Programming Massively Parallel Processors.",
  "keywords": [
    "CUDA"
  ],
  "articleBody": "9 Parallel Histogram-An Introduction to Atomic Operations and Privatization 本章介绍并行直方图计算模式，其中每个输出元素都可以由任何线程更新。因此，当线程更新输出元素时必须注意线程之间的协调，避免任何可能破坏最终结果的干扰。\n9.1 Background 直方图是数据集中数据值出现的数量计数或百分比的显示。在最常见的直方图形式中，间隔区间沿水平轴绘制，每个间隔中的数据值计数表示为从水平轴上升的矩形或条形的高度。 许多应用领域依赖于直方图来总结数据集进行数据分析。其中一个领域就是计算机视觉。图像子区域直方图的计算过程是计算机视觉中特征 (图像中感兴趣的模式) 提取的重要方法。\nA Histogram Representation of “programming massively parallel processors”\n9.2 Atomic Operations and A Basic Histogram Kernel 如下图所示，并行化直方图计算的最直接的方法是启动数据一样多的线程，让每个线程处理一个元素。每个线程读取其分配的输入元素，并增加对应的隔计数器的值。\nBasic Parallelization of a Histogram\nhisto 数组中间隔计数器的增加是对内存位置的更新或 read-modify-write 操作。该操作包括读取内存位置(读)，在原始值上加 1(修改)，并将新值写回内存位置 (写)。在实际过程中会出现读-修改-写竞争条件 (read-modify-write race condition)，在这种情况下，两个或多个同步更新操作的结果会根据所涉及的操作的相对时间而变化。 下图 A 中线程 1 在时间段 1~3 期间完成了其读-修改-写序列的所有三个部分，然后线程 2 在时间段 4 开始，最后结果正确。在图 B 中，两个线程的读-修改-写顺序重叠。线程 1 在时间段 4 时将新值写入 histo[x]。当线程 2 在时间段 3 读取 histo[x]时，它的值仍然是 0，因此最后的写入的值是 1.\nRace Condition in Updating a histo Array Element\n原子操作 (atomic operation) 的读、修改和写部分构成一个不可分割的单元，因此称为原子操作。对该位置的其他读-修改-写序列不能与其在时间上有重叠。需要注意原子操作在线程之间不强制任何特定的执行顺序，比如线程 1 可以在线程 2 之前或之后运行。CUDA内核可以通过函数调用对内存位置执行原子加法操作:\n1 int atomicAdd(int* address, int val); atomicAdd 是一个内建函数 (intrinsic function)，它被编译成一个硬件原子操作指令。该指令读取全局或共享内存中 address 参数所指向的32位字，将 val 加上旧值中并写入结果回相同地址的内存中。该函数返回地址处的旧值。\nIntrinsic Functions 现代处理器通常提供特殊指令，这些指令要么执行关键功能 (如原子操作)，要么大幅提高性能 (如矢量指令)。这些指令通常作为内建函数暴露给程序员，从程序员的角度来看，这些是库函数。然而，它们被编译器以一种特殊的方式处理。每个这样的调用都被翻译成相应的特殊指令。在最终代码中没有函数调用，只有与用户代码一致的特殊指令。 1 2 3 4 5 6 7 8 9 10 __global__ void histo_kernel(char* data, unsigned int length, unsigned int* histo) { unsigned int i = threadIdx.x + blockIdx.x * blockDim.x; if (i \u003c length) { int alphabet_position = data[i] - 'a'; if (alphabet_position \u003e= 0 \u0026\u0026 alphabet_position \u003c 26) { atomicAdd(\u0026histo[alphabet_position / 4], 1); } } } 9.3 Latency and Throughput of Atomic Operations 高内存访问吞吐量的关键是同时进行许多 DRAM 访问。然而，当许多原子操作更新相同的内存位置时，一个后面线程的读-修改-写序列在前一个线程的写操作结束之前不能开始，即如下图所示，同时只能有一个线程在同一内存位置执行原子操作。更新这些间隔的大量争用流量会使得吞吐量降低。\nThe Execution of Atomic Operations at the Same Location\n提高原子操作吞吐量的一种方法是减少对竞争严重的位置的访问延迟。现代 GPU 允许在被所有 SM 共享的最后一级缓存中执行原子操作。由于对最后一级缓存的访问时间是几十个周期而不是几百个周期，因此原子操作的吞吐量与早期GPU相比至少提高了一个数量级。\n9.4 Privatization 提高原子操作吞吐量的另一种方法是通过引导流量远离竞争严重的位置。这可以通过一种称为私有化 (privatization) 的技术来实现。其思想是将高度竞争的输出数据结构复制到私有副本中，以便线程的每个子集都可以更新其私有副本。 下图展示了如何将私有化应用于直方图统计。每个线程块由 8 个线程组成，争用只会在同一块中的线程之间以及在最后合并私有副本时发生，而不是更新相同直方图 bin 的所有线程之间发生争用。\nReduce Contention of Atomic Operations by Private Copies of Histogram\n一个私有化版本的代码如下，为 histo 数组分配足够的设备内存 (gridDim.x*NUM_BINS*4 bytes) 来保存直方图的所有私有副本。在执行结束时，每个线程块将把私有副本中的值提交到 块 0 的部分。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #define NUM_BINS 7 // # histo bins __global__ void histo_private_kernel(char* data, unsigned int length, unsigned int* histo) { unsigned int i = threadIdx.x + blockIdx.x * blockDim.x; if (i \u003c length) { int alphabet_position = data[i] - 'a'; if (alphabet_position \u003e= 0 \u0026\u0026 alphabet_position \u003c 26) { atomicAdd(\u0026histo[blockIdx.x * 7 + alphabet_position / 4], 1); } } if (blockIdx.x \u003e 0) { __syncthreads(); // for (unsigned int bin = threadIdx.x; bin \u003c NUM_BINS; bin += blockDim.x) { unsigned int binValue = histo[blockIdx * NUM_BINS + bin]; atomicAdd(\u0026histo[bin], binValue); } } } 在每个线程块的基础上创建直方图的私有副本的一个好处是线程可以在提交自己的统计结果之前使用 __syncthreads() 来等待彼此。另一个好处是，如果直方图中的 bin 数量足够小，则可以在共享内存中声明直方图的私有副本 (每个线程块一个)。下面代码直方图在共享内存中分配私有副本 histo_s 数组，并由块的线程并行初始化为 0.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 __global__ void histo_shared_private_kernel(char* data, unsigned int length, unsigned int* histo) { // Initializing private bins __shared__ unsigned int histo_s[NUM_BINS]; for (unsigned int bin = threadIdx.x; bin \u003c NUM_BINS; bin += blockDim.x) { histo_s[bin] = 0; } __syncthreads(); // Histogram unsigned int i = threadIdx.x + blockIdx.x * blockDim.x; if (i \u003c length) { int alphabet_position = data[i] - 'a'; if (alphabet_position \u003e= 0 \u0026\u0026 alphabet_position \u003c 26) { atomicAdd(\u0026histo_s[alphabet_position / 4], 1); } } __syncthreads(); // Commit to global memory for (unsigned int bin = threadIdx.x; bin \u003c NUM_BINS; bin += blockDim.x) { unsigned binValue = histo_s[bin]; if (binValue \u003e 0) { atomicAdd(\u0026histo[bin], binValue); } } } 9.5 Coarsening 私有化的开销是需要将私有副本提交到公共副本。每个线程块都会执行一次提交操作，因此，使用的线程块越多，这个开销就越大。如下图所示，我们可以通过减少块的数量来减少私有副本的数量，从而减少提交到公共副本的次数，让每个线程处理多个输入元素。\nContiguous Partition of Input Elements\n下面代码是一个连续分区 (contiguous partition) 策略的示例，输入被连续划分成多个段，每个段被分配给一个线程，每个线程从 tid*CFACTOR 迭代到 (tid+1)*CFACTOR 进行所负责部分的统计。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #define CFACTOR 3 __global__ void histo_shared_private_contiguous_kernel(char* data, unsigned int length, unsigned int* histo) { { // Initializing private bins __shared__ unsigned int histo_s[NUM_BINS]; for (unsigned int bin = threadIdx.x; bin \u003c NUM_BINS; bin += blockDim.x) { histo_s[bin] = 0; } __syncthreads(); // Histogram unsigned tid = blockIdx.x * blockDim.x + threadIdx.x; for (unsigned int i = tid * CFACTOR; i \u003c (tid + 1)*CFACTOR \u0026\u0026 i \u003c length; i++) { int alphabet_position = data[i] - 'a'; if (alphabet_position \u003e= 0 \u0026\u0026 alphabet_position \u003c 26) { atomicAdd(\u0026histo_s[alphabet_position / 4], 1); } } __syncthreads(); // Commit to global memory for (unsigned int bin = threadIdx.x; bin \u003c NUM_BINS; bin += blockDim.x) { unsigned binValue = histo_s[bin]; if (binValue \u003e 0) { atomicAdd(\u0026histo[bin], binValue); } } } 上述在 GPU 上连续分区的思路会导致内存不友好的访问模式，因为 threadIdx 相同的线程访问的不是一块连续的内存区域。因此我们要采用交错分区 (interleaved partition)，如下图所示，即不同线程要处理的分区彼此交错。实际应用中每个线程在每次迭代中应该处理 4 个 char (一个 32 位字)，以充分利用缓存和 SMs 之间的互连带宽。\nInterleaved Partition of Input Elements\n下面代码是一个交错分区的示例。在循环的第一次迭代中，每个线程使用其全局线程索引访问数据数组:线程 0 访问元素 0，线程 1 访问元素 1，线程 2 访问元素 2…所有线程共同处理输入的第一个 blockDim.x*gridDim.x 元素。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 __global__ void histo_shared_private_interleaved_kernel(char* data, unsigned int length, unsigned int* histo) { { // Initializing private bins __shared__ unsigned int histo_s[NUM_BINS]; for (unsigned int bin = threadIdx.x; bin \u003c NUM_BINS; bin += blockDim.x) { histo_s[bin] = 0; } __syncthreads(); // Histogram unsigned tid = blockIdx.x * blockDim.x + threadIdx.x; for (unsigned int i = tid; i \u003c length; i += blockDim.x * gridDim.x) { int alphabet_position = data[i] - 'a'; if (alphabet_position \u003e= 0 \u0026\u0026 alphabet_position \u003c 26) { atomicAdd(\u0026histo_s[alphabet_position / 4], 1); } } __syncthreads(); // Commit to global memory for (unsigned int bin = threadIdx.x; bin \u003c NUM_BINS; bin += blockDim.x) { unsigned binValue = histo_s[bin]; if (binValue \u003e 0) { atomicAdd(\u0026histo[bin], binValue); } } } 9.6 Aggregation 一些数据集在局部区域有大量相同的数据值。如此高度集中的相同值会导致严重的争用，并降低并行直方图计算的吞吐量。一个简单而有效的优化是，如果每个线程正在更新直方图的相同元素，则将连续的更新聚合为单个更新。下面的代码展示了聚合的直方图计算。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 __global__ void histo_shared_private_interleaved_aggregated_kernel(char* data, unsigned int length, unsigned int* histo) { // Initializing private bins __shared__ unsigned int histo_s[NUM_BINS]; for (unsigned int bin = threadIdx.x; bin \u003c NUM_BINS; bin += blockDim.x) { histo_s[bin] = 0; } __syncthreads(); // Histogram unsigned int accumulator = 0; int prevBinIdx = -1; unsigned tid = blockIdx.x * blockDim.x + threadIdx.x; for (unsigned int i = tid; i \u003c length; i += blockDim.x * gridDim.x) { int alphabet_position = data[i] - 'a'; if (alphabet_position \u003e= 0 \u0026\u0026 alphabet_position \u003c 26) { int currBinIdx = alphabet_position / 4; if (currBinIdx != prevBinIdx) { // Update previous statistics if (accumulator \u003e 0) { atomicAdd(\u0026histo_s[prevBinIdx], accumulator); } accumulator = 1; prevBinIdx = currBinIdx; } else { // Accumulate statistics accumulator++; } } } if (accumulator \u003e 0) { // Update last bin atomicAdd(\u0026histo_s[prevBinIdx], accumulator); } __syncthreads(); // Commit to global memory for (unsigned int bin = threadIdx.x; bin \u003c NUM_BINS; bin += blockDim.x) { unsigned binValue = histo_s[bin]; if (binValue \u003e 0) { atomicAdd(\u0026histo[bin], binValue); } } } 可以看出聚合内核需要更多的语句和变量。添加的 if 语句可能会出现控制发散。然而，如果没有争用或存在严重的争用，就很少有控制发散，因为线程要么都在增加累加器值，要么都在连续刷新。\n",
  "wordCount" : "3150",
  "inLanguage": "en",
  "datePublished": "2024-09-09T10:27:42+08:00",
  "dateModified": "2025-06-07T23:40:58+08:00",
  "author":[{
    "@type": "Person",
    "name": "WITHER"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:57770/blogs/courselearning/pmpp/pmpp-ch9/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "WITHER",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:57770/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:57770/" accesskey="h" title="WITHER (Alt + H)">WITHER</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="http://localhost:57770/zh/" title="简体中文"
                            aria-label="简体中文">简体中文</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:57770/" title="🏠 Home">
                    <span>🏠 Home</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:57770/about_me/" title="🙋🏻‍♂️ Me">
                    <span>🙋🏻‍♂️ Me</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:57770/blogs/" title="📚 Blogs">
                    <span>📚 Blogs</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:57770/categories/" title="🧩 Categories">
                    <span>🧩 Categories</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:57770/tags/" title="🔖 Tags">
                    <span>🔖 Tags</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:57770/archives/" title="⏱ Archive">
                    <span>⏱ Archive</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:57770/search/" title="🔍 Search (Alt &#43; /)" accesskey=/>
                    <span>🔍 Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:57770/friends/" title="🤝 Friends">
                    <span>🤝 Friends</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:57770/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:57770/blogs/">Blogs</a>&nbsp;»&nbsp;<a href="http://localhost:57770/blogs/courselearning/">Course Learning</a>&nbsp;»&nbsp;<a href="http://localhost:57770/blogs/courselearning/pmpp/">Programming Massive Parallel</a></div>
    <h1 class="post-title entry-hint-parent">
      PMPP Learning-Chapter 9 Parallel Histogram-An Introduction to Atomic Operations and Privatization
    </h1>
    <div class="post-description">
      Personal notebook 9 of Programming Massively Parallel Processors.
    </div>
    <div class="post-meta"><span title='2024-09-09 10:27:42 +0800 CST'>Sep-09-2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;3150 words&nbsp;·&nbsp;WITHER

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">Table of Contents</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#9-parallel-histogram-an-introduction-to-atomic-operations-and-privatization" aria-label="9 Parallel Histogram-An Introduction to Atomic Operations and Privatization">9 Parallel Histogram-An Introduction to Atomic Operations and Privatization</a><ul>
                            
                    <li>
                        <a href="#91-background" aria-label="9.1 Background">9.1 Background</a></li>
                    <li>
                        <a href="#92-atomic-operations-and-a-basic-histogram-kernel" aria-label="9.2 Atomic Operations and A Basic Histogram Kernel">9.2 Atomic Operations and A Basic Histogram Kernel</a></li>
                    <li>
                        <a href="#93-latency-and-throughput-of-atomic-operations" aria-label="9.3 Latency and Throughput of Atomic Operations">9.3 Latency and Throughput of Atomic Operations</a></li>
                    <li>
                        <a href="#94-privatization" aria-label="9.4 Privatization">9.4 Privatization</a></li>
                    <li>
                        <a href="#95-coarsening" aria-label="9.5 Coarsening">9.5 Coarsening</a></li>
                    <li>
                        <a href="#96-aggregation" aria-label="9.6 Aggregation">9.6 Aggregation</a>
                    </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>
  <div class="post-content"><h1 id="9-parallel-histogram-an-introduction-to-atomic-operations-and-privatization">9 Parallel Histogram-An Introduction to Atomic Operations and Privatization<a hidden class="anchor" aria-hidden="true" href="#9-parallel-histogram-an-introduction-to-atomic-operations-and-privatization">#</a></h1>
<p>本章介绍并行直方图计算模式，其中每个输出元素都可以由任何线程更新。因此，当线程更新输出元素时必须注意线程之间的协调，避免任何可能破坏最终结果的干扰。</p>
<h2 id="91-background">9.1 Background<a hidden class="anchor" aria-hidden="true" href="#91-background">#</a></h2>
<p>直方图是数据集中数据值出现的数量计数或百分比的显示。在最常见的直方图形式中，间隔区间沿水平轴绘制，每个间隔中的数据值计数表示为从水平轴上升的矩形或条形的高度。
许多应用领域依赖于直方图来总结数据集进行数据分析。其中一个领域就是计算机视觉。图像子区域直方图的计算过程是计算机视觉中特征 (图像中感兴趣的模式) 提取的重要方法。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEBf1b2ad27e9184b6ecf628e068c42e7e4?method=download&amp;shareKey=a44ec6cce3fffb07208a7a67ee8005a5" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEBf1b2ad27e9184b6ecf628e068c42e7e4?method=download&amp;shareKey=a44ec6cce3fffb07208a7a67ee8005a5" alt="A Histogram Representation of  “programming massively parallel processors”">
    </a><figcaption>A Histogram Representation of  “programming massively parallel processors”</figcaption></figure></p>
<h2 id="92-atomic-operations-and-a-basic-histogram-kernel">9.2 Atomic Operations and A Basic Histogram Kernel<a hidden class="anchor" aria-hidden="true" href="#92-atomic-operations-and-a-basic-histogram-kernel">#</a></h2>
<p>如下图所示，并行化直方图计算的最直接的方法是启动数据一样多的线程，让每个线程处理一个元素。每个线程读取其分配的输入元素，并增加对应的隔计数器的值。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEBd162f505e52265f5421f0fa883e5d19b?method=download&amp;shareKey=4d8e366384fcc19aebe518ad8fecdc7d" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEBd162f505e52265f5421f0fa883e5d19b?method=download&amp;shareKey=4d8e366384fcc19aebe518ad8fecdc7d" alt="Basic Parallelization of a Histogram">
    </a><figcaption>Basic Parallelization of a Histogram</figcaption></figure></p>
<p>histo 数组中间隔计数器的增加是对内存位置的更新或 read-modify-write 操作。该操作包括读取内存位置(读)，在原始值上加 1(修改)，并将新值写回内存位置 (写)。在实际过程中会出现读-修改-写竞争条件 (<em>read-modify-write race condition</em>)，在这种情况下，两个或多个同步更新操作的结果会根据所涉及的操作的相对时间而变化。
下图 A 中线程 1 在时间段 1~3 期间完成了其读-修改-写序列的所有三个部分，然后线程 2 在时间段 4 开始，最后结果正确。在图 B 中，两个线程的读-修改-写顺序重叠。线程 1 在时间段 4 时将新值写入 <code>histo[x]</code>。当线程 2 在时间段 3 读取 <code>histo[x]</code>时，它的值仍然是 0，因此最后的写入的值是 1.</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEBfcb1b1249b8c3eaa4b079cc3c6211f60?method=download&amp;shareKey=6c860292730da34f80c4f3020f5e709c" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEBfcb1b1249b8c3eaa4b079cc3c6211f60?method=download&amp;shareKey=6c860292730da34f80c4f3020f5e709c" alt="Race Condition in Updating a histo Array Element">
    </a><figcaption>Race Condition in Updating a histo Array Element</figcaption></figure></p>
<p>原子操作 (<em>atomic operation</em>) 的读、修改和写部分构成一个不可分割的单元，因此称为原子操作。对该位置的其他读-修改-写序列不能与其在时间上有重叠。需要注意<em>原子操作在线程之间不强制任何特定的执行顺序</em>，比如线程 1 可以在线程 2 之前或之后运行。CUDA内核可以通过函数调用对内存位置执行原子加法操作:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">atomicAdd</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">address</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>atomicAdd</code> 是一个内建函数 (intrinsic function)，它被编译成一个硬件原子操作指令。该指令读取全局或共享内存中 <code>address</code> 参数所指向的32位字，将 <code>val</code> 加上旧值中并写入结果回相同地址的内存中。该函数返回地址处的旧值。</p>
<details class="custom-details">
    <summary class="custom-summary">Intrinsic Functions</summary>
    <div>现代处理器通常提供特殊指令，这些指令要么执行关键功能 (如原子操作)，要么大幅提高性能 (如矢量指令)。这些指令通常作为内建函数暴露给程序员，从程序员的角度来看，这些是库函数。然而，它们被编译器以一种特殊的方式处理。每个这样的调用都被翻译成相应的特殊指令。在最终代码中没有函数调用，只有与用户代码一致的特殊指令。</div>
</details><br>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">__global__</span> 
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">histo_kernel</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span> <span class="n">histo</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kt">int</span> <span class="n">alphabet_position</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">alphabet_position</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">alphabet_position</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">atomicAdd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">histo</span><span class="p">[</span><span class="n">alphabet_position</span> <span class="o">/</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="93-latency-and-throughput-of-atomic-operations">9.3 Latency and Throughput of Atomic Operations<a hidden class="anchor" aria-hidden="true" href="#93-latency-and-throughput-of-atomic-operations">#</a></h2>
<p>高内存访问吞吐量的关键是同时进行许多 DRAM 访问。然而，当许多原子操作更新相同的内存位置时，一个后面线程的读-修改-写序列在前一个线程的写操作结束之前不能开始，即如下图所示，同时只能有一个线程在同一内存位置执行原子操作。更新这些间隔的大量争用流量会使得吞吐量降低。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEBe7de6cb4432d570997a5d51a354269df?method=download&amp;shareKey=244ed14ff414262053d92e3b884321b4" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEBe7de6cb4432d570997a5d51a354269df?method=download&amp;shareKey=244ed14ff414262053d92e3b884321b4" alt="The Execution of Atomic Operations at the Same Location">
    </a><figcaption>The Execution of Atomic Operations at the Same Location</figcaption></figure></p>
<p>提高原子操作吞吐量的一种方法是减少对竞争严重的位置的访问延迟。现代 GPU 允许在被所有 SM 共享的最后一级缓存中执行原子操作。由于对最后一级缓存的访问时间是几十个周期而不是几百个周期，因此原子操作的吞吐量与早期GPU相比至少提高了一个数量级。</p>
<h2 id="94-privatization">9.4 Privatization<a hidden class="anchor" aria-hidden="true" href="#94-privatization">#</a></h2>
<p>提高原子操作吞吐量的另一种方法是通过引导流量远离竞争严重的位置。这可以通过一种称为私有化 (<em>privatization</em>) 的技术来实现。其思想是将高度竞争的输出数据结构复制到私有副本中，以便线程的每个子集都可以更新其私有副本。
下图展示了如何将私有化应用于直方图统计。每个线程块由 8 个线程组成，争用只会在同一块中的线程之间以及在最后合并私有副本时发生，而不是更新相同直方图 bin 的所有线程之间发生争用。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEBb7aa2df247e5dc432476efa8b601df20?method=download&amp;shareKey=82f3b5074429b6bf29ca79a092a0044d" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEBb7aa2df247e5dc432476efa8b601df20?method=download&amp;shareKey=82f3b5074429b6bf29ca79a092a0044d" alt="Reduce Contention of Atomic Operations by Private Copies of Histogram">
    </a><figcaption>Reduce Contention of Atomic Operations by Private Copies of Histogram</figcaption></figure></p>
<p>一个私有化版本的代码如下，为 histo 数组分配足够的设备内存 (<code>gridDim.x*NUM_BINS*4</code> bytes) 来保存直方图的所有私有副本。在执行结束时，每个线程块将把私有副本中的值提交到 块 0 的部分。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#define NUM_BINS 7  </span><span class="c1">// # histo bins 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">__global__</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">histo_private_kernel</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span> <span class="n">histo</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kt">int</span> <span class="n">alphabet_position</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">alphabet_position</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">alphabet_position</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">atomicAdd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">histo</span><span class="p">[</span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="mi">7</span> <span class="o">+</span> <span class="n">alphabet_position</span> <span class="o">/</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">__syncthreads</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">		<span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bin</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span> <span class="n">bin</span> <span class="o">&lt;</span> <span class="n">NUM_BINS</span><span class="p">;</span> <span class="n">bin</span> <span class="o">+=</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">binValue</span> <span class="o">=</span> <span class="n">histo</span><span class="p">[</span><span class="n">blockIdx</span> <span class="o">*</span> <span class="n">NUM_BINS</span> <span class="o">+</span> <span class="n">bin</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">			<span class="n">atomicAdd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">histo</span><span class="p">[</span><span class="n">bin</span><span class="p">],</span> <span class="n">binValue</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在每个线程块的基础上创建直方图的私有副本的一个好处是线程可以在提交自己的统计结果之前使用 <code>__syncthreads()</code> 来等待彼此。另一个好处是，如果直方图中的 bin 数量足够小，则可以在共享内存中声明直方图的私有副本 (每个线程块一个)。下面代码直方图在共享内存中分配私有副本 <code>histo_s</code> 数组，并由块的线程并行初始化为 0.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">__global__</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">histo_shared_private_kernel</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span> <span class="n">histo</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Initializing private bins
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">__shared__</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">histo_s</span><span class="p">[</span><span class="n">NUM_BINS</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bin</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span> <span class="n">bin</span> <span class="o">&lt;</span> <span class="n">NUM_BINS</span><span class="p">;</span> <span class="n">bin</span> <span class="o">+=</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">histo_s</span><span class="p">[</span><span class="n">bin</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">__syncthreads</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Histogram
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kt">int</span> <span class="n">alphabet_position</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">alphabet_position</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">alphabet_position</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">atomicAdd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">histo_s</span><span class="p">[</span><span class="n">alphabet_position</span> <span class="o">/</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">__syncthreads</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Commit to global memory
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bin</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span> <span class="n">bin</span> <span class="o">&lt;</span> <span class="n">NUM_BINS</span><span class="p">;</span> <span class="n">bin</span> <span class="o">+=</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kt">unsigned</span> <span class="n">binValue</span> <span class="o">=</span> <span class="n">histo_s</span><span class="p">[</span><span class="n">bin</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">binValue</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">atomicAdd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">histo</span><span class="p">[</span><span class="n">bin</span><span class="p">],</span> <span class="n">binValue</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="95-coarsening">9.5 Coarsening<a hidden class="anchor" aria-hidden="true" href="#95-coarsening">#</a></h2>
<p>私有化的开销是需要将私有副本提交到公共副本。每个线程块都会执行一次提交操作，因此，使用的线程块越多，这个开销就越大。如下图所示，我们可以通过减少块的数量来减少私有副本的数量，从而减少提交到公共副本的次数，让每个线程处理多个输入元素。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEB685390a635126cba569f8c85254bcfc5?method=download&amp;shareKey=bf894427e4a2c0fdce32f9bf00094c52" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEB685390a635126cba569f8c85254bcfc5?method=download&amp;shareKey=bf894427e4a2c0fdce32f9bf00094c52" alt="Contiguous Partition of Input Elements">
    </a><figcaption>Contiguous Partition of Input Elements</figcaption></figure></p>
<p>下面代码是一个连续分区 (<em>contiguous partition</em>) 策略的示例，输入被连续划分成多个段，每个段被分配给一个线程，每个线程从 <code>tid*CFACTOR</code> 迭代到 <code>(tid+1)*CFACTOR</code> 进行所负责部分的统计。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#define CFACTOR 3
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="n">__global__</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">histo_shared_private_contiguous_kernel</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span> <span class="n">histo</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Initializing private bins
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">__shared__</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">histo_s</span><span class="p">[</span><span class="n">NUM_BINS</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bin</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span> <span class="n">bin</span> <span class="o">&lt;</span> <span class="n">NUM_BINS</span><span class="p">;</span> <span class="n">bin</span> <span class="o">+=</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">histo_s</span><span class="p">[</span><span class="n">bin</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">__syncthreads</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Histogram
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">unsigned</span> <span class="n">tid</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">tid</span> <span class="o">*</span> <span class="n">CFACTOR</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">tid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">CFACTOR</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kt">int</span> <span class="n">alphabet_position</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">alphabet_position</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">alphabet_position</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">atomicAdd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">histo_s</span><span class="p">[</span><span class="n">alphabet_position</span> <span class="o">/</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">__syncthreads</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Commit to global memory
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bin</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span> <span class="n">bin</span> <span class="o">&lt;</span> <span class="n">NUM_BINS</span><span class="p">;</span> <span class="n">bin</span> <span class="o">+=</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kt">unsigned</span> <span class="n">binValue</span> <span class="o">=</span> <span class="n">histo_s</span><span class="p">[</span><span class="n">bin</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">binValue</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">atomicAdd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">histo</span><span class="p">[</span><span class="n">bin</span><span class="p">],</span> <span class="n">binValue</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上述在 GPU 上连续分区的思路会导致内存不友好的访问模式，因为 threadIdx 相同的线程访问的不是一块连续的内存区域。因此我们要采用交错分区 (<em>interleaved partition</em>)，如下图所示，即不同线程要处理的分区彼此交错。实际应用中每个线程在每次迭代中应该处理 4 个 char (一个 32 位字)，以充分利用缓存和 SMs 之间的互连带宽。</p>
<p>
<figure class="post-figure">
    <a href="https://note.youdao.com/yws/api/personal/file/WEB166097c6dec3a7d7eed2c82d5706bf55?method=download&amp;shareKey=79fb19c70cf16d76fdc9113eeefd12e8" target="_blank" rel="noopener">
        <img loading="lazy" src="https://note.youdao.com/yws/api/personal/file/WEB166097c6dec3a7d7eed2c82d5706bf55?method=download&amp;shareKey=79fb19c70cf16d76fdc9113eeefd12e8" alt="Interleaved Partition of Input Elements">
    </a><figcaption>Interleaved Partition of Input Elements</figcaption></figure></p>
<p>下面代码是一个交错分区的示例。在循环的第一次迭代中，每个线程使用其全局线程索引访问数据数组:线程 0 访问元素 0，线程 1 访问元素 1，线程 2 访问元素 2&hellip;所有线程共同处理输入的第一个 <code>blockDim.x*gridDim.x</code> 元素。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">__global__</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">histo_shared_private_interleaved_kernel</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span> <span class="n">histo</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Initializing private bins
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">__shared__</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">histo_s</span><span class="p">[</span><span class="n">NUM_BINS</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bin</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span> <span class="n">bin</span> <span class="o">&lt;</span> <span class="n">NUM_BINS</span><span class="p">;</span> <span class="n">bin</span> <span class="o">+=</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">histo_s</span><span class="p">[</span><span class="n">bin</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">__syncthreads</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Histogram
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">unsigned</span> <span class="n">tid</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">tid</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kt">int</span> <span class="n">alphabet_position</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">alphabet_position</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">alphabet_position</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">atomicAdd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">histo_s</span><span class="p">[</span><span class="n">alphabet_position</span> <span class="o">/</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">__syncthreads</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Commit to global memory
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bin</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span> <span class="n">bin</span> <span class="o">&lt;</span> <span class="n">NUM_BINS</span><span class="p">;</span> <span class="n">bin</span> <span class="o">+=</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kt">unsigned</span> <span class="n">binValue</span> <span class="o">=</span> <span class="n">histo_s</span><span class="p">[</span><span class="n">bin</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">binValue</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">atomicAdd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">histo</span><span class="p">[</span><span class="n">bin</span><span class="p">],</span> <span class="n">binValue</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="96-aggregation">9.6 Aggregation<a hidden class="anchor" aria-hidden="true" href="#96-aggregation">#</a></h2>
<p>一些数据集在局部区域有大量相同的数据值。如此高度集中的相同值会导致严重的争用，并降低并行直方图计算的吞吐量。一个简单而有效的优化是，如果每个线程正在更新直方图的相同元素，则将连续的更新聚合为单个更新。下面的代码展示了聚合的直方图计算。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">__global__</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">histo_shared_private_interleaved_aggregated_kernel</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span> <span class="n">histo</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Initializing private bins
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="n">__shared__</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">histo_s</span><span class="p">[</span><span class="n">NUM_BINS</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bin</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span> <span class="n">bin</span> <span class="o">&lt;</span> <span class="n">NUM_BINS</span><span class="p">;</span> <span class="n">bin</span> <span class="o">+=</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">histo_s</span><span class="p">[</span><span class="n">bin</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">__syncthreads</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Histogram
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">accumulator</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">prevBinIdx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">unsigned</span> <span class="n">tid</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">tid</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">gridDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kt">int</span> <span class="n">alphabet_position</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">alphabet_position</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">alphabet_position</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="kt">int</span> <span class="n">currBinIdx</span> <span class="o">=</span> <span class="n">alphabet_position</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="n">currBinIdx</span> <span class="o">!=</span> <span class="n">prevBinIdx</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// Update previous statistics
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="k">if</span> <span class="p">(</span><span class="n">accumulator</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="n">atomicAdd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">histo_s</span><span class="p">[</span><span class="n">prevBinIdx</span><span class="p">],</span> <span class="n">accumulator</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">				<span class="n">accumulator</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">				<span class="n">prevBinIdx</span> <span class="o">=</span> <span class="n">currBinIdx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>  <span class="c1">// Accumulate statistics
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="n">accumulator</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">accumulator</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// Update last bin
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">atomicAdd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">histo_s</span><span class="p">[</span><span class="n">prevBinIdx</span><span class="p">],</span> <span class="n">accumulator</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">__syncthreads</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Commit to global memory
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bin</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span> <span class="n">bin</span> <span class="o">&lt;</span> <span class="n">NUM_BINS</span><span class="p">;</span> <span class="n">bin</span> <span class="o">+=</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kt">unsigned</span> <span class="n">binValue</span> <span class="o">=</span> <span class="n">histo_s</span><span class="p">[</span><span class="n">bin</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">binValue</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">atomicAdd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">histo</span><span class="p">[</span><span class="n">bin</span><span class="p">],</span> <span class="n">binValue</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看出聚合内核需要更多的语句和变量。添加的 if 语句可能会出现控制发散。然而，如果没有争用或存在严重的争用，就很少有控制发散，因为线程要么都在增加累加器值，要么都在连续刷新。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:57770/tags/pmpp-learning/">PMPP Learning</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:57770/blogs/courselearning/pmpp/pmpp-ch8/">
    <span class="title">« Prev</span>
    <br>
    <span>PMPP Learning-Chapter 8 Stencil</span>
  </a>
  <a class="next" href="http://localhost:57770/blogs/courselearning/pmpp/pmpp-ch7/">
    <span class="title">Next »</span>
    <br>
    <span>PMPP Learning-Chapter 7 Convolution-An Introduction to Constant Memory and Caching</span>
  </a>
</nav>

  </footer><script src="https://giscus.app/client.js"
        data-repo="jamesnulliu/jamesnulliu.github.io"
        data-repo-id="R_kgDOMPCQIw"
        data-category="Announcements"
        data-category-id="DIC_kwDOMPCQI84Cgb2t"
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="bottom"
        data-theme="preferred_color_scheme"
        data-lang="en"
        crossorigin="anonymous"
        async>
</script>
</article>
    </main>
    
<footer class="footer">
        <span>© 2024-2025 WITHER</span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
