---
title: "Regular Expression Rules"
date: 2025-07-04T10:02:17+08:00
lastmod: 2025-07-04T10:02:17+08:00
author: ["WITHER"]

categories:
- Productivity

tags:
- Regular Expression

keywords:
- Regular Expression

description: "Regular Expression note." # 文章描述，与搜索优化相关
summary: "Regular Expression note." # 文章简单描述，会展示在主页
weight: # 输入1可以顶置文章，用来给文章展示排序，不填就默认按时间排序
slug: ""
draft: false # 是否为草稿
comments: true
showToc: true # 显示目录
TocOpen: true # 自动展开目录
autonumbering: true # 目录自动编号
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: true # 底部不显示分享栏
searchHidden: false # 该页面可以被搜索到
showbreadcrumbs: true #顶部显示当前路径
mermaid: true
cover:
    image: ""
    caption: ""
    alt: ""
    relative: false
---

# Regular Expression Rules Detailed Explanation

正则表达式 (Regular Expression，简称 regex) 是一种用于匹配和操作文本的强大工具。它通过定义特定的模式来查找、验证或替换字符串。本文档详细介绍正则表达式的规则，包括基本语法、常用元字符、量词、捕获组等，并提供示例。

## 1. Regular Expression Basics

正则表达式由普通字符和元字符组成：
- **普通字符**：如字母、数字、符号 (如 `a`、`1`、`@`)，直接匹配自身。
- **元字符**：具有特殊意义的字符，如 `.`、`^`、`*` 等，用于定义匹配规则。

正则表达式通常用斜杠 `/` 包裹 (如 `/abc/`)，但在不同语言中可能有所不同 (例如 Python 用字符串表示，JavaScript 用 `/.../`) 。

## 2. Common Metacharacters

以下是正则表达式中常用的元字符及其含义：

| 元字符 | 描述 | 示例 | 匹配结果 |
| ------ | ------ | ------ | ------ |
| `.` | 匹配除换行符 (`\n`) 外的任意单个字符 | `a.c` | `abc`, `a1c`, `a@c` |
| `^` | 匹配字符串的开头 | `^abc` | `abc` (仅在字符串开头)  |
| `$` | 匹配字符串的结尾 | `abc$` | `abc` (仅在字符串结尾)  |
| `*` | 匹配前面的字符或子表达式 0 次或多次 | `ab*c` | `ac`, `abc`, `abbc` |
| `+` | 匹配前面的字符或子表达式 1 次或多次 | `ab+c` | `abc`, `abbc` (不匹配 `ac`)  |
| `?` | 匹配前面的字符或子表达式 0 次或 1 次 | `ab?c` | `ac`, `abc` |
| `|` | 或运算，匹配左侧或右侧的模式 | `a|b` | `a` 或 `b` |
| `[]` | 匹配方括号内的任意一个字符 | `[abc]` | `a`, `b`, 或 `c` |
| `[^]` | 匹配不在方括号内的任意字符 | `[^abc]` | 非 `a`、`b`、`c` 的字符 |
| `()` | 定义子表达式或捕获组 | `(abc)` | 匹配 `abc` 作为一个整体 |
| `{n}` | 精确匹配前面的字符或子表达式 n 次 | `a{3}` | `aaa` |
| `{n,}` | 匹配前面的字符或子表达式至少 n 次 | `a{2,}` | `aa`, `aaa`, `aaaa` |
| `{n,m}` | 匹配前面的字符或子表达式 n 到 m 次 | `a{2,3}` | `aa`, `aaa` |

## 3. Character Classes

字符类用于匹配特定范围或类型的字符：

- **预定义字符类**：
  - `\d`：匹配任意数字，等价于 `[0-9]`.
  - `\D`：匹配非数字，等价于 `[^0-9]`.
  - `\w`：匹配任意字母、数字或下划线，等价于 `[a-zA-Z0-9_]` dissuades
  - `\W`：匹配非字母、数字或下划线，等价于 `[^a-zA-Z0-9_]`.
  - `\s`：匹配任意空白字符 (如空格、制表符、换行符) 。
  - `\S`：匹配非空白字符。
- **自定义字符类**：
  - `[a-z]`：匹配小写字母 `a` 到 `z`.
  - `[A-Z]`：匹配大写字母 `A` 到 `Z`.
  - `[0-9]`：匹配数字 `0` 到 `9`.
  - `[a-zA-Z]`：匹配任意字母。
  - `[a-dm-p]`：匹配 `a` 到 `d` 或 `m` 到 `p` 的字符。

示例：
- `\d{3}`：匹配三个数字，如 `123`.
- `[a-zA-Z]+`：匹配一个或多个字母，如 `hello`.

## 4. Quantifiers

量词控制前面的字符或子表达式的重复次数：

- `*`：0 次或多次。
- `+`：1 次或多次。
- `?`：0 次或 1 次。
- `{n}`：精确 n 次。
- `{n,}`：至少 n 次。
- `{n,m}`：n 到 m 次。

**贪婪模式与非贪婪模式**：
- 默认情况下，量词是**贪婪模式**，匹配尽可能多的字符。例如，`a.*b` 匹配 `a123b456b` 中的 `a123b456b`.
- 添加 `?` 后变为**非贪婪模式**，匹配尽可能少的字符。例如，`a.*?b` 匹配 `a123b456b` 中的 `a123b`.

## 5. Capture Groups and Non-Capture Groups

- **捕获组**：用 `()` 包裹的子表达式，可以提取匹配的内容或进行反向引用。
  - 示例：`(\d{2})-(\d{2})` 匹配 `12-34`，捕获组 1 为 `12`，捕获组 2 为 `34`.
  - 反向引用：使用 `\n` (n 为组编号) 引用捕获组。例如，`(a)\1` 匹配 `aa` (两个相同的 `a`) 。
- **非捕获组**：用 `(?:...)` 定义，不保存匹配内容，仅用于分组。
  - 示例：`(?:abc)` 匹配 `abc`，但不捕获。

## 6. Boundaries and Assertions

- **单词边界**：
  - `\b`：匹配单词边界。例如，`\bcat\b` 匹配 `cat`，但不匹配 `category` 中的 `cat`.
  - `\B`：匹配非单词边界。
- **前瞻与后顾断言**：
  - `(?=...)`：正向前瞻，匹配后面跟着某模式的情况。例如，`a(?=b)` 匹配 `ab` 中的 `a`.
  - `(?!...)`：负向前瞻，匹配后面不跟某模式的情况。例如，`a(?!b)` 匹配 `ac` 中的 `a`.
  - `(?<=...)`：正向后顾，匹配前面是某模式的情况。例如，`(?<=b)a` 匹配 `ba` 中的 `a`.
  - `(?<!...)`：负向后顾，匹配前面不是某模式的情况。例如，`(?<!b)a` 匹配 `ca` 中的 `a`.

## 7. Modifiers (Flags) 

修饰符控制正则表达式的行为，常见修饰符包括：
- `i`：忽略大小写。例如，`/abc/i` 匹配 `ABC`.
- `g`：全局匹配，查找所有匹配项。
- `m`：多行模式，`^` 和 `$` 匹配每行的开头和结尾。
- 注意：
  - 修饰符的写法因语言而异。例如，在 JavaScript 中，修饰符写在正则表达式后 (如 `/abc/gi`) ，而在 Python 中通过 `re.compile(pattern, re.IGNORECASE)` 指定。

## 8. Common Application Examples

以下是一些常见的正则表达式应用场景及其示例：

1. **验证邮箱格式**:
   ```regex
   ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$
   ```
2. **提取 URL**:
    ```regex
    https?://[^\s]+
    ```
3. **验证密码** (至少 8 位，包含字母、数字、特殊字符):
    ```regex
    ^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$
    ```
4. **匹配日期格式** (YYYY-MM-DD):
    ```regex
    \d{4}-(0[1-9]|1[0-2])-(0[1-9]|[12]\d|3[01])
    ```

